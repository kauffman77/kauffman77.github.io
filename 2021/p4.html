<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-04-12 Mon 11:42 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSCI 2021 Project 4: Performance Optimization and Timing</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Chris Kauffman" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, maximum-scale=1, minimum-scale=1" />
<style type="text/css">
@media screen {
:root {
--heading-bg-color:#e8c62e;
--heading-fg-color:#7a0019;
}
html {
font-family: serif;
text-align: justify;
}
pre.src, pre.example {
overflow-x: scroll;
}
/* Merge subtitle area with title area */
.subtitle {
text-align: center;
margin-top: -2em;
padding-top: 1em;
padding-bottom: 0.1em;
}
.title, .subtitle {
color: var(--heading-fg-color);
background-color: var(--heading-bg-color);
}
/* Section borders, left section header style */
div.outline-2, #table-of-contents {
background-color: rgb(250,250,250);
border: 0.75em solid var(--heading-bg-color);
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
}
div.outline-2 > h2, #table-of-contents > h2 {
background-color: var(--heading-bg-color);
color: var(--heading-fg-color);
font-variant: small-caps;
padding: 0em 0em 0em .5em; /* top right bottom left */
margin: 0em -.5em 0em -.75em; /* top right bottom left */
text-align: left;
}
blockquote {
font-style: italic;
}
td, th {
padding-top: 2px;
padding-bottom: 2px;
}
body {
background-color: #EEE;
}
pre {
}
#content, #preamble, #postamble {
margin-left:300px;
}
.tag {
background-color: inherit; font-family: inherit;
padding: inherit; font-size: 80%; font-weight: inherit;
text-transform: uppercase;
}

.figure p { text-align: inherit; }
figure-number { font-style: italic; }
#table-of-contents {
text-align: left;
position: fixed;
left: 0;
margin: 0 auto;
padding: 0;
width: 300px;
top: 0;
height: 100%;
border: 0;
display: block;
}
#text-table-of-contents {
overflow-y: scroll;
height: 100%;
}
#text-table-of-contents ul {
padding-left: 1em;
margin-left: 0.5em;
}
#table-of-contents > h2 {
padding: 0.1em;
margin: 0;
}
/* adjustments for small screen, toc at top only */
@media (max-width: 800px) { /* landscape for iphone */
html {
-webkit-text-size-adjust: none;  /* prevent scaling of text on mobile */
}
body {
background-color: #EEE;
width:100%;
margin:0 auto;
}
#content, #preamble, #postamble {
margin-left:0;
}
#table-of-contents {
position: static;
left: inherit;
width:inherit;
height: auto;
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
border: 0.75em solid #006633;
}
div.outline-2, #table-of-contents {
background-color: rgb(250,250,250);
border: 0.75em solid var(--heading-bg-color);
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
}
div.outline-2 > h2, #table-of-contents > h2 {
background-color: var(--heading-bg-color);
color: var(--heading-fg-color);
font-variant: small-caps;
padding: 0em 0em 0em .5em; /* top right bottom left */
margin: 0em -.5em 0em -.75em; /* top right bottom left */
text-align: left;
}
#text-table-of-contents {
overflow-y: visible;
height: inherit;
}
#text-table-of-contents ul {
padding-left: 1em;
margin-left: 0.5em;
}
}
.linenr { font-size: xx-small; }
}

@media print {
html {
font-family: serif;
font-size: 10pt;
text-align: justify;
.linenr { font-size: xx-small; }
}
}
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="preamble" class="status">
<i>Last Updated: 2021-04-12 Mon 11:42</i>
</div>
<div id="content">
<h1 class="title">CSCI 2021 Project 4: Performance Optimization and Timing</h1>
<ul class="org-ul">
<li><b>Due: 11:59pm Mon 4/19/2021</b></li>
<li><i>Approximately 3.0-4.0% of total grade</i></li>
<li>Submit to <a href="https://www.gradescope.com/"><b>Gradescope</b></a> (submission now REALLY open)</li>
<li>Projects are <b>individual work</b>: no collaboration with other students
is allowed. Seek help from course staff if you get stuck for too long.</li>
</ul>

<div id="outline-container-org8d0fd5c" class="outline-4">
<h4 id="org8d0fd5c">CODE/TEST DISTRIBUTION: <a href="p4-code.zip">p4-code.zip</a></h4>
</div>

<div id="outline-container-org96c453e" class="outline-4">
<h4 id="org96c453e">VIDEO OVERVIEW: <a href="https://youtu.be/jfrYPZ5UlOM">https://youtu.be/jfrYPZ5UlOM</a></h4>
</div>

<div id="outline-container-org6e58f03" class="outline-4">
<h4 id="org6e58f03">CHANGELOG:</h4>
<div class="outline-text-4" id="text-org6e58f03">
<dl class="org-dl">
<dt>Mon Apr 12 11:37:13 AM CDT 2021</dt><dd>Added in the missing <code>00_ID.txt</code>
file to <code>p4-code.zip</code> according to the report on <a href="https://piazza.com/class/kjx0d5e4nhg9z?cid=754">Post 754</a>.</dd>
</dl>
</div>
</div>

<div id="outline-container-orge9ed6db" class="outline-4">
<h4 id="orge9ed6db"></h4>
<div class="outline-text-4" id="text-orge9ed6db">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd230dd4">1. Introduction</a></li>
<li><a href="#orga9b0c2d">2. Download Code and Setup</a></li>
<li><a href="#org4247c35">3. <b>Problem 1</b>: Matrix Diagonal Sums</a>
<ul>
<li><a href="#org12de936">3.1. Overview</a></li>
<li><a href="#org59bc66b">3.2. Optimize Diagonal Sums</a></li>
<li><a href="#orgdb751b5">3.3. Evaluation on <code>csel-kh125-NN</code></a></li>
<li><a href="#org7c72cb0">3.4. <code>sumdiag_print.c</code> Testing Program</a></li>
<li><a href="#orga63dbbf">3.5. Optimization Suggestions and Documentation</a></li>
<li><a href="#org3da90b4">3.6. Grading Criteria for Problem 1 (50%)</a></li>
</ul>
</li>
<li><a href="#org584cecb">4. <b>Problem 2</b>: Timing Search Algorithms</a>
<ul>
<li><a href="#org117da5e">4.1. Overview</a></li>
<li><a href="#org1e19bda">4.2. <code>main()</code> in <code>search_benchmark.c</code></a></li>
<li><a href="#org9f4406e">4.3. Running Algorithms based on Command Line Arguments</a></li>
<li><a href="#org9574b8d">4.4. Sample <code>main()</code> Runs</a></li>
<li><a href="#org91f0bd2">4.5. Proper Setup and Cleanup for Searches</a></li>
<li><a href="#org8c9db76">4.6. What to Measure</a></li>
<li><a href="#org384a73c">4.7. MAKEUP CREDIT: Code Layout in <code>search_benchmark.c</code></a></li>
<li><a href="#org7d297d2">4.8. Grading Criteria for Problem 2 (50%)</a></li>
</ul>
</li>
<li><a href="#orgb71ffcd">5. Writeup</a></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd230dd4" class="outline-2">
<h2 id="orgd230dd4"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This assignment focuses on aspects of optimizing and measuring
performance.  
</p>
<ul class="org-ul">
<li>The first problem provides a baseline implementation for
a function and asks for a more performant version which runs
faster. To do so, one must exploit knowledge of the memory hierarchy
and processor pipeline.</li>
<li>The second problem provides a series of functions for classic search
algorithms and requires implementation of a <code>main()</code> function to
benchmark the performance of those functions.</li>
</ul>
</div>
</div>

<div id="outline-container-orga9b0c2d" class="outline-2">
<h2 id="orga9b0c2d"><span class="section-number-2">2</span> <a id="org08ceada"></a> Download Code and Setup</h2>
<div class="outline-text-2" id="text-2">
<p>
Download the code pack linked at the top of the page. Unzip this which
will create a project folder. Create new files in this
folder. Ultimately you will re-zip this folder to submit it.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">File</th>
<th scope="col" class="org-left">State</th>
<th scope="col" class="org-left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>Makefile</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 &amp; 2 Build file</td>
</tr>

<tr>
<td class="org-left"><code>P4-WRITEUP.txt</code></td>
<td class="org-left">EDIT</td>
<td class="org-left">Fill in answers to assignment questions</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>sumdiag_optm.c</code></td>
<td class="org-left">EDIT</td>
<td class="org-left">Problem 1 create and fill in optimized function definition</td>
</tr>

<tr>
<td class="org-left"><code>sumdiag_benchmark.c</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 main benchmark</td>
</tr>

<tr>
<td class="org-left"><code>sumdiag_print.c</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 testing program</td>
</tr>

<tr>
<td class="org-left"><code>sumdiag_base.c</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 baseline function to beat</td>
</tr>

<tr>
<td class="org-left"><code>matvec.h</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 header file</td>
</tr>

<tr>
<td class="org-left"><code>matvec_util.c</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 utility functions for matrices/vectors</td>
</tr>

<tr>
<td class="org-left"><code>test_sumdiag.org</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Tests to check for memory issues in problem 1</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>search.h</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 2 header file</td>
</tr>

<tr>
<td class="org-left"><code>search_funcs.c</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 2 search, setup, and cleanup functions</td>
</tr>

<tr>
<td class="org-left"><code>search_benchmark.c</code></td>
<td class="org-left">EDIT/COMPLETE</td>
<td class="org-left">Problem 2 timing <code>main()</code> to create</td>
</tr>

<tr>
<td class="org-left"><code>test_search_benchmark.org</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Tests to check for memory issues in problem 2</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>testy</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Testing script</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org4247c35" class="outline-2">
<h2 id="org4247c35"><span class="section-number-2">3</span> <b>Problem 1</b>: Matrix Diagonal Sums</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org12de936" class="outline-3">
<h3 id="org12de936"><span class="section-number-3">3.1</span> Overview</h3>
<div class="outline-text-3" id="text-3-1">
<p>
A problem that occasionally arises in numerical computing when working
with Matrices (2D Arrays) is to compute the sums of the <b>Diagonals</b> of
a matrix.  The main diagonal of a matrix is comprised of all elements
at indices (0,0), (1,1), (2,2), and so forth.  There are several
numbering schemes for diagonals but we will use the one represented in
the following diagram which also shows the sums of the diagonals.
</p>

<div class="org-center">

<div id="org5b505c4" class="figure">
<p><img src="sumdiag.png" alt="sumdiag.png" style="max-width:100%;" />
</p>
<p><span class="figure-number">Figure 1: </span>5 by 5 matrix with diagonals colored. The diagram shows our numbering scheme for diagonals and the corresponding diagonal sums. Diagonal numbers start at 0 and progress counter-clockwise around the bottom and right of the matrix. For square matrices, the main diagonal is always numbered as the #rows-1 or #cols-1 which are equal.</p>
</div>
</div>

<p>
A code is provided in the file <code>sumdiag_base.c</code> which computes the
sums of diagonals and stores them in a vector. The algorithm does so
using the most "natural" approach of walking down each diagonal and
totaling its elements then storing the result in the associated vector
element.  As you survey the code, note the use of various convenience
macros such as <code>MGET(mat,i,j)</code> and <code>VSET(vec,i,x)</code> to interact with
the matrix and vector types used.
</p>

<div class="org-src-container">
<pre class="src src-c">int sumdiag_BASE(matrix_t mat, vector_t vec) {
  if(vec.len != (mat.rows + mat.cols -1)){
    printf("sumdiag_base: bad sizes\n");
    return 1;
  }
  for(int i=0; i&lt;vec.len; i++){                   // initialize vector of diagonal sums
    VSET(vec,i,0);                                // to all 0s
  }

  for(int d=0; d &lt; mat.rows; d++){                // iterate over lower diagonals
    int c = 0;                                    // col always starts at 0 in lower diags
    for(int r=mat.rows-d-1; r&lt;mat.rows; r++,c++){ // work down rows, right cols for same diag
      int el_rc = MGET(mat, r, c);                // get matrix element on diagonal
      int vec_d = VGET(vec, d);                   // retrieve current sum for diag
      VSET(vec, d, el_rc+vec_d);                  // add on back to the diagonal sum
    }
  }

  int maxdiag = (mat.rows+mat.cols)-1;            // calculate last diagonal
  for(int d=mat.rows; d &lt; maxdiag ; d++){         // iterate starting at first upper diag
    int r = 0;                                    // row always starts at 0 in upper diags
    for(int c=d-mat.cols+1; c&lt;mat.cols; r++,c++){ // work down rows, right cols for same diag
      int el_rc = MGET(mat, r, c);                // matrix element
      int vec_d = VGET(vec, d);                   // diagonal sum from vector
      VSET(vec, d, el_rc+vec_d);                  // add on to sum
    }
  }
  return 0;                                       // return success
}
</pre>
</div>

<p>
While this algorithm is a direct translation of how humans would
visually calculate the sums of diagonals for small matrices, it is
unfortunately fairly slow when executing on most modern computing
systems.
</p>
</div>
</div>

<div id="outline-container-org59bc66b" class="outline-3">
<h3 id="org59bc66b"><span class="section-number-3">3.2</span> Optimize Diagonal Sums</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The purpose of this problem is to write <code>sumdiag_OPTM()</code> which is a
faster version of the provided <code>sumdiag_BASE()</code> to calculate the sums
of diagonals.
</p>

<p>
Write your code in the file <code>sumdiag_optm.c</code>.
</p>

<p>
Keep the following things in mind.
</p>
<ol class="org-ol">
<li>You will need to acquaint yourself with the functions and types
related to matrices and vectors provided in the <code>matvec.h</code> and
demonstrated in the baseline function. Understanding the layout of
the matrix in memory is essential to unlocking performance.</li>
<li>The goal of <code>sumdiag_OPTM()</code> is to exceed the performance of
<code>sumdiag_BASE()</code> by as much as possible.</li>
<li>To achieve this goal, several optimizations must be implemented and
suggestions are given in a later section.</li>
<li>You will need to document your optimizations in the file
<code>P4-WRITEUP.txt</code> and provide timing results of running the
optimized version.</li>
<li>Part of your grade will be based on the speed of the optimized code
on the machine <code>csel-kh1250-NN.cselabs.umn.edu</code>. The main routine
<code>sumdiag_benchmark.c</code> will be used for this.</li>
</ol>

<p>
Some details are provided in subsequent sections.
</p>
</div>
</div>


<div id="outline-container-orgdb751b5" class="outline-3">
<h3 id="orgdb751b5"><span class="section-number-3">3.3</span> Evaluation on <code>csel-kh125-NN</code></h3>
<div class="outline-text-3" id="text-3-3">
<p>
The provided file <code>sumdiag_benchmark.c</code> provides a benchmark for the
speed of diagonal summing. It will be used by graders to evaluate the
submitted code and should be used during development to gauge
performance improvements.
</p>

<p>
The machines <code>csel-kh1250-NN.cselabs.umn.edu</code> (where <code>NN</code> is <code>01, 02,
03, ... 37</code>) will be used for evaluation. The scoring present in
<code>sumdiag_benchmark.c</code> is "tuned" to these machines and will likely
report incorrect results on other machines.  That means that codes
should be <b>tested on csel-kh1250 machines</b> so that no unexpected
results occur after submission. Results reported should be from one of
<code>csel-kh1250-NN</code>.
</p>

<p>
The output of the <code>sumdiag_benchmark</code> is shown below.
</p>
<ul class="org-ul">
<li>SIZE: the size of the matrix being used. The benchmark always
uses square matrices</li>
<li>Runtimes for the 2 functions
<ul class="org-ul">
<li><code>BASE</code>: the time it takes for <code>sumdiag_BASE()</code> to complete.</li>
<li><code>OPTM</code>: the time it takes for <code>sumdiag_OPTM()</code> to complete.</li>
</ul></li>
<li>SPDUP: the speedup of <code>sumdiag_OPTM()</code> over <code>sumdiag_BASE()</code> which
is <code>BASE / OPTM</code>.</li>
<li><p>
POINTS: which are earned according to the following code:
</p>
<div class="org-src-container">
<pre class="src src-c">    double points = speedup_OPTM - 1.0;     // speedup of 1.0 is no speedup at all
    points = points &gt; 0.0 ? points : 0.0;   // no negative point values: min 0.0
</pre>
</div>
<p>
This scheme means that unless actual optimizations are implemented,
0 points will be scored.
</p></li>
</ul>

<p>
Below are several demonstration runs of <code>sumdiag_benchmark</code>.
</p>
<div class="org-src-container">
<pre class="src src-sh"># RUN ON NON-CSEL-KH1250 MACHINE: NOTE WARNINGS
homeputer&gt; ./sumdiag_benchmark 
WARNING: expected host 'csel-kh1250-NN' but got host 'homeputer'
WARNING: timing results / scoring will not reflect actual scoring
WARNING: run on host 'csel-kh1250-NN' for accurate results
==== Matrix Diagonal Sum Benchmark Version 2 ====
------ Tuned for csel-kh1250-NN machines --------
  SIZE       BASE       OPTM  SPDUP POINTS 
   512 2.3240e-03 1.1180e-03   2.08   1.08 
  1024 1.3354e-02 5.4160e-03   2.47   1.47 
  1101 1.2935e-02 1.0266e-02   1.26   0.26 
  2048 6.9519e-02 2.3286e-02   2.99   1.99 
  4099 2.9959e-01 7.1339e-02   4.20   3.20 
  6001 8.3091e-01 1.4950e-01   5.56   4.56 
  8191 2.7868e+00 2.8367e-01   9.82   8.82 
RAW POINTS: 21.37
TOTAL POINTS: 21 / 35
WARNING: expected host 'csel-kh1250-NN' but got host 'homeputer'
WARNING: timing results / scoring will not reflect actual scoring
WARNING: run on host 'csel-kh1250-NN' for accurate results

# PARTIAL CREDIT RUN
csel-kh1250-07&gt; ./sumdiag_benchmark
==== Matrix Diagonal Sum Benchmark Version 2 ====
------ Tuned for csel-kh1250-NN machines --------
  SIZE       BASE       OPTM  SPDUP POINTS 
   512 2.9110e-03 1.8990e-03   1.53   0.53 
  1024 6.5820e-03 3.8090e-03   1.73   0.73 
  1101 7.3950e-03 4.3150e-03   1.71   0.71 
  2048 8.8279e-02 1.5028e-02   5.87   4.87 
  4099 3.6446e-01 5.7960e-02   6.29   5.29 
  6001 9.2396e-01 1.2452e-01   7.42   6.42 
  8191 2.4125e+00 2.3274e-01  10.37   9.37 
RAW POINTS: 27.92
TOTAL POINTS: 28 / 35

# FULL CREDIT RUN
csel-kh1250-07&gt; ./sumdiag_benchmark
==== Matrix Diagonal Sum Benchmark Version 2 ====
------ Tuned for csel-kh1250-NN machines --------
  SIZE       BASE       OPTM  SPDUP POINTS 
   512 4.2340e-03 1.5620e-03   2.71   1.71 
  1024 7.2050e-03 3.2370e-03   2.23   1.23 
  1101 7.6120e-03 3.2760e-03   2.32   1.32 
  2048 8.9477e-02 1.1366e-02   7.87   6.87 
  4099 3.7041e-01 4.5491e-02   8.14   7.14 
  6001 9.5016e-01 9.6499e-02   9.85   8.85 
  8191 2.4793e+00 2.0149e-01  12.31  11.31 
RAW POINTS: 38.43
TOTAL POINTS: 35 / 35
</pre>
</div>

<p>
Note that it is possible to exceed the score associated with maximal
performance (as seen in the RAW POINTS reported) but no more than the
final reported points will be given for the performance portion of the
problem.
</p>
</div>
</div>

<div id="outline-container-org7c72cb0" class="outline-3">
<h3 id="org7c72cb0"><span class="section-number-3">3.4</span> <code>sumdiag_print.c</code> Testing Program</h3>
<div class="outline-text-3" id="text-3-4">
<p>
As one works on implementing optimizations in <code>sumdiag_OPTM()</code>, bugs
which compute incorrect results are often introduced.  To aid in
testing, the <code>sumdiag_print()</code> program runs both the BASE and OPTM
versions on the same matrix and shows all results. The matrix size is
determined from the command line and is printed on the screen to
enable hand verification. Examples are below.
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; ./sumdiag_print 5                    # run on a size 5 by 5 matrix; 
==== Matrix Diagonal Sum Print ====
Matrix:
5 x 5 matrix                           # shows the matrix
   0:    0    1    2    3    4 
   1:    5    6    7    8    9 
   2:   10   11   12   13   14 
   3:   15   16   17   18   19 
   4:   20   21   22   23   24 

Diagnonal Sums:                        # prints diag sums for BASE/OPTM
[ i]: BASE OPTM
[ 0]:   20   20                        # matching
[ 1]:   36   36 
[ 2]:   48   48 
[ 3]:   56   56 
[ 4]:   60   36 ***                    # not matching: OPTM is buggy
[ 5]:   40   21 ***
[ 6]:   24   10 ***
[ 7]:   12    3 ***
[ 8]:    4    0 ***

</pre>
</div>
</div>
</div>


<div id="outline-container-orga63dbbf" class="outline-3">
<h3 id="orga63dbbf"><span class="section-number-3">3.5</span> <a id="org47005c0"></a> Optimization Suggestions and Documentation</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Labs and lectures have covered several kinds of optimizations which
are useful to improve the speed of <code>sumdiag_OPTM()</code>.  These techniques
include:
</p>
<ul class="org-ul">
<li>Re-ordering memory accesses to be as sequential as possible which
favors cache (<b>very important</b>)</li>
<li>Increasing potential processor pipelining by adjusting the
destinations of arithmetic operations.</li>
<li>Decreasing any unnecessary work such as memory accesses or
arithmetic operations.</li>
</ul>
<p>
These should be sufficient to gain full credit though you are free to
explore additional optimizations.
</p>

<p>
One handy realization most folks will reach is that it is useful to be
able to compute the Diagonal an individual matrix element belongs to
based on its row/col indices.  The following formula is useful for
that:
</p>
<div class="org-src-container">
<pre class="src src-c">mat_elem = MGET(mat, col_num, row_num);         // retrive an element based on row/col
diag_num = col_num - row_num + mat.cols - 1;    // calculate the diagonal number for it
</pre>
</div>
</div>
</div>

<div id="outline-container-org3da90b4" class="outline-3 grading 50">
<h3 id="org3da90b4"><span class="section-number-3">3.6</span> Grading Criteria for Problem 1 (50%)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="grading">grading</span>&#xa0;<span class="50">50</span></span></h3>
<div class="outline-text-3" id="text-3-6">
<p>
The file <code>P4-WRITEUP.txt</code> has several questions that should be
answered in a similar fashion to lab write-ups. These document the
optimizations used in <code>sumdiag_OPTM()</code> require a justification for
their use.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-left">Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">AUTOMATED TESTS</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">No memory errors reported by Valgrind via <code>make prob1-valgrind</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">MANUAL INSPECTION of <code>sumdiag_optm.c</code></td>
</tr>

<tr>
<td class="org-right">35</td>
<td class="org-left">Performance of <code>sumdiag_OPTM()</code> on <code>csel-kh1250.cselabs.umn.edu</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">As measured by the provided <code>sumdiag_benchmark</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left"><code>P4-WRITEUP.txt</code></td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Answer 1A <code>P4-WRITEUP.txt</code> (source code)</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Answer 1B <code>P4-WRITEUP.txt</code> (timing table)</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Answer 1C <code>P4-WRITEUP.txt</code> (optimizations description)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org584cecb" class="outline-2">
<h2 id="org584cecb"><span class="section-number-2">4</span> <b>Problem 2</b>: Timing Search Algorithms</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org117da5e" class="outline-3">
<h3 id="org117da5e"><span class="section-number-3">4.1</span> Overview</h3>
<div class="outline-text-3" id="text-4-1">
<p>
This problem centers on timing several algorithms to measure their
performance. This will require use of C timing functions which have
been demonstrated in various parts of the class including the previous
problem.
</p>

<p>
You will measure the performance of 4 search functions which simply
determine whether an integer <code>query</code> is present in an associated data
structure.  All of these along with associated setup functions are
provided in the <code>search_funcs.c</code> file.  The search algorithms are as
follows.
</p>

<dl class="org-dl">
<dt>Linear Search in an Array</dt><dd>The array need not be sorted and is
searched from beginning to end.</dd>
<dt>Linear Search in a Linked List</dt><dd>Nodes are linked together and the
list is searched for a query from beginning to end.</dd>
<dt>Binary Search in a Sorted Array</dt><dd>The classic divide and conquer
algorithm which repeatedly halves the search space.</dd>
<dt>Binary Search in a Tree</dt><dd>A binary search tree enables searching
for a query by following left/right branches.</dd>
</dl>

<p>
If you do not have a sense of the relative computational complexities
of these algorithms, you should review these as they should factor
into your analysis of the timings of the algorithms.
</p>

<p>
As was the case for problem 1, you can develop your timing program on
any platform but the analysis should be conducted on
<code>csel-kh1250-NN.cselabs.umn.edu</code> to ensure comparability.
</p>
</div>
</div>


<div id="outline-container-org1e19bda" class="outline-3">
<h3 id="org1e19bda"><span class="section-number-3">4.2</span> <code>main()</code> in <code>search_benchmark.c</code></h3>
<div class="outline-text-3" id="text-4-2">
<p>
The requirements from this problem is that you provide a <code>main()</code>
function in the file <code>search_benchmark.c</code> with the following features.
</p>

<ol class="org-ol">
<li>Runs on a range of sizes that can be specified on the command
line.  A typical approach is to allow one to specify a minimum and
maximum size of the search data structures and repeatedly double
starting at the minimum and ending at the max.</li>
<li><p>
Create "even" data in the structures using the provided
functions. 
</p>
<ul class="org-ul">
<li><code>make_even_array()</code> for arrays</li>
<li><code>make_even_list()</code> for linked lists</li>
<li><code>make_even_trees()</code> for  trees</li>
</ul>
<p>
This will populate the data structure with the sequence
<code>0,2,4,...,(len-1)*2</code>.  This data population allows searches
for items that are known to be present (even numbers) and items
that are known not to be present (odd numbers).
</p></li>
<li><p>
Perform a variable number of searches on the data structures.  This
should be done the following way.
</p>
<ul class="org-ul">
<li>On the command line the number of repetitions of searches should
be specified on the command line.</li>
<li>Search for every element in the data structures the given number
of repetitions.</li>
<li>Search an equal number of times for elements NOT in the data
structure.</li>
</ul>
<p>
A typical example method for this is as follows. For a size 100
data structure perform
</p>
<ul class="org-ul">
<li>An outer loop over the number of repetitions</li>
<li>An inner loop that searches for the numbers
<code>0,1,2,3,4,...,(2*len)-1</code></li>
</ul>
<p>
This pattern searches for an equal number of present/not-present
items.
</p></li>
<li><p>
Measure the <b>Total Time for the Entire Search Loop</b> for a given
algorithm. Since individual searches will take a minuscule amount
of time, the Total Time for the loop is the most robust measure to
discuss. While such a time may include some artifacts such as
incriminating loop variables, these will be "charged" to all
algorithms equally so that the comparison remains fair. <b>Avoid use
of functions like pow()</b> as these will introduce unnecessarily
calculations inflating the measured times. Favor multiplications to
increase size such as
</p>
<pre class="example">
cur_search_size = cur_search_size * 2;
</pre></li>
<li><p>
Enable any combination of algorithms to be tested by specifying
which are to be run on  the command line.  The required way to do this
is to accept a command line argument which enables which search
types should be done.  The associated characters with each
algorithm are
</p>
<ul class="org-ul">
<li><code>a</code> for linear array search</li>
<li><code>b</code> for binary search</li>
<li><code>l</code> for linked list search</li>
<li><code>t</code> for tree search</li>
</ul>
<p>
Specify a command line argument which enables the searches:
</p>
<ul class="org-ul">
<li><code>l</code>: run linked list search only</li>
<li><code>ab</code>: run linear array search and binary array search</li>
<li><code>alt</code>: run all but the binary array search</li>
<li><code>ablt</code>: run all algorithms</li>
<li>If no string is specified, run all algorithms</li>
</ul></li>
<li>Ensure that an equal number of searches is done for each
of the algorithms being benchmarked.</li>
<li>Ensure that the timing that is done is ONLY for searching and not
for setup and cleanup for the data structures.</li>
<li>Ensure that there are no memory leaks or other problems in setup
and cleanup for the searches.</li>
</ol>
</div>
</div>

<div id="outline-container-org9f4406e" class="outline-3">
<h3 id="org9f4406e"><span class="section-number-3">4.3</span> Running Algorithms based on Command Line Arguments</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Many folks who have not had to handle command line arguments struggle
some what with the style of <code>search_benchmark</code> so here is some
additional guidance on handling this aspect of the program.
</p>
</div>


<div id="outline-container-orga93e00a" class="outline-4">
<h4 id="orga93e00a">Run the algorithms in a fixed order</h4>
<div class="outline-text-4" id="text-orga93e00a">
<p>
An invocation like
</p>
<pre class="example">
./search_benchmark 5 10 10 al
</pre>

<p>
should run the linear array search (<code>a</code>) and linear linked list search
(<code>l</code>).  So should the invocation
</p>
<pre class="example">
./search_benchmark 5 10 10 la
</pre>

<p>
Since we are interested <b>only</b> in comparing timing for these
algorithms, the order of which is run first and printed first does not
matter so <b>run the algorithms and print results in a fixed order.</b>
That is, both of the above will run the array search first and linked
list search second giving identical ordering results:
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; ./search_benchmark 5 10 10 al
  LENGTH SEARCHES      array       list 
      32      640 1.2345e+06 1.2345e+06 
      64     1280 1.2345e+06 1.2345e+06 
     128     2560 1.2345e+06 1.2345e+06 
     256     5120 1.2345e+06 1.2345e+06 
     512    10240 1.2345e+06 1.2345e+06 
    1024    20480 1.2345e+06 1.2345e+06 

&gt; ./search_benchmark 5 10 10 la           # still running linear array search first
  LENGTH SEARCHES      array       list 
      32      640 1.2345e+06 1.2345e+06 
      64     1280 1.2345e+06 1.2345e+06 
     128     2560 1.2345e+06 1.2345e+06 
     256     5120 1.2345e+06 1.2345e+06 
     512    10240 1.2345e+06 1.2345e+06 
    1024    20480 1.2345e+06 1.2345e+06 

</pre>
</div>

<p>
Search times above are intentionally left out so you will need to
trust your own code to get an idea of how long things are
running. However, very short run times are generally unreliable. Aim
for a <b>minimum time of 1e-03 seconds</b> in order to make sure your
results are reliable.  Shorter times like 1e-05 will vary too much to
trust. 
</p>
</div>
</div>

<div id="outline-container-org14ee463" class="outline-4">
<h4 id="org14ee463">Use Boolean-like variables to track which algorithms to run</h4>
<div class="outline-text-4" id="text-org14ee463">
<p>
If following the advice of the previous section, to run the 4
algorithms in a fixed order, one can simple assign variables in
<code>main()</code> which indicate which algorithms to run as in the following.
</p>
<div class="org-src-container">
<pre class="src src-c">  int run_linear_array = 0;
  int run_linear_list  = 0;
  ...
</pre>
</div>
<p>
Later, these variables are checked in a conditional as in:
</p>
<div class="org-src-container">
<pre class="src src-c">  if(run_linear_array){
    // run loops to time linear search in an array
  }
  if(run_linear_list){
    // run loops to time linear search in a list
  }
  ...
</pre>
</div>

<p>
When processing the command line argument associated with which
algorithms to run, one can 'turn on' the algorithm if the associated
character is present according to the following pseudo-code
</p>
<div class="org-src-container">
<pre class="src src-c">  set algs_string to argv[4]
  for(i=0; i &lt; length(algs_string); i++){
    if(algs_string[i] == 'a'){
      do_linear_array = 1;
    }
    ...
  }
</pre>
</div>

<p>
While the above approach does not allow one to run algorithms in an
arbitrary order, it does allow any combination of algorithms to be run
and compared which is all that is needed to complete the timing.
</p>
</div>
</div>

<div id="outline-container-org9c1f935" class="outline-4">
<h4 id="org9c1f935">Free and Re-allocate Memory for Different Sizes</h4>
<div class="outline-text-4" id="text-org9c1f935">
<p>
While the search functions for Linked Lists and Binary Search Trees
both take size arguments, these are ignored in the searches.  Instead,
<code>NULL</code>'s in the data structures are used to find the bounds of them.
This means if one is searching for data that is not in a small list,
the end of the data structure will be reached sooner and <i>not found</i>
will be determined faster than if searching in a large list.  To that
end <b>allocate data structures that are sized specifically to the
search size</b> each time. Do NOT allocate one large data structure and
do all size searches on it as this will create artificially bad
timings for the linked structures.
</p>
</div>
</div>
</div>


<div id="outline-container-org9574b8d" class="outline-3">
<h3 id="org9574b8d"><span class="section-number-3">4.4</span> Sample <code>main()</code> Runs</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Below are some sample runs of the <code>main()</code> function and output that is
produced.  Note that the times have intentionally been set to all
identical times.  Your exact output may vary some but <code>main()</code> must
use the command line options as indicated below. These arguments are
</p>
<ol class="org-ol">
<li>Minimum data size (power of 2)</li>
<li>Maximum data size (power of 2)</li>
<li>Number of repeats</li>
<li>(Optional) Characters specifying which search algorithms to run. If
this is omitted, run all algorithms.</li>
</ol>

<div class="org-src-container">
<pre class="src src-sh">&gt; ./search_benchmark 
usage: ./search_benchmark &lt;minpow&gt; &lt;maxpow&gt; &lt;repeats&gt; [which]
 which is a combination of:
  a : Linear Array Search
  l : Linked List Search
  b : Binary Array Search
  t : Binary Tree Search
  (default all)

# run all algorithms, single repetition of searches
&gt; ./search_benchmark 9 14 1 
  LENGTH SEARCHES      array       list     binary       tree 
     512     1024 1.2345e+06 1.2345e+06 1.2345e+06 1.2345e+06 
    1024     2048 1.2345e+06 1.2345e+06 1.2345e+06 1.2345e+06
    2048     4096 1.2345e+06 1.2345e+06 1.2345e+06 1.2345e+06
    4096     8192 1.2345e+06 1.2345e+06 1.2345e+06 1.2345e+06
    8192    16384 1.2345e+06 1.2345e+06 1.2345e+06 1.2345e+06
   16384    32768 1.2345e+06 1.2345e+06 1.2345e+06 1.2345e+06

# Note that SEARCHES is 2*LENGTH as 1 successful and 1 unsuccessful
# search is run for each element in the data structure

# run linear array, linked list, binary array search algorithms, 10 repetition of searches
&gt; ./search_benchmark 5 10 10 alb
  LENGTH SEARCHES      array       list     binary 
      32      640 1.2345e+06 1.2345e+06 1.2345e+06
      64     1280 1.2345e+06 1.2345e+06 1.2345e+06
     128     2560 1.2345e+06 1.2345e+06 1.2345e+06
     256     5120 1.2345e+06 1.2345e+06 1.2345e+06
     512    10240 1.2345e+06 1.2345e+06 1.2345e+06
    1024    20480 1.2345e+06 1.2345e+06 1.2345e+06

# run linear binary array and tree search algorithms, 2 repetition of searches
&gt; ./search_benchmark 14 19 2  bt
  LENGTH SEARCHES     binary       tree 
   16384    65536 1.2345e+06 1.2345e+06
   32768   131072 1.2345e+06 1.2345e+06
   65536   262144 1.2345e+06 1.2345e+06
  131072   524288 1.2345e+06 1.2345e+06
  262144  1048576 1.2345e+06 1.2345e+06
  524288  2097152 1.2345e+06 1.2345e+06

</pre>
</div>
</div>
</div>


<div id="outline-container-org91f0bd2" class="outline-3">
<h3 id="org91f0bd2"><span class="section-number-3">4.5</span> Proper Setup and Cleanup for Searches</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Each search algorithm requires setup and cleanup which is described
below. All these follow the same patter which can enable somewhat more
elegant setup/search/cleanup which is discussed in the section on
bonus credit.
</p>
</div>

<div id="outline-container-org3c78c7f" class="outline-4">
<h4 id="org3c78c7f">Linear and Binary Array Search</h4>
<div class="outline-text-4" id="text-org3c78c7f">
<p>
Use the function <code>make_evens_array()</code> to create an appropriately
sized <code>int</code> array for these functions.  Call <code>free()</code> on this array
when finished with it.
</p>
</div>
</div>

<div id="outline-container-orgf4003b2" class="outline-4">
<h4 id="orgf4003b2">Linked List Search</h4>
<div class="outline-text-4" id="text-orgf4003b2">
<p>
Use the function <code>make_evens_list()</code> to create an appropriately
sized <code>list_t</code>.  Call <code>list_free()</code> on this list when finished with
it.
</p>
</div>
</div>

<div id="outline-container-org2d233dc" class="outline-4">
<h4 id="org2d233dc">Binary Tree Search</h4>
<div class="outline-text-4" id="text-org2d233dc">
<p>
Use the function <code>make_evens_tree()</code> to create an appropriately
sized <code>bst_t</code>.  Call <code>bst_free()</code> on this list when finished with
it.
</p>
</div>
</div>
</div>

<div id="outline-container-org8c9db76" class="outline-3">
<h3 id="org8c9db76"><span class="section-number-3">4.6</span> What to Measure</h3>
<div class="outline-text-3" id="text-4-6">
<p>
The reason for the requirements mentioned above is to study the
performance of different search algorithms and answer associated
questions in the <code>P4-WRITEUP.txt</code>.  The main goals of these questions
are to elucidate.
</p>
<ol class="org-ol">
<li>To compare the linear and logarithmic search complexities to see if
one or the other is superior at small and large input sizes</li>
<li>To compare the contiguous memory (array) approaches to the linked
memory (list/tree) approaches to see if one or the other is
superior at small and large sizes.</li>
</ol>
<p>
To that end make sure to answer the thoroughly answer questions
provided.
</p>
</div>
</div>

<div id="outline-container-org384a73c" class="outline-3">
<h3 id="org384a73c"><span class="section-number-3">4.7</span> MAKEUP CREDIT: Code Layout in <code>search_benchmark.c</code></h3>
<div class="outline-text-3" id="text-4-7">
<p>
"Makeup" credit will allow the score on this assignment to exceed 100%
but will not allow the overall score on the project portion of the
grade to exceed the weight specified in the syllabus. It is designed
to help "make up" for lost credit on previous assignments.
</p>

<p>
Makeup credit is available in this assignment for implementing the
selection of which search functions to run in an "elegant" fashion.
Likely the best method for this is to use a table of function
pointers. This style is demonstrated in lab09 but must be expanded
upon in this lab to reach its full potential.
</p>

<p>
The main purpose to using such a table is to avoid a large <code>if/else</code>
or <code>switch/case</code> block.  For example, a simple approach to doing
different search types is something like the following.
</p>
<div class="org-src-container">
<pre class="src src-c">int main(...){
  int do_linear_array = 1;
  int do_linked_list  = 1;
  ...;
  for(all sizes){
    if(do_linear_array){
      // setup array
      // start timer
      // do searches
      // stop timer
      // print output
      // free the array
    }
    if(do_linked_list){
      // setup list
      // start timer
      // do searches
      // stop timer
      // print output
      // free the list
    }
    ...;
  }
}
</pre>
</div>
<p>
This formulation obviously involves a much redundant code. A good way
to avoid this is to parameterize the repeated parts as functions and
iterate over the table invoking functions appropriate to the different
types of searches.
</p>

<p>
To get a sense of how this might work, here is an incomplete example
setup used in one solution.
</p>
<div class="org-src-container">
<pre class="src src-c">// Table of search algorithms
searchalg_t algs[] = {
  {"Linear Array Search", "array",  'a', 1,
   (search_t) linear_array_search, (setup_t) make_evens_array, (cleanup_t) free},
  {"Linked List Search",  "list",   'l', 1,
   (search_t) linkedlist_search,   (setup_t) make_evens_list,  (cleanup_t) list_free},
  ...
  {NULL}
};
</pre>
</div>
<p>
None of the types are given in the above but several notable things
are present.
</p>
<ol class="org-ol">
<li>The types of searches are described in an array (table) of structs</li>
<li>Each field pertains to a description or function for the search</li>
<li>Some of the functions are for setup, others for cleanup, and the
first is the actual search function.</li>
<li>Casting is required to get the different function prototypes to
"fit" into the same kind of struct.</li>
<li>All of the searches are enabled by default but fields can changed
to disable them.</li>
<li>One only needs to iterate through the array invoking appropriate
functions. This avoids the need for a large <code>if/else</code> style
program.</li>
</ol>

<p>
To complete this part, document your code with comments and also
describe you design using function pointers/structs in
<code>P4-WRITEUP.txt</code>.
</p>

<p>
For those interested in completing the MAKEUP credit, have a look at
the <a href="https://www-users.cs.umn.edu/~kauffman/2021/function-pointers.html">Function Pointer in C</a> tutorial which is linked from the course
schedule. 
</p>

<p>
<b>WARNING:</b> Staff will not assist students with the MAKEUP portion
unless they have already completed a "standard" implementation of the
<code>search_benchmark</code> program.  Students should start with an <code>if/else</code>
structure, produce timing results, complete the <code>P4-WRITEUP.txt</code>
questions, <b>and then</b> move on to the MAKEUP credit.
</p>
</div>
</div>

<div id="outline-container-org7d297d2" class="outline-3 grading 50">
<h3 id="org7d297d2"><span class="section-number-3">4.8</span> Grading Criteria for Problem 2 (50%)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="grading">grading</span>&#xa0;<span class="50">50</span></span></h3>
<div class="outline-text-3" id="text-4-8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-left">Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">AUTOMATED TESTS</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">No memory errors reported by <code>make test-prob2</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">MANUAL INSPECTION of <code>search_benchmark.c</code></td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Accepts parameters that control the min/max data sizes and number of repeats</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Proper searching for success and fail elements</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">The Total Search Loop Time is measured for each algorithm and reported, not an average per search</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Timing does not include memory allocationo/de-allocation</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Allocates data that is exactly to search sizes to prevent handicapping lists and arrays</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Clean and well-documented code for <code>main()</code> that uses simple approaches to run algorithms requested</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left"><code>P4-WRITEUP.txt</code></td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Timing results larger than 1e-03 seconds for most cases; smaller times are unreliable.</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Answer 2A <code>P4-WRITEUP.txt</code> (min size for differences)</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">Answer 2B <code>P4-WRITEUP.txt</code> (list vs array)</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-left">Answer 2C <code>P4-WRITEUP.txt</code> (tree vs array))</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">Answer 2D <code>P4-WRITEUP.txt</code> (caching effects))</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">OPTIONAL MAKEUP CREDIT</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">Use a table of function pointers effectively in <code>search_benchmark.c</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Must describe this design in section 2E of <code>P4-WRITEUP.txt</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-orgb71ffcd" class="outline-2">
<h2 id="orgb71ffcd"><span class="section-number-2">5</span> Writeup</h2>
<div class="outline-text-2" id="text-5">
<p>
This assignment involves answering questions in the file
<code>P4-WRITEUP.txt</code> which is included in the code pack and pasted below.
</p>

<div class="org-src-container">
<pre class="src src-text">                              ____________

                               P4 WRITEUP
                              ____________


- Name: (FILL THIS in)
- NetID: (THE kauf0095 IN kauf0095@umn.edu)

Answer the questions below according to the project specification. Write
your answers directly in this text file and submit it along with your
code.


PROBLEM 1: sumdiag_OPTM()
=========================

  Do your timing study on csel-keller1250-NN.cselabs.umn.edu


(A) Paste Source Code
~~~~~~~~~~~~~~~~~~~~~

  Paste a copy of your source code for the function `sumdiag_OPTM()'

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(B) Timing on csel-kh1250-NN
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Paste a copy of the results of running `sumdiag_benchmark' on
  csel-kh1250-NN.cselabs.umn.edu in the space below which shows how your
  performance optimizations improved on the baseline codes.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(C) Optimizations
~~~~~~~~~~~~~~~~~

  Describe in some detail the optimizations you used to speed the code
  up.  THE CODE SHOULD CONTAIN SOME COMMENTS already to describe these
  but in the section below, describe in English the techniques you used
  to make the code run faster.  Format your descriptions into discrete
  chunks such as.
        Optimization 1: Blah bla blah... This should make run
        faster because yakkety yakeety yak.

        Optimization 2: Blah bla blah... This should make run
        faster because yakkety yakeety yak.

        ...  Optimization N: Blah bla blah... This should make run
        faster because yakkety yakeety yak.
  Full credit solutions will have a least two optimizations and describe
  WHY these improved performance in at least a couple sentences.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


PROBLEM 2: Timing Search Algorithms
===================================

  Do your timing study on csel-kh1250-NN.cselabs.umn.edu. In most cases,
  report times larger than 1e-03 seconds as times shorter than this are
  unreliable. Run searches for more repetitions to lengthen run times.


(A) Min Size for Algorithmic Differences
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Determine the size of input array where one starts to see a measurable
  difference in the performance of the linear and logarithmic
  algorithms.  Produce a timing table which includes all algorithms
  which clearly demonstrates an uptick in the times associated with some
  while others remain much lower.  Identify what size this appears to be
  a occur.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(B) Linear Search in List vs Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Determine whether the linear array and linked list search remain
  approximately at the same performance level as size increases to large
  data or whether one begins to become favorable over other. Determine
  the approximate size at which this divergence becomes obvious. Discuss
  reasons WHY this difference arises.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(C) Binary Search in Tree vs Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Compare the binary array search and binary tree search on small to
  very large arrays. Determine if there is a size at which the
  performance of these two begins to diverge. If so, describe why this
  might be happening based on your understanding of the data structures
  and the memory system. If not, describe why you believe there is
  little performance difference between the two.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(D) Caching Effects on Algorithms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  It is commonly believed that memory systems that feature a Cache will
  lead to arrays performing faster than linked structures such as Linked
  Lists and Binary Search Trees. Describe whether your timings confirm
  or refute this belief.  Address both types of algorithms in your
  answer:
  - What effects does Cache have on Linear Search in arrays and lists
    and why?
  - What effects does Cache have on Binary Search in arrays and trees
    and why?

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(E) OPTIONAL MAKEUP CREDIT
~~~~~~~~~~~~~~~~~~~~~~~~~~

  If you decided to make use of a table of function pointers/structs
  which is worth makeup credit, describe your basic design for this
  below.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr/> <i> Author: Chris Kauffman (<a href="mailto:kauffman@umn.edu">kauffman@umn.edu</a>) <br/> Date: 2021-04-12 Mon 11:42 <br/> </i>
</div>
</body>
</html>
