<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-11-17 Thu 14:15 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSCI 2021 Project 4: Performance Optimization and Timing</title>
<meta name="author" content="Chris Kauffman" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<meta name="viewport" content="width=device-width, maximum-scale=1, minimum-scale=1" />
<style type="text/css">
@media screen {
:root {
--heading-bg-color:#e8c62e;
--heading-fg-color:#7a0019;
}
html {
font-family: serif;
text-align: justify;
}
pre.src, pre.example {
overflow-x: scroll;
}
/* Merge subtitle area with title area */
.subtitle {
text-align: center;
margin-top: -2em;
padding-top: 1em;
padding-bottom: 0.1em;
}
.title, .subtitle {
color: var(--heading-fg-color);
background-color: var(--heading-bg-color);
}
/* Section borders, left section header style */
div.outline-2, #table-of-contents {
background-color: rgb(250,250,250);
border: 0.75em solid var(--heading-bg-color);
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
}
div.outline-2 > h2, #table-of-contents > h2 {
background-color: var(--heading-bg-color);
color: var(--heading-fg-color);
font-variant: small-caps;
padding: 0em 0em 0em .5em; /* top right bottom left */
margin: 0em -.5em 0em -.75em; /* top right bottom left */
text-align: left;
}
blockquote {
font-style: italic;
}
td, th {
padding-top: 2px;
padding-bottom: 2px;
}
body {
background-color: #EEE;
}
pre {
}
#content, #preamble, #postamble {
margin-left:300px;
max-width: 100%;
}
.tag {
background-color: inherit; font-family: inherit;
padding: inherit; font-size: 80%; font-weight: inherit;
text-transform: uppercase;
}

.figure p { text-align: inherit; }
figure-number { font-style: italic; }
#table-of-contents {
text-align: left;
position: fixed;
left: 0;
margin: 0 auto;
padding: 0;
width: 300px;
top: 0;
height: 100%;
border: 0;
display: block;
}
#text-table-of-contents {
overflow-y: scroll;
height: 100%;
}
#text-table-of-contents ul {
padding-left: 1em;
margin-left: 0.5em;
}
#table-of-contents > h2 {
padding: 0.1em;
margin: 0;
}
/* adjustments for small screen, toc at top only */
@media (max-width: 800px) { /* landscape for iphone */
html {
-webkit-text-size-adjust: none;  /* prevent scaling of text on mobile */
}
body {
background-color: #EEE;
width:100%;
margin:0 auto;
}
#content, #preamble, #postamble {
margin-left:0;
}
#table-of-contents {
position: static;
left: inherit;
width:inherit;
height: auto;
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
border: 0.75em solid #006633;
}
div.outline-2, #table-of-contents {
background-color: rgb(250,250,250);
border: 0.75em solid var(--heading-bg-color);
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
}
div.outline-2 > h2, #table-of-contents > h2 {
background-color: var(--heading-bg-color);
color: var(--heading-fg-color);
font-variant: small-caps;
padding: 0em 0em 0em .5em; /* top right bottom left */
margin: 0em -.5em 0em -.75em; /* top right bottom left */
text-align: left;
}
#text-table-of-contents {
overflow-y: visible;
height: inherit;
}
#text-table-of-contents ul {
padding-left: 1em;
margin-left: 0.5em;
}
}
.linenr { font-size: xx-small; }
}

@media print {
html {
font-family: serif;
font-size: 10pt;
text-align: justify;
.linenr { font-size: xx-small; }
}
}
</style>
</head>
<body>
<div id="preamble" class="status">
<i>Last Updated: 2022-11-17 Thu 14:15</i>
</div>
<div id="content" class="content">
<h1 class="title">CSCI 2021 Project 4: Performance Optimization and Timing</h1>
<ul class="org-ul">
<li><b>Due: 11:59pm Wed 30-Nov-2022</b></li>
<li><i>Approximately 3.0-4.0% of total grade</i></li>
<li>Submit to <a href="https://www.gradescope.com/"><b>Gradescope</b></a></li>
<li>Projects are <b>individual work</b>: no collaboration with other students
is allowed. Seek help from course staff if you get stuck for too long.</li>
</ul>

<div id="outline-container-org0b3bd8a" class="outline-4">
<h4 id="org0b3bd8a">CODE/TEST DISTRIBUTION: <a href="p4-code.zip">p4-code.zip</a></h4>
</div>
<div id="outline-container-org47a46ca" class="outline-4">
<h4 id="org47a46ca">Video Overview: <a href="https://youtu.be/bHYAIGX9sUM">https://youtu.be/bHYAIGX9sUM</a></h4>
</div>
<div id="outline-container-orgfcb51c9" class="outline-4">
<h4 id="orgfcb51c9">CHANGELOG:</h4>
<div class="outline-text-4" id="text-orgfcb51c9">
<dl class="org-dl">
<dt>Thu Nov 17 02:13:57 PM CST 2022</dt><dd>A Video Overview of Project 4 has
been added. Several hints are offered in the video which may be
worth your time to consider. The video is linked at the top of the
P4 spec and directly here: <a href="https://youtu.be/bHYAIGX9sUM">https://youtu.be/bHYAIGX9sUM</a></dd>
</dl>
</div>
</div>

<div id="outline-container-orga14d188" class="outline-4">
<h4 id="orga14d188"></h4>
<div class="outline-text-4" id="text-orga14d188">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org34f829c">1. Introduction</a></li>
<li><a href="#org0364d10">2. Download Code and Setup</a></li>
<li><a href="#org15011ad">3. <b>Problem 1</b>: Matrix Diagonal Sums</a>
<ul>
<li><a href="#org848b490">3.1. Overview</a></li>
<li><a href="#org10bd2fd">3.2. Optimize Diagonal Sums</a></li>
<li><a href="#orgfdc4c6c">3.3. Evaluation on <code>loginNN</code></a></li>
<li><a href="#orgc966a6d">3.4. <code>sumdiag_print.c</code> Testing Program</a></li>
<li><a href="#optimizations">3.5. Optimization Suggestions and Documentation</a></li>
<li><a href="#org2d8f54d">3.6. Grading Criteria for Problem 1 (50%)</a></li>
</ul>
</li>
<li><a href="#org83f5937">4. <b>Problem 2</b>: Timing Search Algorithms</a>
<ul>
<li><a href="#org3a734e1">4.1. Overview</a></li>
<li><a href="#orgae662f1">4.2. <code>main()</code> in <code>search_benchmark.c</code></a></li>
<li><a href="#search-benchmark-runs">4.3. Sample Runs</a></li>
<li><a href="#orgd0701d6">4.4. Running Algorithms based on Command Line Arguments</a></li>
<li><a href="#orgd1e9fb7">4.5. Proper Setup and Cleanup for Searches</a></li>
<li><a href="#orgcf35528">4.6. What to Measure</a></li>
<li><a href="#org7a460c2">4.7. MAKEUP CREDIT: Code Layout in <code>search_benchmark.c</code></a></li>
<li><a href="#orgc72766c">4.8. Grading Criteria for Problem 2 (45%)</a></li>
</ul>
</li>
<li><a href="#org5f2ddf1">5. Writeup</a></li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-org34f829c" class="outline-2">
<h2 id="org34f829c"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This assignment focuses on aspects of optimizing and measuring
performance.  
</p>
<ul class="org-ul">
<li>The first problem provides a baseline implementation for
a function and asks for a more performant version which runs
faster. To do so, one must exploit knowledge of the memory hierarchy
and processor pipeline.</li>
<li>The second problem provides a series of functions for classic search
algorithms and requires implementation of a <code>main()</code> function to
benchmark the performance of those functions.</li>
</ul>
</div>
</div>

<div id="outline-container-org0364d10" class="outline-2">
<h2 id="org0364d10"><span class="section-number-2">2</span> <a id="orgff5c77c"></a> Download Code and Setup</h2>
<div class="outline-text-2" id="text-2">
<p>
Download the code pack linked at the top of the page. Unzip this which
will create a project folder. Create new files in this
folder. Ultimately you will re-zip this folder to submit it.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">File</th>
<th scope="col" class="org-left">State</th>
<th scope="col" class="org-left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>Makefile</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 &amp; 2 Build file</td>
</tr>

<tr>
<td class="org-left"><code>P4-WRITEUP.txt</code></td>
<td class="org-left">Edit</td>
<td class="org-left">Fill in answers to assignment questions</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>sumdiag_optm.c</code></td>
<td class="org-left">EDIT</td>
<td class="org-left">Problem 1 create and fill in optimized function definition</td>
</tr>

<tr>
<td class="org-left"><code>sumdiag_benchmark.c</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 main benchmark</td>
</tr>

<tr>
<td class="org-left"><code>sumdiag_print.c</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 testing program</td>
</tr>

<tr>
<td class="org-left"><code>sumdiag_base.c</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 baseline function to beat</td>
</tr>

<tr>
<td class="org-left"><code>matvec.h</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 header file</td>
</tr>

<tr>
<td class="org-left"><code>matvec_util.c</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 1 utility functions for matrices/vectors</td>
</tr>

<tr>
<td class="org-left"><code>test_sumdiag.org</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Tests to check for memory issues in problem 1</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>search.h</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 2 header file</td>
</tr>

<tr>
<td class="org-left"><code>search_funcs.c</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 2 search, setup, and cleanup functions</td>
</tr>

<tr>
<td class="org-left"><code>search_benchmark.c</code></td>
<td class="org-left">EDIT/COMPLETE</td>
<td class="org-left">Problem 2 timing <code>main()</code> to create</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>testy</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Testing script</td>
</tr>

<tr>
<td class="org-left"><code>test_matata.org</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Tests to check for memory issues in problem 1</td>
</tr>

<tr>
<td class="org-left"><code>test_search_benchmark.org</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Tests to check for memory issues in problem 2</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org15011ad" class="outline-2">
<h2 id="org15011ad"><span class="section-number-2">3</span> <b>Problem 1</b>: Matrix Diagonal Sums</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org848b490" class="outline-3">
<h3 id="org848b490"><span class="section-number-3">3.1</span> Overview</h3>
<div class="outline-text-3" id="text-3-1">
<p>
A problem that occasionally arises in numerical computing when working
with Matrices (2D Arrays) is to compute the sums of the <b>Diagonals</b> of
a matrix.  The main diagonal of a matrix is comprised of all elements
at indices (0,0), (1,1), (2,2), and so forth.  There are several
numbering schemes for diagonals but we will use the one represented in
the following diagram which also shows the sums of the diagonals.
</p>

<div class="org-center">

<div id="org49be714" class="figure">
<p><img src="sumdiag.png" alt="sumdiag.png" style="max-width:100%;" />
</p>
<p><span class="figure-number">Figure 1: </span>5 by 5 matrix with diagonals colored. The diagram shows our numbering scheme for diagonals and the corresponding diagonal sums. Diagonal numbers start at 0 and progress counter-clockwise around the bottom and right of the matrix. For square matrices, the main diagonal is always numbered as the #rows-1 or #cols-1 which are equal.</p>
</div>
</div>

<p>
A code is provided in the file <code>sumdiag_base.c</code> which computes the
sums of diagonals and stores them in a vector. The algorithm does so
using the most "natural" approach of walking down each diagonal and
totaling its elements then storing the result in the associated vector
element.  As you survey the code, note the use of various convenience
functions such as <code>mget(mat,i,j)</code> and <code>vset(vec,i,x)</code> to interact with
the matrix and vector types used.
</p>

<div class="org-src-container">
<pre class="src src-c">int sumdiag_BASE_NORMAL(matrix_t *mat, vector_t *vec) {
  if(vec-&gt;len != (mat-&gt;rows + mat-&gt;cols -1)){
    printf("sumdiag_base: bad sizes\n");
    return 1;
  }
  for(int i=0; i&lt;vec-&gt;len; i++){                     // initialize vector of diagonal sums
    vset(vec,i,0);                                   // to all 0s
  }

  for(int d=0; d &lt; mat-&gt;rows; d++){                  // iterate over lower diagonals
    int c = 0;                                       // col always starts at 0 in lower diags
    for(int r=mat-&gt;rows-d-1; r&lt;mat-&gt;rows; r++,c++){  // work down rows, right cols for same diag
      int el_rc = mget(mat, r, c);                   // get matrix element on diagonal
      int vec_d = vget(vec, d);                      // retrieve current sum for diag
      vset(vec, d, el_rc+vec_d);                     // add on back to the diagonal sum
    }
  }

  int maxdiag = (mat-&gt;rows+mat-&gt;cols)-1;             // calculate last diagonal
  for(int d=mat-&gt;rows; d &lt; maxdiag ; d++){           // iterate starting at first upper diag
    int r = 0;                                       // row always starts at 0 in upper diags
    for(int c=d-mat-&gt;cols+1; c&lt;mat-&gt;cols; r++,c++){  // work down rows, right cols for same diag
      int el_rc = mget(mat, r, c);                   // matrix element
      int vec_d = vget(vec, d);                      // diagonal sum from vector
      vset(vec, d, el_rc+vec_d);                     // add on to sum
    }
  }
  return 0;                                          // return success
}
</pre>
</div>

<p>
While this algorithm is a direct translation of how humans would
visually calculate the sums of diagonals for small matrices, it is
unfortunately fairly slow when executing on most modern computing
systems.
</p>
</div>
</div>

<div id="outline-container-org10bd2fd" class="outline-3">
<h3 id="org10bd2fd"><span class="section-number-3">3.2</span> Optimize Diagonal Sums</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The purpose of this problem is to write <code>sumdiag_OPTM()</code> which is a
faster version of the provided <code>sumdiag_BASE()</code> to calculate the sums
of diagonals.
</p>

<p>
Write your code in the file <code>sumdiag_optm.c</code>.
</p>

<p>
Keep the following things in mind.
</p>
<ol class="org-ol">
<li>You will need to acquaint yourself with the functions and types
related to matrices and vectors provided in the <code>matvec.h</code> and
demonstrated in the baseline function. Understanding the layout of
the matrix in memory is essential to unlocking performance.</li>
<li>The goal of <code>sumdiag_OPTM()</code> is to exceed the performance of
<code>sumdiag_BASE()</code> by as much as possible.</li>
<li>To achieve this goal, several optimizations must be implemented and
suggestions are given in a later section.</li>
<li>You will need to document your optimizations in the file
<code>P4-WRITEUP.txt</code> and provide timing results of running the
optimized version.</li>
<li>Part of your grade will be based on the speed of the optimized code
on the machines <code>loginNN.cselabs.umn.edu</code>. The main routine
<code>sumdiag_benchmark.c</code> will be used for this.</li>
</ol>

<p>
Some details are provided in subsequent sections.
</p>
</div>
</div>

<div id="outline-container-orgfdc4c6c" class="outline-3">
<h3 id="orgfdc4c6c"><span class="section-number-3">3.3</span> Evaluation on <code>loginNN</code></h3>
<div class="outline-text-3" id="text-3-3">
<p>
The provided file <code>sumdiag_benchmark.c</code> provides a benchmark for the
speed of diagonal summing. It will be used by graders to evaluate the
submitted code and should be used during development to gauge
performance improvements.
</p>

<p>
The following machines may be used to evaluate the benchmark:
</p>
<div class="org-src-container">
<pre class="src src-text">login01.cselabs.umn.edu  OR  csel-remote-lnx-01.cselabs.umn.edu
login02.cselabs.umn.edu  OR  csel-remote-lnx-02.cselabs.umn.edu
login03.cselabs.umn.edu  OR  csel-remote-lnx-03.cselabs.umn.edu
login04.cselabs.umn.edu  OR  csel-remote-lnx-04.cselabs.umn.edu
login05.cselabs.umn.edu  OR  csel-remote-lnx-05.cselabs.umn.edu
login06.cselabs.umn.edu  OR  csel-remote-lnx-06.cselabs.umn.edu
</pre>
</div>
<p>
These are newer server machines with quite a few processors and are
not virtualized making them ideal for performance benchmarks.
</p>

<p>
The scoring present in <code>sumdiag_benchmark.c</code> is "tuned" to these
machines and will likely report incorrect results on other machines.
That means that codes should be <b>tested on loginNN machines</b> so that
no unexpected results occur after submission. Results reported should
be from one of <code>loginNN</code>.
</p>

<p>
The output of the <code>sumdiag_benchmark</code> is shown below.
</p>
<ul class="org-ul">
<li>SIZE: the size of the matrix being used. The benchmark always
uses square matrices</li>
<li>Runtimes for the 2 functions
<ul class="org-ul">
<li><code>BASE</code>: the time it takes for <code>sumdiag_BASE()</code> to complete.</li>
<li><code>OPTM</code>: the time it takes for <code>sumdiag_OPTM()</code> to complete.</li>
</ul></li>
<li>SPDUP: the speedup of <code>sumdiag_OPTM()</code> over <code>sumdiag_BASE()</code> which
is <code>BASE / OPTM</code>.</li>
<li><p>
POINTS: which are earned according to the following code:
</p>
<div class="org-src-container">
<pre class="src src-c">    double points = log(speedup_OPTM) / log(2.0) * size / 2048;
</pre>
</div>
<p>
This scheme means that unless actual optimizations are implemented,
0 points will be scored. Roughly this scores according to a
logarithmic scale that is weighted towards more points if speedups
at larger sized inputs is achieved.
</p></li>
</ul>

<p>
Below are several demonstration runs of <code>sumdiag_benchmark</code>.
</p>
<div class="org-src-container">
<pre class="src src-sh"># RUN ON INCORRECT MACHINE (NOT loginNN): NOTE WARNINGS
homeputer&gt; ./sumdiag_benchmark 
WARNING: expected host 'csel-remote-lnx-01' but got host 'val'
WARNING: timing results / scoring will not reflect actual scoring
WARNING: run on host 'csel-remote-lnx-01' for accurate results
==== Matrix Diagonal Sum Benchmark Version 3 ====
------ Tuned for csel-remote-lnx-NN machines --------
  SIZE       BASE       OPTM  SPDUP POINTS 
   512 3.1570e-02 4.0520e-03   7.79   0.76 
  1024 7.6512e-02 1.4715e-02   5.20   1.22 
  1101 8.7841e-02 1.8098e-02   4.85   1.25 
  2048 3.8762e-01 6.0538e-02   6.40   2.74 
  4099 1.5315e+00 2.3139e-01   6.62   5.59 
  6001 3.7776e+00 4.8399e-01   7.81   8.89 
  8192 7.1925e+00 8.9518e-01   8.03  12.31 
RAW POINTS: 32.77
TOTAL POINTS: 33 / 35
WARNING: expected host 'csel-remote-lnx-01' but got host 'val'
WARNING: timing results / scoring will not reflect actual scoring
WARNING: run on host 'csel-remote-lnx-01' for accurate results

# PARTIAL CREDIT RUN
&gt;&gt; ssh ssh login01.cselabs.umn.edu
...
login01&gt; ./sumdiag_benchmark
==== Matrix Diagonal Sum Benchmark Version 3 ====
------ Tuned for csel-remote-lnx-NN machines --------
  SIZE       BASE       OPTM  SPDUP POINTS 
   512 1.2573e-02 3.8700e-03   3.25   0.44 
  1024 5.3862e-02 1.5494e-02   3.48   0.92 
  1101 6.0651e-02 1.8055e-02   3.36   0.96 
  2048 3.1395e-01 6.2855e-02   4.99   2.38 
  4099 1.5505e+00 2.5374e-01   6.11   5.35 
  6001 3.4942e+00 5.4745e-01   6.38   8.02 
  8192 6.6624e+00 1.0128e+00   6.58  11.13 
RAW POINTS: 29.20
TOTAL POINTS: 29 / 35

# FULL CREDIT RUN
login01&gt; ./sumdiag_benchmark
==== Matrix Diagonal Sum Benchmark Version 3 ====
------ Tuned for csel-remote-lnx-NN machines --------
  SIZE       BASE       OPTM  SPDUP POINTS 
   512 1.3784e-02 2.4550e-03   5.61   0.64 
  1024 5.5067e-02 9.7000e-03   5.68   1.28 
  1101 6.2697e-02 1.1165e-02   5.62   1.37 
  2048 3.2443e-01 4.0681e-02   7.97   3.07 
  4099 1.5905e+00 1.6463e-01   9.66   6.71 
  6001 3.5678e+00 3.5394e-01  10.08  10.00 
  8192 6.8017e+00 6.5771e-01  10.34  13.81 
RAW POINTS: 36.87
TOTAL POINTS: 35 / 35
</pre>
</div>

<p>
Note that it is possible to exceed the score associated with maximal
performance (as seen in the RAW POINTS reported) but no more than the
final reported points will be given for the performance portion of the
problem.
</p>

<blockquote>
<p>
Achieving very high speedup and significantly exceeding the max score
may garner some MAKEUP credit: you'll know you earned this as the
benchmark will report as much
</p>
</blockquote>
</div>
</div>


<div id="outline-container-orgc966a6d" class="outline-3">
<h3 id="orgc966a6d"><span class="section-number-3">3.4</span> <code>sumdiag_print.c</code> Testing Program</h3>
<div class="outline-text-3" id="text-3-4">
<p>
As one works on implementing optimizations in <code>sumdiag_OPTM()</code>, bugs
which compute incorrect results are often introduced.  To aid in
testing, the <code>sumdiag_print()</code> program runs both the BASE and OPTM
versions on the same matrix and shows all results. The matrix size is
determined from the command line and is printed on the screen to
enable hand verification. Examples are below.
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; ./sumdiag_print 5                    # run on a size 5 by 5 matrix; 
==== Matrix Diagonal Sum Print ====
Matrix:
5 x 5 matrix                           # shows the matrix
   0:    0    1    2    3    4 
   1:    5    6    7    8    9 
   2:   10   11   12   13   14 
   3:   15   16   17   18   19 
   4:   20   21   22   23   24 

Diagnonal Sums:                        # prints diag sums for BASE/OPTM
[ i]: BASE OPTM
[ 0]:   20   20                        # matching
[ 1]:   36   36 
[ 2]:   48   48 
[ 3]:   56   56 
[ 4]:   60   36 ***                    # not matching: OPTM is buggy
[ 5]:   40   21 ***
[ 6]:   24   10 ***
[ 7]:   12    3 ***
[ 8]:    4    0 ***

</pre>
</div>
</div>
</div>


<div id="outline-container-org5898cb9" class="outline-3">
<h3 id="optimizations"><a id="org5898cb9"></a><span class="section-number-3">3.5</span> <a id="org7f6cbc7"></a> Optimization Suggestions and Documentation</h3>
<div class="outline-text-3" id="text-optimizations">
<p>
Labs and lectures will cover several kinds of optimizations which are
useful to improve the speed of <code>sumdiag_OPTM()</code>.  These techniques
include any or all of the following:
</p>
<ol class="org-ol">
<li>Replacing repeated memory references with local non-pointer data
which will likely be assigned to registers to alleviate slow-down
from memory accesses.</li>
<li>Eliminating barriers to natural compiler optimizations such as by
replacing short function calls with equivalent inline code or Macro
invocations. <i>Hint: in <code>matvec.h</code> there is both <code>vget()</code> function
and a <code>VGET()</code> macro;</i> <i>use the that is likely to be faster in your
own code.</i></li>
<li>Re-ordering memory accesses to be as sequential as possible which
favors cache. <b>Unless memory accesses favor cache, it is unlikely
that many optimizations will have much effect.</b></li>
<li>Increasing potential processor pipelining by adjusting the
destinations of arithmetic operations.</li>
<li>Decreasing any unnecessary work such as memory accesses or
arithmetic operations.</li>
</ol>
<p>
These should be sufficient to gain full credit though you are free to
explore additional optimizations.
</p>

<p>
One handy realization most folks will reach is that it is useful to be
able to compute the Diagonal of an individual matrix element belongs to
based on its row/col indices.  The following formula is useful for
that:
</p>
<div class="org-src-container">
<pre class="src src-c">mat_elem = MGET(mat, col_num, row_num);         // retrive an element based on row/col
diag_num = col_num - row_num + mat.cols - 1;    // calculate the diagonal number for it
</pre>
</div>
</div>
</div>

<div id="outline-container-org2d8f54d" class="outline-3 grading 50">
<h3 id="org2d8f54d"><span class="section-number-3">3.6</span> Grading Criteria for Problem 1 (50%)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="grading">grading</span>&#xa0;<span class="50">50</span></span></h3>
<div class="outline-text-3" id="text-3-6">
<p>
The file <code>P4-WRITEUP.txt</code> has several questions that should be
answered in a similar fashion to lab write-ups. These document the
optimizations used in <code>sumdiag_OPTM()</code> require a justification for
their use.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-left">Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">AUTOMATED TESTS</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">No output/memory errors reported  <code>make test-prob1</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">MANUAL INSPECTION of <code>sumdiag_optm.c</code></td>
</tr>

<tr>
<td class="org-right">35</td>
<td class="org-left">Performance of <code>sumdiag_OPTM()</code> on <code>loginNN.cselabs.umn.edu</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">As measured by the provided <code>sumdiag_benchmark</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left"><code>P4-WRITEUP.txt</code></td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Answer 1A <code>P4-WRITEUP.txt</code> (source code)</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Answer 1B <code>P4-WRITEUP.txt</code> (timing table)</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Answer 1C <code>P4-WRITEUP.txt</code> (optimizations description)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-org83f5937" class="outline-2">
<h2 id="org83f5937"><span class="section-number-2">4</span> <b>Problem 2</b>: Timing Search Algorithms</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org3a734e1" class="outline-3">
<h3 id="org3a734e1"><span class="section-number-3">4.1</span> Overview</h3>
<div class="outline-text-3" id="text-4-1">
<p>
This problem centers on timing several algorithms to measure their
performance. This will require use of C timing functions which have
been demonstrated in various parts of the class including the previous
problem.
</p>

<p>
You will measure the performance of 4 search functions which simply
determine whether an integer <code>query</code> is present in an associated data
structure.  All of these along with associated setup functions are
provided in the <code>search_funcs.c</code> file.  The search algorithms are as
follows.
</p>

<dl class="org-dl">
<dt>Linear Search in an Array</dt><dd>The array need not be sorted and is
searched from beginning to end.</dd>
<dt>Linear Search in a Linked List</dt><dd>Nodes are linked together and the
list is searched for a query from beginning to end.</dd>
<dt>Binary Search in a Sorted Array</dt><dd>The classic divide and conquer
algorithm which repeatedly halves the search space.</dd>
<dt>Binary Search in a Tree</dt><dd>A binary search tree enables searching
for a query by following left/right branches.</dd>
</dl>

<p>
If you do not have a sense of the relative computational complexities
of these algorithms, you should review these as they should factor
into your analysis of the timings of the algorithms.
</p>

<p>
As was the case for problem 1, you can develop your timing program on
any platform but *analyze and report results on the
<code>loginNN.cselabs.umn.edu</code> machines to ensure comparability.
</p>
</div>
</div>


<div id="outline-container-orgae662f1" class="outline-3">
<h3 id="orgae662f1"><span class="section-number-3">4.2</span> <code>main()</code> in <code>search_benchmark.c</code></h3>
<div class="outline-text-3" id="text-4-2">
<p>
The requirements from this problem is that you provide a <code>main()</code>
function in the file <code>search_benchmark.c</code> with the following features.
</p>

<ol class="org-ol">
<li>Runs on a range of sizes that can be specified on the command
line.  A typical approach is to allow one to specify a minimum and
maximum size of the search data structures and repeatedly double
starting at the minimum and ending at the max.</li>
<li><p>
Create "even" data in the structures using the provided
functions. 
</p>
<ul class="org-ul">
<li><code>make_even_array()</code> for arrays</li>
<li><code>make_even_list()</code> for linked lists</li>
<li><code>make_even_trees()</code> for  trees</li>
</ul>
<p>
This will populate the data structure with the sequence
<code>0,2,4,...,(len-1)*2</code>.  This data population allows searches
for items that are known to be present (even numbers) and items
that are known not to be present (odd numbers).
</p></li>
<li><p>
Perform a variable number of searches on the data structures.  This
should be done the following way.
</p>
<ul class="org-ul">
<li>On the command line the number of repetitions of searches should
be specified on the command line.</li>
<li>Search for every element in the data structures the given number
of repetitions.</li>
<li>Search an equal number of times for elements NOT in the data
structure.</li>
</ul>
<p>
A typical example method for this is as follows. For a size 100
data structure perform
</p>
<ul class="org-ul">
<li>An outer loop over the number of repetitions</li>
<li>An inner loop that searches for the numbers
<code>0,1,2,3,4,...,(2*len)-1</code></li>
</ul>
<p>
This pattern searches for an equal number of present/not-present
items.
</p></li>
<li><p>
Measure the <b>Total Time for the Entire Search Loop</b> for a given
algorithm. Since individual searches will take a minuscule amount
of time, the Total Time for the loop is the most robust measure to
discuss. While such a time may include some artifacts such as
incriminating loop variables, these will be "charged" to all
algorithms equally so that the comparison remains fair. <b>Avoid use
of functions like pow()</b> as these will introduce unnecessarily
calculations inflating the measured times. Favor multiplications to
increase size such as
</p>
<pre class="example">
cur_search_size = cur_search_size * 2;
</pre></li>
<li><p>
Enable any combination of algorithms to be tested by specifying
which are to be run on the command line.  The required way to do
this is to accept optional 4th, 5th, etc. command line arguments
which enable different search types.  The associated strings for
each algorithm are
</p>
<ul class="org-ul">
<li><code>la</code> for linear array search</li>
<li><code>ll</code> for linked list search</li>
<li><code>bl</code> for binary search</li>
<li><code>bt</code> for tree search</li>
</ul>
<p>
Specify additional command line arguments which enable the searches:
</p>
<ul class="org-ul">
<li><code>ll</code>: run linked list search only</li>
<li><code>la ba</code>: run linear array search and binary array search</li>
<li><code>la ll bt</code>: run all but the binary array search</li>
<li><code>ll bt la ba</code>: run all algorithms</li>
<li>If no string is specified, run all algorithms; this is the
default.</li>
<li>The order of the additional command line arguments need not
affect the output. For example specifying <code>la ll</code> can have the
same output as <code>ll la</code> (both run linear search in arrays and
linked lists).</li>
</ul></li>
<li>Ensure that an equal number of searches is done for each
of the algorithms being benchmarked.</li>
<li>Ensure that the timing that is done is ONLY for searching and not
for setup and cleanup for the data structures.</li>
<li>Ensure that there are no memory leaks or other problems in setup
and cleanup for the searches.</li>
</ol>
</div>
</div>

<div id="outline-container-org7d5282b" class="outline-3">
<h3 id="search-benchmark-runs"><a id="org7d5282b"></a><span class="section-number-3">4.3</span> Sample Runs</h3>
<div class="outline-text-3" id="text-search-benchmark-runs">
<p>
Below are some sample runs of the search benchmark. You do not need to
match all aspects of the output exactly but tests will check for basic
output like printing the first line with correct data structures. Some
aspects of <code>search_benchmark</code> behavior are discussed later in more
detail. 
</p>

<div class="org-src-container">
<pre class="src src-sh">homeputer&gt; ssh login01.cselabs.umn.edu

&gt;&gt; ./search_benchmark
usage: ./search_benchmark &lt;minpow&gt; &lt;maxpow&gt; &lt;repeats&gt; [alg1 alg2 ...]
  minpow:  first data structure size is 2^minpow
  maxpow:  last data structure size is 2^maxpow
  repeats: number of times to loop search sequence to scale time
with alg1 alg2 as a combination of:
  la : Linear Array Search
  ll : Linked List Search
  ba : Binary Array Search
  bt : Binary Tree Search
  (default all)

# NOTE: the usage message is optional and only shown here to give a
# summary of how command line arguments control the program

&gt;&gt; ./search_benchmark 1 5 1 ll    # Run only Linked List "ll" searches on lists 2^1 to 2^5 in size
    SIZE  NSEARCH       list 
       2        4 3.0000e-06      # size 2^1 list with [0,2], search sequence 0,1,2,3 with 1 repeat
       4        8 2.0000e-06      # size 2^2 list with [0,2,4,6], search sequence 0,1,2,3,..,7 with 1 repeat
       8       16 3.0000e-06      # size 2^3 list with [0,2,4,6,...14], search sequence 0,1,2,3,..,15 with 1 repeat
      16       32 4.0000e-06 
      32       64 8.0000e-06 

# NOTE: these times are below 1.0e-03, too short to trust; increase
# &lt;repeats&gt; parameter to scale time up to be more reliable

&gt;&gt; ./search_benchmark 4 8 10 ba bt      # Run only the Binary Array "ba" and Binary Tree "bt" searches
    SIZE  NSEARCH     binary       tree 
      16      320 1.2000e-05 1.0000e-05 # size 16 array/tree with elements [0,2,4,...30], search sequence 0,1,2,...31 with 10 repeats
      32      640 2.4000e-05 2.0000e-05 # size 32 array/tree with elements [0,2,4,...62], search sequence 0,1,2,...63 with 10 repeats
      64     1280 6.5000e-05 5.0000e-05 # ...
     128     2560 2.0900e-04 1.7700e-04 
     256     5120 5.0500e-04 4.4400e-04 

# NOTE: these times are below 1.0e-03, too short to trust; increase
# &lt;repeats&gt; parameter to scale time up to be more reliable

&gt;&gt; ./search_benchmark 3 6 5                                   # Run ALL algorithms (no alg params)
    SIZE  NSEARCH      array       list     binary       tree 
       8       80 4.0000e-06 4.0000e-06 5.0000e-06 4.0000e-06 # search seq 0,1,2...15 with 5 repeats
      16      160 7.0000e-06 7.0000e-06 7.0000e-06 8.0000e-06 # search seq 0,1,2...32 with 5 repeats
      32      320 1.8000e-05 2.7000e-05 1.6000e-05 1.6000e-05 # search seq 0,1,2...63 with 5 repeats
      64      640 5.7000e-05 9.3000e-05 3.5000e-05 4.0000e-05 # search seq 0,1,2...127 with 5 repeats

# NOTE: these times are below 1.0e-03, too short to trust; increase
# &lt;repeats&gt; parameter to scale time up to be more reliable
</pre>
</div>
</div>
</div>


<div id="outline-container-orgd0701d6" class="outline-3">
<h3 id="orgd0701d6"><span class="section-number-3">4.4</span> Running Algorithms based on Command Line Arguments</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Many folks who have not had to handle command line arguments struggle
some what with the style of <code>search_benchmark</code> so here is some
additional guidance on handling this aspect of the program.
</p>
</div>


<div id="outline-container-org4aa29fb" class="outline-4">
<h4 id="org4aa29fb">C Command Line Arguments Handling</h4>
<div class="outline-text-4" id="text-org4aa29fb">
<p>
Keep in mind that C uses the following conventions for command line
arguments based on the parameters to <code>main(int argc, char *argv[])</code>.
</p>
<ul class="org-ul">
<li><code>int argc</code> is the total number of strings appearing on the command
including the program name</li>
<li><code>char *argv[]</code> is an array of strings which are the command lines</li>
</ul>

<p>
For example, here are a couple command line configurations based on
possible runs of <code>search_benchmark</code>.
</p>
<div class="org-src-container">
<pre class="src src-sh">&gt;&gt; ./search_benchmark 5 10 20 
# argc = 4
# argv[0] = "search_benchmark"
# argv[1] = "5"
# argv[2] = "10"
# argv[3] = "20"

&gt;&gt; ./search_benchmark 5 10 20 la bt
# argc = 6
# argv[0] = "search_benchmark"
# argv[1] = "5"
# argv[2] = "10"
# argv[3] = "20"
# argv[3] = "la"
# argv[3] = "bt"
</pre>
</div>

<p>
Handling numeric arguments is often eased with <code>atoi(), atol(),
atof()</code> and related functions. If these are not familiar, look up
documentation associated with them.
</p>
</div>
</div>

<div id="outline-container-orgc1257ec" class="outline-4">
<h4 id="orgc1257ec">Run the algorithms in a fixed order</h4>
<div class="outline-text-4" id="text-orgc1257ec">
<p>
An invocation like
</p>
<pre class="example">
./search_benchmark 5 10 10 la ll
</pre>

<p>
should run the linear array search (<code>a</code>) and linear linked list search
(<code>l</code>).  So should the invocation
</p>
<pre class="example">
./search_benchmark 5 10 10 ll la
</pre>

<p>
Since we are interested <b>only</b> in comparing timing for these
algorithms, the order of which is run first and printed first does not
matter so <b>run the algorithms and print results in a fixed order.</b>
That is, both of the above will run the array search first and linked
list search second giving identical ordering results:
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt; ./search_benchmark 5 10 10 la ll
    SIZE  NSEARCH      array       list 
      32      640 1.2345e+06 1.2345e+06 
      64     1280 1.2345e+06 1.2345e+06 
     128     2560 1.2345e+06 1.2345e+06 
     256     5120 1.2345e+06 1.2345e+06 
     512    10240 1.2345e+06 1.2345e+06 
    1024    20480 1.2345e+06 1.2345e+06 

&gt; ./search_benchmark 5 10 10 ll la         # still running linear array search first
    SIZE  NSEARCH      array       list 
      32      640 1.2345e+06 1.2345e+06 
      64     1280 1.2345e+06 1.2345e+06 
     128     2560 1.2345e+06 1.2345e+06 
     256     5120 1.2345e+06 1.2345e+06 
     512    10240 1.2345e+06 1.2345e+06 
    1024    20480 1.2345e+06 1.2345e+06 

</pre>
</div>

<p>
Search times above are intentionally left out so you will need to
trust your own code to get an idea of how long things are
running. However, very short run times are generally unreliable. Aim
for a <b>minimum time of 1e-03 seconds</b> in order to make sure your
results are reliable.  Shorter times like 1e-05 will vary too much to
trust. 
</p>
</div>
</div>

<div id="outline-container-orgef97e63" class="outline-4">
<h4 id="orgef97e63">Use Boolean-like variables to track which algorithms to run</h4>
<div class="outline-text-4" id="text-orgef97e63">
<p>
If following the advice of the previous section, to run the 4
algorithms in a fixed order, one can simple assign variables in
<code>main()</code> which indicate which algorithms to run as in the following.
</p>
<div class="org-src-container">
<pre class="src src-c">  int run_linear_array = 0;
  int run_linear_list  = 0;
  ...
</pre>
</div>
<p>
Later, these variables are checked in a conditional as in:
</p>
<div class="org-src-container">
<pre class="src src-c">  if(run_linear_array){
    // run loops to time linear search in an array
  }
  if(run_linear_list){
    // run loops to time linear search in a list
  }
  ...
</pre>
</div>

<p>
<a id="org4aa212e"></a> <i>Updated Wed Apr 13 04:56:08 PM CDT 2022</i>
</p>

<p>
When processing the command line argument
associated with which algorithms to run, one can 'turn on' the
algorithm if the associated string is present on the command line
according to the following pseudo-code
</p>
<div class="org-src-container">
<pre class="src src-c">turn on all algorithms as this is the default;
if(#arguments &gt; 4){
  turn off all algorithms since command line arguments dictate which to run;
  for(each argument in argv[] at index 4 or above){
    if( argv[i] is equal to "la" ){
      run_linear_array = 1;
    }
    ...
  }
</pre>
</div>
<p>
While the above approach does not allow one to run algorithms in an
arbitrary order, it does allow any combination of algorithms to be run
and compared which is all that is needed to complete the timing.
</p>
</div>
</div>

<div id="outline-container-org311f5d0" class="outline-4">
<h4 id="org311f5d0">Free and Re-allocate Memory for Different Sizes</h4>
<div class="outline-text-4" id="text-org311f5d0">
<p>
While the search functions for Linked Lists and Binary Search Trees
both take size arguments, these are ignored in the searches.  Instead,
<code>NULL</code>'s in the data structures are used to find the bounds of them.
This means if one is searching for data that is not in a small list,
the end of the data structure will be reached sooner and <i>not found</i>
will be determined faster than if searching in a large list.  To that
end <b>allocate data structures that are sized specifically to the
search size</b> each time. Do NOT allocate one large data structure and
do all size searches on it as this will create artificially bad
timings for the linked structures.
</p>
</div>
</div>
</div>


<div id="outline-container-orgd1e9fb7" class="outline-3">
<h3 id="orgd1e9fb7"><span class="section-number-3">4.5</span> Proper Setup and Cleanup for Searches</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Each search algorithm requires setup and cleanup which is described
below. All these follow the same patter which can enable somewhat more
elegant setup/search/cleanup which is discussed in the section on
bonus credit.
</p>
</div>

<div id="outline-container-orge149b6c" class="outline-4">
<h4 id="orge149b6c">Linear and Binary Array Search</h4>
<div class="outline-text-4" id="text-orge149b6c">
<p>
Use the function <code>make_evens_array()</code> to create an appropriately
sized <code>int</code> array for these functions.  Call <code>free()</code> on this array
when finished with it.
</p>
</div>
</div>

<div id="outline-container-org4bea7f8" class="outline-4">
<h4 id="org4bea7f8">Linked List Search</h4>
<div class="outline-text-4" id="text-org4bea7f8">
<p>
Use the function <code>make_evens_list()</code> to create an appropriately
sized <code>list_t</code>.  Call <code>list_free()</code> on this list when finished with
it.
</p>
</div>
</div>

<div id="outline-container-org30661d8" class="outline-4">
<h4 id="org30661d8">Binary Tree Search</h4>
<div class="outline-text-4" id="text-org30661d8">
<p>
Use the function <code>make_evens_tree()</code> to create an appropriately
sized <code>bst_t</code>.  Call <code>bst_free()</code> on this list when finished with
it.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcf35528" class="outline-3">
<h3 id="orgcf35528"><span class="section-number-3">4.6</span> What to Measure</h3>
<div class="outline-text-3" id="text-4-6">
<p>
The reason for the requirements mentioned above is to study the
performance of different search algorithms and answer associated
questions in the <code>P4-WRITEUP.txt</code>.  The main goals of these questions
are to elucidate.
</p>
<ol class="org-ol">
<li>To compare the linear and logarithmic search complexities to see if
one or the other is superior at small and large input sizes</li>
<li>To compare the contiguous memory (array) approaches to the linked
memory (list/tree) approaches to see if one or the other is
superior at small and large sizes.</li>
</ol>
<p>
To that end make sure to answer the thoroughly answer questions
provided.
</p>
</div>
</div>

<div id="outline-container-org7a460c2" class="outline-3">
<h3 id="org7a460c2"><span class="section-number-3">4.7</span> MAKEUP CREDIT: Code Layout in <code>search_benchmark.c</code></h3>
<div class="outline-text-3" id="text-4-7">
<p>
"Makeup" credit will allow the score on this assignment to exceed 100%
but will not allow the overall score on the project portion of the
grade to exceed the weight specified in the syllabus. It is designed
to help "make up" for lost credit on previous assignments.
</p>

<p>
Makeup credit is available in this assignment for implementing the
selection of which search functions to run in an "elegant" fashion.
Likely the best method for this is to use a table of function
pointers. This style is demonstrated in Lab09 and Lab11 but must be
expanded upon in this lab to reach its full potential.
</p>

<p>
The main purpose to using such a table is to avoid a large <code>if/else</code>
or <code>switch/case</code> block.  For example, a simple approach to doing
different search types is something like the following.
</p>
<div class="org-src-container">
<pre class="src src-c">int main(...){
  int do_linear_array = 1;
  int do_linked_list  = 1;
  ...;
  for(all sizes){
    if(do_linear_array){
      // setup array
      // start timer
      // do searches
      // stop timer
      // print output
      // free the array
    }
    if(do_linked_list){
      // setup list
      // start timer
      // do searches
      // stop timer
      // print output
      // free the list
    }
    ...;
  }
}
</pre>
</div>
<p>
This formulation obviously involves a much redundant code. A good way
to avoid this is to parameterize the repeated parts as functions and
iterate over the table invoking functions appropriate to the different
types of searches.
</p>

<p>
To get a sense of how this might work, here is an incomplete example
setup used in one solution.
</p>
<div class="org-src-container">
<pre class="src src-c">// Table of search algorithms
searchalg_t algs[] = {
  {"Linear Array Search", "array",  'a', 1,
   (search_t) linear_array_search, (setup_t) make_evens_array, (cleanup_t) free},
  {"Linked List Search",  "list",   'l', 1,
   (search_t) linkedlist_search,   (setup_t) make_evens_list,  (cleanup_t) list_free},
  ...
  {NULL}
};
</pre>
</div>
<p>
None of the types are given in the above but several notable things
are present.
</p>
<ol class="org-ol">
<li>The types of searches are described in an array (table) of structs</li>
<li>Each field pertains to a description or function for the search</li>
<li>Some of the functions are for setup, others for cleanup, and the
first is the actual search function.</li>
<li>Casting is required to get the different function prototypes to
"fit" into the same kind of struct.</li>
<li>All of the searches are enabled by default but fields can changed
to disable them.</li>
<li>One only needs to iterate through the array invoking appropriate
functions. This avoids the need for a large <code>if/else</code> style
program.</li>
</ol>

<p>
To complete this part, document your code with comments and also
describe you design using function pointers/structs in
<code>P4-WRITEUP.txt</code>.
</p>

<p>
It may be worthwhile to study some examples of the use of function
pointers which are useful for this type of situation. A short tutorial
on this topic is here:
<a href="https://www-users.cse.umn.edu/~kauffman/2021/function-pointers.html">https://www-users.cse.umn.edu/~kauffman/2021/function-pointers.html</a>
</p>
</div>
</div>

<div id="outline-container-orgc72766c" class="outline-3 grading 45">
<h3 id="orgc72766c"><span class="section-number-3">4.8</span> Grading Criteria for Problem 2 (45%)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="grading">grading</span>&#xa0;<span class="45">45</span></span></h3>
<div class="outline-text-3" id="text-4-8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-left">Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">AUTOMATED TESTS</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Passed tests associated with <code>make test-prob2</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">MANUAL INSPECTION of <code>search_benchmark.c</code></td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Accepts parameters that control the min/max data sizes and number of repeats</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Proper searching for success and fail elements</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">The Total Search Loop Time is measured for each algorithm and reported, not an average per search</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Timing does not include memory allocationo/de-allocation</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Allocates data that is exactly to search sizes to prevent handicapping lists and arrays</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Clean and well-documented code for <code>main()</code> that uses simple approaches to run algorithms requested</td>
</tr>

<tr>
<td class="org-right">15</td>
<td class="org-left">SUBTOTAL</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left"><code>P4-WRITEUP.txt</code></td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Timing results larger than 1e-03 seconds for most cases; smaller times are unreliable.</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Answer 2A <code>P4-WRITEUP.txt</code> (min size for differences)</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Answer 2B <code>P4-WRITEUP.txt</code> (list vs array)</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Answer 2C <code>P4-WRITEUP.txt</code> (tree vs array))</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">Answer 2D <code>P4-WRITEUP.txt</code> (caching effects))</td>
</tr>

<tr>
<td class="org-right">25</td>
<td class="org-left">SUBTOTAL</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">OPTIONAL MAKEUP CREDIT</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">Use a table of function pointers effectively in <code>search_benchmark.c</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Must describe this design in section 2E of <code>P4-WRITEUP.txt</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-org5f2ddf1" class="outline-2">
<h2 id="org5f2ddf1"><span class="section-number-2">5</span> Writeup</h2>
<div class="outline-text-2" id="text-5">
<p>
This assignment involves answering questions in the file
<code>P4-WRITEUP.txt</code> which is included in the code pack and pasted below.
</p>

<div class="org-src-container">
<pre class="src src-text">                              ____________

                               P4 WRITEUP
                              ____________


- Name: (FILL THIS in)
- NetID: (THE kauf0095 IN kauf0095@umn.edu)

Answer the questions below according to the project specification. Write
your answers directly in this text file and submit it along with your
code.


PROBLEM 1: sumdiag_OPTM()
=========================

  Do your timing study on loginNN.cselabs.umn.edu


(A) Paste Source Code
~~~~~~~~~~~~~~~~~~~~~

  Paste a copy of your source code for the function `sumdiag_OPTM()'

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(B) Timing on loginNN.cselabs.umn.edu
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Paste a copy of the results of running `sumdiag_benchmark' on
  loginNN.cselabs.umn.edu (like login01, login02, ..., login06) in the
  space below which shows how your performance optimizations improved on
  the baseline codes.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(C) Optimizations
~~~~~~~~~~~~~~~~~

  Describe in some detail the optimizations you used to speed the code
  up.  THE CODE SHOULD CONTAIN SOME COMMENTS already to describe these
  but in the section below, describe in English the techniques you used
  to make the code run faster.  Format your descriptions into discrete
  chunks such as.
        Optimization 1: Blah bla blah... This should make run
        faster because yakkety yakeety yak.

        Optimization 2: Blah bla blah... This should make run
        faster because yakkety yakeety yak.

        ...  Optimization N: Blah bla blah... This should make run
        faster because yakkety yakeety yak.
  Full credit solutions will have a least THREE optimizations and
  describe WHY these improved performance in at least a couple
  sentences.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


PROBLEM 2: Timing Search Algorithms
===================================

  Do your timing study on loginNN.cselabs.umn.edu. In most cases, report
  times larger than 1e-03 seconds as times shorter than this are
  unreliable. Run searches for more repetitions to lengthen run times.


(A) Min Size for Algorithmic Differences
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Determine the size of input array where one starts to see a measurable
  difference in the performance of the linear and logarithmic
  algorithms.  Produce a timing table which includes all algorithms
  which clearly demonstrates an uptick in the times associated with some
  while others remain much lower.  Identify what size this appears to be
  a occur.

  SHOW A TIMING TABLE to support your conclusions and ensure that the
  times reported are larger that 1e-03.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(B) Linear Search in List vs Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Determine whether the linear array and linked list search remain
  approximately at the same performance level as size increases to large
  data or whether one begins to become favorable over other. Determine
  the approximate size at which this divergence becomes obvious. Discuss
  reasons WHY this difference arises.

  SHOW A TIMING TABLE to support your conclusions and ensure that the
  times reported are larger that 1e-03.


  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(C) Binary Search in Tree vs Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Compare the binary array search and binary tree search on small to
  very large arrays. Determine if there is a size at which the
  performance of these two begins to diverge. If so, describe why this
  might be happening based on your understanding of the data structures
  and the memory system. If not, describe why you believe there is
  little performance difference between the two.

  SHOW A TIMING TABLE to support your conclusions and ensure that the
  times reported are larger that 1e-03.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(D) Caching Effects on Algorithms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  It is commonly believed that memory systems that feature a Cache will
  lead to arrays performing faster than linked structures such as Linked
  Lists and Binary Search Trees. Describe whether your timings confirm
  or refute this belief.  Address both types of algorithms in your
  answer:
  - What effects does Cache have on Linear Search in arrays and lists
    and why?
  - What effects does Cache have on Binary Search in arrays and trees
    and why?

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(E) OPTIONAL MAKEUP CREDIT
~~~~~~~~~~~~~~~~~~~~~~~~~~

  If you decided to make use of a table of function pointers/structs
  which is worth makeup credit, describe your basic design for this
  below.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr/> <i> Author: Chris Kauffman (<a href="mailto:kauffman@umn.edu">kauffman@umn.edu</a>) <br/> Date: 2022-11-17 Thu 14:15 <br/> </i>
</div>
</body>
</html>
