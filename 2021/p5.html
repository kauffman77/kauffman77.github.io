<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-04-25 Mon 21:40 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSCI 2021 Project 5: Memory Allocator</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Chris Kauffman" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, maximum-scale=1, minimum-scale=1" />
<style type="text/css">
@media screen {
:root {
--heading-bg-color:#e8c62e;
--heading-fg-color:#7a0019;
}
html {
font-family: serif;
text-align: justify;
}
pre.src, pre.example {
overflow-x: scroll;
}
/* Merge subtitle area with title area */
.subtitle {
text-align: center;
margin-top: -2em;
padding-top: 1em;
padding-bottom: 0.1em;
}
.title, .subtitle {
color: var(--heading-fg-color);
background-color: var(--heading-bg-color);
}
/* Section borders, left section header style */
div.outline-2, #table-of-contents {
background-color: rgb(250,250,250);
border: 0.75em solid var(--heading-bg-color);
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
}
div.outline-2 > h2, #table-of-contents > h2 {
background-color: var(--heading-bg-color);
color: var(--heading-fg-color);
font-variant: small-caps;
padding: 0em 0em 0em .5em; /* top right bottom left */
margin: 0em -.5em 0em -.75em; /* top right bottom left */
text-align: left;
}
blockquote {
font-style: italic;
}
td, th {
padding-top: 2px;
padding-bottom: 2px;
}
body {
background-color: #EEE;
}
pre {
}
#content, #preamble, #postamble {
margin-left:300px;
}
.tag {
background-color: inherit; font-family: inherit;
padding: inherit; font-size: 80%; font-weight: inherit;
text-transform: uppercase;
}

.figure p { text-align: inherit; }
figure-number { font-style: italic; }
#table-of-contents {
text-align: left;
position: fixed;
left: 0;
margin: 0 auto;
padding: 0;
width: 300px;
top: 0;
height: 100%;
border: 0;
display: block;
}
#text-table-of-contents {
overflow-y: scroll;
height: 100%;
}
#text-table-of-contents ul {
padding-left: 1em;
margin-left: 0.5em;
}
#table-of-contents > h2 {
padding: 0.1em;
margin: 0;
}
/* adjustments for small screen, toc at top only */
@media (max-width: 800px) { /* landscape for iphone */
html {
-webkit-text-size-adjust: none;  /* prevent scaling of text on mobile */
}
body {
background-color: #EEE;
width:100%;
margin:0 auto;
}
#content, #preamble, #postamble {
margin-left:0;
}
#table-of-contents {
position: static;
left: inherit;
width:inherit;
height: auto;
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
border: 0.75em solid #006633;
}
div.outline-2, #table-of-contents {
background-color: rgb(250,250,250);
border: 0.75em solid var(--heading-bg-color);
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
}
div.outline-2 > h2, #table-of-contents > h2 {
background-color: var(--heading-bg-color);
color: var(--heading-fg-color);
font-variant: small-caps;
padding: 0em 0em 0em .5em; /* top right bottom left */
margin: 0em -.5em 0em -.75em; /* top right bottom left */
text-align: left;
}
#text-table-of-contents {
overflow-y: visible;
height: inherit;
}
#text-table-of-contents ul {
padding-left: 1em;
margin-left: 0.5em;
}
}
.linenr { font-size: xx-small; }
}

@media print {
html {
font-family: serif;
font-size: 10pt;
text-align: justify;
.linenr { font-size: xx-small; }
}
}
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="preamble" class="status">
<i>Last Updated: 2022-04-25 Mon 21:40</i>
</div>
<div id="content">
<h1 class="title">CSCI 2021 Project 5: Memory Allocator</h1>
<ul class="org-ul">
<li><b>Due: 11:59pm Mon 5/02/2022</b></li>
<li><i>Approximately 3.0-4.0% of total grade</i></li>
<li>Submit to <a href="https://www.gradescope.com/"><b>Gradescope</b></a> (submission now open)</li>
<li>Projects are <b>individual work</b>: no collaboration with other students
is allowed. Seek help from course staff if you get stuck for too long.</li>
</ul>

<div id="outline-container-orgd6be1fa" class="outline-4">
<h4 id="orgd6be1fa">CODE DISTRIBUTION: <a href="p5-code.zip">p5-code.zip</a></h4>
</div>

<div id="outline-container-org9596e23" class="outline-4">
<h4 id="org9596e23">Video Overview: <i>Not Yet Available</i></h4>
</div>

<div id="outline-container-org33c133e" class="outline-4">
<h4 id="org33c133e">CHANGELOG: Empty</h4>
<div class="outline-text-4" id="text-org33c133e">
</div>
</div>

<div id="outline-container-orgf310c8a" class="outline-4">
<h4 id="orgf310c8a"></h4>
<div class="outline-text-4" id="text-orgf310c8a">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5967a33">1. Overview</a></li>
<li><a href="#org29ddc12">2. Download Code and Setup</a></li>
<li><a href="#org1b7e63e">3. <b>Problem 1</b> : EL Malloc</a>
<ul>
<li><a href="#org1abfd0e">3.1. EL Malloc Data Structures</a></li>
<li><a href="#org1fb9a69">3.2. Block Header/Footer</a></li>
<li><a href="#org2f13056">3.3. Footers and Blocks Above/Below</a></li>
<li><a href="#orgd16fb0c">3.4. Block Lists and Global Control</a></li>
<li><a href="#orge610565">3.5. Pointers and "Actual" Space</a></li>
<li><a href="#org6753c14">3.6. Doubly Linked List Operations</a></li>
<li><a href="#org4e3098c">3.7. Allocation via Block Splitting</a></li>
<li><a href="#org87c30c9">3.8. Freeing Blocks and Merging</a></li>
<li><a href="#orga817088">3.9. Expanding the Heap</a></li>
<li><a href="#org0f6bb99">3.10. Overall Code Structure of EL Malloc</a></li>
<li><a href="#org1fe4cfa">3.11. Demo Run using EL Malloc</a></li>
<li><a href="#org3db8d1d">3.12. Grading Criteria for El Malloc</a></li>
</ul>
</li>
<li><a href="#org878cdeb">4. Project Submission</a>
<ul>
<li><a href="#orgad5801b">4.1. Submit to Gradescope</a></li>
<li><a href="#org32499a3">4.2. Late Policies</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org5967a33" class="outline-2">
<h2 id="org5967a33"><span class="section-number-2">1</span> Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
This project features a single required problem pertaining to the
final topics discussed in lecture.
</p>
<ul class="org-ul">
<li>EL Malloc implements a simple, explicit list memory
allocator.  This manages heap memory in doubly linked lists of
Available and Used memory blocks to provide <code>el_malloc() /
  el_free()</code>. It could be extended with some work to be a drop-in
replacement for <code>malloc() / free()</code>.</li>
</ul>
</div>
</div>


<div id="outline-container-org29ddc12" class="outline-2">
<h2 id="org29ddc12"><span class="section-number-2">2</span> <a id="org7d6ac3c"></a> Download Code and Setup</h2>
<div class="outline-text-2" id="text-2">
<p>
Download the code pack linked at the top of the page. Unzip this which
will create a project folder. Create new files in this
folder. Ultimately you will re-zip this folder to submit it.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">File</th>
<th scope="col" class="org-left">State</th>
<th scope="col" class="org-left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>Makefile</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Build file to compile all programs</td>
</tr>

<tr>
<td class="org-left"><code>testy</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Test running script</td>
</tr>

<tr>
<td class="org-left"><code>test-input/*</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Problem 1 and 2: Directory with required data files</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>el_malloc.h</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 2 header file</td>
</tr>

<tr>
<td class="org-left"><code>el_demo.h</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Problem 2 demo main()</td>
</tr>

<tr>
<td class="org-left"><code>el_malloc.c</code></td>
<td class="org-left">COMPLETE</td>
<td class="org-left">Problem 2 implemented REQUIRED functions</td>
</tr>

<tr>
<td class="org-left"><code>test_el_malloc.c</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Problem 2 Testing program for El Malloc</td>
</tr>

<tr>
<td class="org-left"><code>test_el_malloc.org</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Problem 2 Testing script for El Malloc</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org1b7e63e" class="outline-2">
<h2 id="org1b7e63e"><span class="section-number-2">3</span> <b>Problem 1</b> : EL Malloc</h2>
<div class="outline-text-2" id="text-3">
<p>
A <b>memory allocator</b> is small system which manages heap memory,
sometimes referred to as the "data" segment of a program.  This
portion of program memory is a linear set of addresses that form a
large block which an expand at runtime by making requests to the
operating system.  Solving the allocation problem forms backbone of
what <code>malloc()/free()</code> do by keeping track of the space used and
released by a user program.  Allocators also see use in garbage
collected languages like Java where there are no explicit <code>free()</code>
calls but the allocator must still find available space for new
objects.
</p>

<p>
One simple way to implement an allocator is to overlay linked lists
on the heap which track at a minimum the available chunks of memory
and possibly also the used chunks.  This comes with a cost: some of
the bytes of memory in the heap are no longer available for the user
program but are instead used for the allocator's book-keeping.  
</p>

<p>
In this problem, an <i>explicit list</i> allocator is developed, thus the
name of the system <code>el_malloc</code>.  It uses two lists to track memory in
the heap:
</p>
<ul class="org-ul">
<li>The <b>Available List</b> of blocks of memory that can be used to answer
calls to <code>malloc()</code></li>
<li>The <b>Used List</b> of blocks that have been returned by <code>malloc()</code> and
should not be returned again until they are <code>free()'d</code></li>
</ul>
<p>
Most operations boil down to manipulating these two lists in some
form.
</p>
<ul class="org-ul">
<li>Allocating with <code>ptr = el_malloc(size);</code> searches the Available List for a
block with sufficient size. That block is split into two blocks. One block
answers the request and is given about <code>size</code> bytes; it is moved to
the Used List. The second block comprises the remainder of the space
and remains on the Available List.</li>
<li>Deallocating with <code>el_free(ptr);</code> moves the block referenced by
<code>ptr</code> from the Used List to the Available List.  To prevent
fragmentation of memory, the newly available block is <b>merged</b> with
adjacent available blocks if possible.</li>
</ul>
</div>

<div id="outline-container-org1abfd0e" class="outline-3">
<h3 id="org1abfd0e"><span class="section-number-3">3.1</span> EL Malloc Data Structures</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Several data structures defined in <code>el_malloc.h</code> should be studied so
that one is acquainted with their intent. The following sections
outline many of these and show diagrams to indicate transformation
the required functions should implement.
</p>
</div>
</div>

<div id="outline-container-org1fb9a69" class="outline-3">
<h3 id="org1fb9a69"><span class="section-number-3">3.2</span> Block Header/Footer</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Each block of memory tracked by EL Malloc is preceded and succeeded by
some bytes of memory for book keeping.  These are referred to as the
block "header" and "footer" and are encoded in the <code>el_blockhead_t</code>
and <code>el_blockfoot_t</code> structs.
</p>

<div class="org-src-container">
<pre class="src src-c">// type which is a "header" for a block of memory; containts info on
// size, whether the block is available or in use, and links to the
// next/prev blocks in a doubly linked list. This data structure
// appears immediately before a block of memory that is tracked by the
// allocator.
typedef struct block {
  size_t size;                  // number of bytes of memory in this block
  char state;                   // either EL_AVAILABLE or EL_USED
  struct block *next;           // pointer to next block in same list
  struct block *prev;           // pointer to previous block in same list
} el_blockhead_t;

// Type for the "footer" of a block; indicates size of the preceding
// block so that its header el_blockhead_t can be found with pointer
// arithmetic. This data appears immediately after an area of memory
// that may be used by a user or is free. Immediately after it is
// either another header (el_blockhead_t) or the end of the heap.
typedef struct {
  size_t size;
} el_blockfoot_t;
</pre>
</div>

<p>
As indicated, the blocks use <b>doubly linked nodes</b> in the header which
will allow easy re-arrangement of the list.
</p>

<p>
A picture of a block with its header, footer, and user data area is
shown below.
</p>
<div class="org-center">

<div id="org35f67cd" class="figure">
<p><img src="block.png" alt="block.png" style="max-width:100%;" />
</p>
<p><span class="figure-number">Figure 1: </span>Block data preceded by a header (<code>el_blockhead_t</code>) and followed by a footer (<code>el_blockfoot_t</code>)._</p>
</div>
</div>
</div>
</div>



<div id="outline-container-org2f13056" class="outline-3">
<h3 id="org2f13056"><span class="section-number-3">3.3</span> Footers and Blocks Above/Below</h3>
<div class="outline-text-3" id="text-3-3">
<p>
One might wonder why the footer appears.  In tracking blocks, there
will arise the need to determine a block that is immediately before a
given block in memory (not the previous in the linked list).  The
footer enables this by tracking the size of the user block of memory
immediately preceding it. 
</p>


<p>
This is illustrated in the diagram below.
</p>
<div class="org-center">

<div id="org4ee6c71" class="figure">
<p><img src="headfoot.png" alt="headfoot.png" style="max-width:100%;" />
</p>
<p><span class="figure-number">Figure 2: </span>Finding preceding block header using footer (<code>el_block_below(header)</code>)</p>
</div>
</div>

<p>
This operation is implemented in the function <code>el_block_below(block)</code> and
the similar operation <code>el_block_above(block)</code> finds the next header
immediately following one in memory.
</p>

<p>
The following functions use pointer arithmetic to determine block
locations from a provided pointer.
</p>
<div class="org-src-container">
<pre class="src src-c">el_blockfoot_t *el_get_footer(el_blockhead_t *block);
el_blockhead_t *el_get_header(el_blockfoot_t *foot);
el_blockhead_t *el_block_above(el_blockhead_t *block);
el_blockhead_t *el_block_below(el_blockhead_t *block);
</pre>
</div>

<p>
These functions benefit from macros defined in <code>el_malloc.h</code> that are
useful for doing pointer operations involving bytes.
</p>
<div class="org-src-container">
<pre class="src src-c">// macro to add a byte offset to a pointer, arguments are a pointer
// and a # of bytes (usually size_t)
#define PTR_PLUS_BYTES(ptr,off) ((void *) (((size_t) (ptr)) + ((size_t) (off))))

// macro to add a byte offset to a pointer, arguments are a pointer
// and a # of bytes (usually size_t)
#define PTR_MINUS_BYTES(ptr,off) ((void *) (((size_t) (ptr)) - ((size_t) (off))))

// macro to add a byte offset to a pointer, arguments are a pointer
// and a # of bytes (usually size_t)
#define PTR_MINUS_PTR(ptr,ptq) (((size_t) (ptr)) - ((size_t) (ptq)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd16fb0c" class="outline-3">
<h3 id="orgd16fb0c"><span class="section-number-3">3.4</span> Block Lists and Global Control</h3>
<div class="outline-text-3" id="text-3-4">
<p>
The main purpose of the memory allocator is to track the available and
used blocks in explicit linked lists. This allows used and available
memory to be distributed throughout the heap. Below are the data
structures that track these lists and the global control data
structure which houses information for the entire heap.
</p>

<div class="org-src-container">
<pre class="src src-c">// Type for a list of blocks; doubly linked with a fixed
// "dummy" node at the beginning and end which do not contain any
// data. List tracks its length and number of bytes in use.
typedef struct {
  el_blockhead_t beg_actual;    // fixed node at beginning of list; state is EL_BEGIN_BLOCK
  el_blockhead_t end_actual;    // fixed node at end of list; state is EL_END_BLOCK
  el_blockhead_t *beg;          // pointer to beg_actual
  el_blockhead_t *end;          // pointer to end_actual
  size_t length;                // length of the used block list (not counting beg/end)
  size_t bytes;                 // total bytes in list used including overhead; 
} el_blocklist_t;
// NOTE: total available bytes for use/in-use in the list is (bytes - length*EL_BLOCK_OVERHEAD)

// Type for the global control of the allocator. Tracks heap size,
// start and end addresses, total size, and lists of available and
// used blocks.
typedef struct {
  void *heap_start;             // pointer to where the heap starts
  void *heap_end;               // pointer to where the heap ends; this memory address is out of bounds
  size_t heap_bytes;            // number of bytes currently in the heap
  el_blocklist_t avail_actual;  // space for the available list data
  el_blocklist_t used_actual;   // space for the used list data
  el_blocklist_t *avail;        // pointer to avail_actual
  el_blocklist_t *used;         // pointer to used_actual
} el_ctl_t;
</pre>
</div>

<p>
The following diagram shows some of the structure induced by use of a
doubly linked lists overlaid onto the heap. The global control
structure <code>el_ctl</code> has two lists for available and used space.
</p>

<div class="org-center">

<div id="org71bffe1" class="figure">
<p><img src="listsglobal.png" alt="listsglobal.png" style="max-width:100%;" />
</p>
<p><span class="figure-number">Figure 3: </span>Structure of heap with several used/available blocks. Pointers from <code>el_ctl</code> lists allow access to these blocks.</p>
</div>
</div>


<p>
The following functions initialize the global control structures,
print stats on the heap, and clean up at the end of execution.
</p>
<div class="org-src-container">
<pre class="src src-c">int el_init(int max_bytes);
void el_print_stats();
void el_cleanup();
</pre>
</div>
</div>
</div>


<div id="outline-container-orge610565" class="outline-3">
<h3 id="orge610565"><span class="section-number-3">3.5</span> Pointers and "Actual" Space</h3>
<div class="outline-text-3" id="text-3-5">
<p>
In several structures, there appear pointers named <code>xxx</code> and structs
named <code>xxx_actual</code>.  For example, in <code>el_blocklist_t</code>:
</p>
<div class="org-src-container">
<pre class="src src-c">typedef struct {
  ...
  el_blockhead_t beg_actual;    // fixed node at beginning of list; state is EL_BEGIN_BLOCK
  el_blockhead_t *beg;          // pointer to beg_actual
  ...
} el_blocklist_t;
</pre>
</div>
<p>
The intent here is that there will <i>always</i> be a node at the beginning
of the doubly linked list which just to make the programming easier so
it makes sense to have an actual struct <code>beg_actual</code> present.
However, when working with the list, the address of the beginning node
is often referenced making <code>beg</code> useful. In any case, <code>beg</code> will be
initialized to <code>&amp;beg_actual</code> as appears in <code>el_init_blocklist()</code>.
</p>
<div class="org-src-container">
<pre class="src src-c">void el_init_blocklist(el_blocklist_t *list){
  list-&gt;beg        = &amp;(list-&gt;beg_actual); 
  list-&gt;beg-&gt;state = EL_BEGIN_BLOCK;
  list-&gt;beg-&gt;size  = EL_UNINITIALIZED;
  ...  
}
</pre>
</div>

<p>
Similarly, since there will always be an Available List, <code>el_ctl_t</code>
has both an <code>avail</code> pointer to the list and <code>avail_actual</code> which is
the struct for the list.
</p>
</div>
</div>

<div id="outline-container-org6753c14" class="outline-3">
<h3 id="org6753c14"><span class="section-number-3">3.6</span> Doubly Linked List Operations</h3>
<div class="outline-text-3" id="text-3-6">
<p>
A large number of operations in EL Malloc boil down to doubly linked
list operations. This includes
</p>
<ul class="org-ul">
<li>Unlinking nodes from the middle of list during <code>el_free()</code></li>
<li>Adding nodes to the beginning of a headed list (allocation and free)</li>
<li>Traversing the list to print and search for available blocks</li>
</ul>

<p>
Recall that unlinking a node from a doubly linked list involves
modifying the previous and next node as in the following.
</p>
<div class="org-src-container">
<pre class="src src-c">  node-&gt;prev-&gt;next = node-&gt;next;
  node-&gt;next-&gt;prev = node-&gt;prev;
</pre>
</div>
<p>
while adding a new node to the front is typically accomplished via
</p>
<div class="org-src-container">
<pre class="src src-c">  node-&gt;prev = list-&gt;beg;
  node-&gt;next = list-&gt;beg-&gt;next;
  node-&gt;prev-&gt;next = node;
  node-&gt;next-&gt;prev = node;
</pre>
</div>

<p>
You may wish to review doubly linked list operations and do some
reading on lists with "dummy" nodes at the beginning and ending if
these concepts are rusty.
</p>

<p>
The following functions pertain to block list operations.
</p>
<div class="org-src-container">
<pre class="src src-c">void el_init_blocklist(el_blocklist_t *list);
void el_print_blocklist(el_blocklist_t *list);
void el_add_block_front(el_blocklist_t *list, el_blockhead_t *block);
void el_remove_block(el_blocklist_t *list, el_blockhead_t *block);
</pre>
</div>
</div>
</div>

<div id="outline-container-org4e3098c" class="outline-3">
<h3 id="org4e3098c"><span class="section-number-3">3.7</span> Allocation via Block Splitting</h3>
<div class="outline-text-3" id="text-3-7">
<p>
The basic operation of granting memory on a call to <code>el_malloc(size)</code>
involves finding an Available Block with enough bytes for <b>both</b> the
requested amount of memory and a new header/footer combination.  The
current requirement is that <b>a block always gets split</b> on an
allocation though a straight-forward optimization would be to not
split in the case of a close or exact size match.
</p>

<p>
This process is demonstrated in the below diagram in which a request
for some bytes has been made. The process prior to diagram involves
searching the Available List for a block with enough space.  Once
found, the block is split into the portion that will be used and the
remaining portion. A pointer to the user area immediately after the
<code>el_blockhead_t</code> is returned.
</p>

<div class="org-center">

<div id="org1f3637f" class="figure">
<p><img src="split.png" alt="split.png" style="max-width:100%;" />
</p>
<p><span class="figure-number">Figure 4: </span>Splitting a block in an allocation request.</p>
</div>
</div>

<p>
The following functions pertain to the location and splitting of
blocks in the available list to fulfill allocation requests.
</p>
<div class="org-src-container">
<pre class="src src-c">el_blockhead_t *el_find_first_avail(size_t size);
el_blockhead_t *el_split_block(el_blockhead_t *block, size_t new_size);
void *el_malloc(size_t nbytes);
</pre>
</div>
</div>
</div>

<div id="outline-container-org87c30c9" class="outline-3">
<h3 id="org87c30c9"><span class="section-number-3">3.8</span> Freeing Blocks and Merging</h3>
<div class="outline-text-3" id="text-3-8">
<p>
Freeing memory passes in a pointer to the user area that was
granted. Immediately preceding this should be a <code>el_blockhead_t</code> and
it can be found with pointer arithmetic.  
</p>

<p>
In order to prevent memory from becoming continually divided into
smaller blocks, on freeing the system checks to see if adjacent blocks
can be merged.  Keep in mind that the blocks that can be merged are
<b>adjacent in memory</b>, not next/previous in some linked list.  Adjacent
blocks can be located using <code>el_block_above()</code> and <code>el_block_below()</code>.
</p>

<p>
To merge, the adjacent blocks must both be Available (not Used).  A
free can then have several cases.
</p>
<ol class="org-ol">
<li>The freed block cannot be merged with any others</li>
<li>The freed block can be merged with only the block above it</li>
<li>The freed block can be merged with only the block below it</li>
<li>The freed block can be merged with both adjacent blocks</li>
</ol>

<p>
The diagrams below show two of these cases.
</p>
<div class="org-center">

<div id="orgd907e7a" class="figure">
<p><img src="free-merge.png" alt="free-merge.png" style="max-width:100%;" />
</p>
<p><span class="figure-number">Figure 5: </span>Two cases of freeing blocks. The 2nd involves merging adjacent nodes with available space.</p>
</div>
</div>

<p>
With careful use of the below functions and handling of <code>NULL</code>
arguments, all 4 cases can be handled with very little code.  Keep in
mind that <code>el_block_above()/below()</code> should return <code>NULL</code> if there is
no block above or below due to that are being out of the boundaries of
the heap.
</p>
<div class="org-src-container">
<pre class="src src-c">el_blockhead_t *el_block_above(el_blockhead_t *block);
el_blockhead_t *el_block_below(el_blockhead_t *block);
void el_merge_block_with_above(el_blockhead_t *lower);
void el_free(void *ptr);
</pre>
</div>
</div>
</div>

<div id="outline-container-orga817088" class="outline-3">
<h3 id="orga817088"><span class="section-number-3">3.9</span> Expanding the Heap</h3>
<div class="outline-text-3" id="text-3-9">
<p>
El Malloc initializes the heap with just a single page of memory
(<code>EL_PAGE_BYTES</code> = 4096 bytes) during <code>el_init()</code>.  While good for
testing, a real application would need more space than this. The
beginnings of <b>heap expansion</b> are provided via the following
function.
</p>
<div class="org-src-container">
<pre class="src src-c">int el_append_pages_to_heap(int npages);
// REQUIRED
// Attempts to append pages of memory to the heap with mmap(). npages
// is how many pages are to be appended with total bytes to be
// appended as npages * EL_PAGE_BYTES. Calls mmap() with similar
// arguments to those used in el_init() however requests the address
// of the pages to be at heap_end so that the heap grows
// contiguously. If this fails, prints the message
// 
//  ERROR: Unable to mmap() additional 3 pages
// 
// and returns 1. Note that mmap() returns the constant MAP_FAILED on
// errors and the returned address will not match the requested
// virtual address on failures.
//
// Otherwise, adjusts heap size and end for the expanded heap. Creates
// a new block for the freshly allocated pages that is added to the
// available list. Also attempts to merge this block with the block
// below it. Returns 0 on success.
</pre>
</div>

<p>
The central idea of the function is to allocate more space for the
heap through <code>mmap()</code> calls. Since it is desirable to treat the heap
a contiguous block of memory, the calls to <code>mmap()</code> should attempt to
map new space for the heap to the <code>el_ctl-&gt;heap_end</code> address thereby
"appending" the pages the heap.
</p>

<p>
Here are a few implementation notes.
</p>
<ul class="org-ul">
<li>In some cases, <code>NULL</code> is passed as the first argument to <code>mmap()</code> as
a user program does not care what virtual address the OS uses for
pages of memory. However, El Malloc will have specific addresses
that it uses for the heap start and expansion.</li>
<li>Analyze the provided <code>el_init()</code> function which initially uses
<code>mmap()</code> to create the heap. Many aspects of the setup function can
be transferred here.</li>
<li>One difference is that while <code>el_init()</code> allocates the heap at
<code>EL_HEAP_START_ADDRESS</code>, <code>el_append_pages_to_heap()</code> should map
pages starting at the heap end. This will create a continuous
virtual memory space for the heap as it expands.</li>
<li>If <code>mmap()</code> fails, it does NOT return <code>NULL</code> and rather returns a
special constant <code>MAP_FAIL</code> which will be different from the
requested address. Check if <code>mmap()</code> succeeds or fails based on this
constant and print the error message indicated if so.</li>
</ul>
</div>
</div>


<div id="outline-container-org0f6bb99" class="outline-3">
<h3 id="org0f6bb99"><span class="section-number-3">3.10</span> Overall Code Structure of EL Malloc</h3>
<div class="outline-text-3" id="text-3-10">
<p>
Below is the code structure of the EL Malloc library.  Some of the
functions have been implemented already while those marked <code>REQUIRED</code>
must be completed for full credit on the problem.
</p>

<pre class="example" id="org0a3d41c">
// el_malloc.c: implementation of explicit list malloc functions.
/////////// SOLUTION //////////////

////////////////////////////////////////////////////////////////////////////////
// Global control functions

int el_init();
// Create an initial block of memory for the heap using
// mmap(). Initialize the el_ctl data structure to point at this
// block. The initializ size/position of the heap for the memory map
// are given in the symbols EL_HEAP_INITIAL_SIZE and
// EL_HEAP_START_ADDRESS.  Initialize the lists in el_ctl to contain a
// single large block of available memory and no used blocks of
// memory.

void el_cleanup();
// Clean up the heap area associated with the system which unmaps all
// pages associated with the heap.

////////////////////////////////////////////////////////////////////////////////
// Pointer arithmetic functions to access adjacent headers/footers

el_blockfoot_t *el_get_footer(el_blockhead_t *head);
// Compute the address of the foot for the given head which is at a
// higher address than the head.

el_blockhead_t *el_get_header(el_blockfoot_t *foot);
// REQUIRED
// Compute the address of the head for the given foot which is at a
// lower address than the foot.

el_blockhead_t *el_block_above(el_blockhead_t *block);
// Return a pointer to the block that is one block higher in memory
// from the given block.  This should be the size of the block plus
// the EL_BLOCK_OVERHEAD which is the space occupied by the header and
// footer. Returns NULL if the block above would be off the heap.
// DOES NOT follow next pointer, looks in adjacent memory.

el_blockhead_t *el_block_below(el_blockhead_t *block);
// REQUIRED
// Return a pointer to the block that is one block lower in memory
// from the given block.  Uses the size of the preceding block found
// in its foot. DOES NOT follow block-&gt;next pointer, looks in adjacent
// memory. Returns NULL if the block below would be outside the heap.
// 
// WARNING: This function must perform slightly different arithmetic
// than el_block_above(). Take care when implementing it.

////////////////////////////////////////////////////////////////////////////////
// Block list operations

void el_print_blocklist(el_blocklist_t *list);
// Print an entire blocklist. The format appears as follows.
//
// {length:   2  bytes:  3400}
//   [  0] head @ 0x600000000000 {state: a  size:   128}
//   [  1] head @ 0x600000000360 {state: a  size:  3192}
//
// Note that the '@' column uses the actual address of items which
// relies on a consistent mmap() starting point for the heap.

void el_print_block(el_blockhead_t *block);
// Print a single block during a sequential walk through the heap

void el_print_stats();
// Print out stats on the heap for use in debugging. Shows the
// available and used list along with a linear walk through the heap
// blocks.

void el_init_blocklist(el_blocklist_t *list);
// Initialize the specified list to be empty. Sets the beg/end
// pointers to the actual space and initializes those data to be the
// ends of the list.  Initializes length and size to 0.

void el_add_block_front(el_blocklist_t *list, el_blockhead_t *block);
// REQUIRED
// Add to the front of list; links for block are adjusted as are links
// within list.  Length is incremented and the bytes for the list are
// updated to include the new block's size and its overhead.

void el_remove_block(el_blocklist_t *list, el_blockhead_t *block);
// REQUIRED
// Unlink block from the list it is in which should be the list
// parameter.  Updates the length and bytes for that list including
// the EL_BLOCK_OVERHEAD bytes associated with header/footer.

////////////////////////////////////////////////////////////////////////////////
// Allocation-related functions

el_blockhead_t *el_find_first_avail(size_t size);
// REQUIRED
// Find the first block in the available list with block size of at
// least (size+EL_BLOCK_OVERHEAD). Overhead is accounted so this
// routine may be used to find an available block to split: splitting
// requires adding in a new header/footer. Returns a pointer to the
// found block or NULL if no of sufficient size is available.

el_blockhead_t *el_split_block(el_blockhead_t *block, size_t new_size);
// REQUIRED
// Set the pointed to block to the given size and add a footer to
// it. Creates another block above it by creating a new header and
// assigning it the remaining space. Ensures that the new block has a
// footer with the correct size. Returns a pointer to the newly
// created block while the parameter block has its size altered to
// parameter size. Does not do any linking of blocks.  If the
// parameter block does not have sufficient size for a split (at least
// new_size + EL_BLOCK_OVERHEAD for the new header/footer) makes no
// changes tot the block and returns NULL indicating no new block was
// created.

void *el_malloc(size_t nbytes);
// REQUIRED
// Return pointer to a block of memory with at least the given size
// for use by the user.  The pointer returned is to the usable space,
// not the block header. Makes use of find_first_avail() to find a
// suitable block and el_split_block() to split it.  Returns NULL if
// no space is available.

////////////////////////////////////////////////////////////////////////////////
// De-allocation/free() related functions

void el_merge_block_with_above(el_blockhead_t *lower);
// REQUIRED
// Attempt to merge the block lower with the next block in
// memory. Does nothing if lower is null or not EL_AVAILABLE and does
// nothing if the next higher block is null (because lower is the last
// block) or not EL_AVAILABLE.  Otherwise, locates the next block with
// el_block_above() and merges these two into a single block. Adjusts
// the fields of lower to incorporate the size of higher block and the
// reclaimed overhead. Adjusts footer of higher to indicate the two
// blocks are merged.  Removes both lower and higher from the
// available list and re-adds lower to the front of the available
// list.

void el_free(void *ptr);
// REQUIRED
// Free the block pointed to by the give ptr.  The area immediately
// preceding the pointer should contain an el_blockhead_t with information
// on the block size. Attempts to merge the free'd block with adjacent
// blocks using el_merge_block_with_above().

////////////////////////////////////////////////////////////////////////////////
// HEAP EXPANSION FUNCTIONS

int el_append_pages_to_heap(int npages);
// Attempts to append pages of memory to the heap with mmap(). npages
// is how many pages are to be appended with total bytes to be
// appended as npages * EL_PAGE_BYTES. Calls mmap() with similar
// arguments to those used in el_init() however requests the address
// of the pages to be at heap_end so that the heap grows
// contiguously. If this fails, prints the message
// 
//  ERROR: Unable to mmap() additional 3 pages
// 
// and returns 1. Note that mmap() returns the constant MAP_FAILED on
// errors and the returned address will not match the requested
// virtual address on failures.
//
// Otherwise, adjusts heap size and end for the expanded heap. Creates
// a new block for the freshly allocated pages that is added to the
// available list. Also attempts to merge this block with the block
// below it. Returns 0 on success.

</pre>
</div>
</div>

<div id="outline-container-org1fe4cfa" class="outline-3">
<h3 id="org1fe4cfa"><span class="section-number-3">3.11</span> Demo Run using EL Malloc</h3>
<div class="outline-text-3" id="text-3-11">
<p>
Below is a run showing the behavior of a series of <code>el_malloc() /
el_free()</code> calls.  They are performed in the provided <code>el_demo.c</code>
program. 
</p>
</div>

<div id="outline-container-org00efc59" class="outline-4">
<h4 id="org00efc59">Source for <code>el_demo.c</code></h4>
<div class="outline-text-4" id="text-org00efc59">
<div class="org-src-container">
<pre class="src src-c">// el_demo.c: Shows use cases for el_malloc() and el_free(). This file
// can be used for testing but is not itself a test.

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include "el_malloc.h"

void print_ptr(char *str, void *ptr){
  if(ptr == NULL){
    printf("%s: (nil)\n", str);
  }
  else{
    printf("%s: %p\n", str, ptr);
  }
}

int main(){
  printf("EL_BLOCK_OVERHEAD: %lu\n",EL_BLOCK_OVERHEAD);
  el_init();

  printf("INITIAL\n"); el_print_stats(); printf("\n");

  void *p1 = el_malloc(128);
  void *p2 = el_malloc(48);
  void *p3 = el_malloc(156);
  printf("MALLOC 3\n"); el_print_stats(); printf("\n");

  printf("POINTERS\n");
  print_ptr("p3",p3);
  print_ptr("p2",p2);
  print_ptr("p1",p1);
  printf("\n");

  void *p4 = el_malloc(22);
  void *p5 = el_malloc(64);
  printf("MALLOC 5\n"); el_print_stats(); printf("\n");

  printf("POINTERS\n");
  print_ptr("p5",p5);
  print_ptr("p4",p4);
  print_ptr("p3",p3);
  print_ptr("p2",p2);
  print_ptr("p1",p1);
  printf("\n");

  el_free(p1);
  printf("FREE 1\n"); el_print_stats(); printf("\n");

  el_free(p3);
  printf("FREE 3\n"); el_print_stats(); printf("\n");

  p3 = el_malloc(32);
  p1 = el_malloc(200);
  
  printf("ALLOC 3,1 AGAIN\n"); el_print_stats(); printf("\n");

  printf("POINTERS\n");
  print_ptr("p1",p1);
  print_ptr("p3",p3);
  print_ptr("p5",p5);
  print_ptr("p4",p4);
  print_ptr("p2",p2);
  printf("\n");

  el_free(p1);

  printf("FREE'D 1\n"); el_print_stats(); printf("\n");

  el_free(p2);

  printf("FREE'D 2\n"); el_print_stats(); printf("\n");

  p1 = el_malloc(3438);
  p2 = el_malloc(1024);
  printf("P2 FAILS\n");
  printf("POINTERS\n");
  print_ptr("p1",p1);
  print_ptr("p3",p3);
  print_ptr("p5",p5);
  print_ptr("p4",p4);
  print_ptr("p2",p2);
  el_print_stats(); printf("\n");

  el_append_pages_to_heap(3);
  printf("APPENDED PAGES\n"); el_print_stats(); printf("\n");

  p2 = el_malloc(1024);
  printf("P2 SUCCEEDS\n");
  printf("POINTERS\n");
  print_ptr("p1",p1);
  print_ptr("p3",p3);
  print_ptr("p5",p5);
  print_ptr("p4",p4);
  print_ptr("p2",p2);
  el_print_stats(); printf("\n");  

  el_free(p1);
  el_free(p2);
  el_free(p3);
  el_free(p4);
  el_free(p5);

  printf("FREE'D 1-5\n"); el_print_stats(); printf("\n");

  el_cleanup();
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f2f880" class="outline-4">
<h4 id="org8f2f880"><a id="orgbc494fe"></a> Output of El Malloc Demo</h4>
<div class="outline-text-4" id="text-org8f2f880">
<div class="org-src-container">
<pre class="src src-text">EL_BLOCK_OVERHEAD: 40
INITIAL
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000001000
total_bytes: 4096
AVAILABLE LIST: {length:   1  bytes:  4096}
  [  0] head @ 0x612000000000 {state: a  size:  4056}
USED LIST: {length:   0  bytes:     0}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      a
  size:       4056 (total: 0x1000)
  prev:       0x610000000018
  next:       0x610000000038
  user:       0x612000000020
  foot:       0x612000000ff8
  foot-&gt;size: 4056

MALLOC 3
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000001000
total_bytes: 4096
AVAILABLE LIST: {length:   1  bytes:  3644}
  [  0] head @ 0x6120000001c4 {state: a  size:  3604}
USED LIST: {length:   3  bytes:   452}
  [  0] head @ 0x612000000100 {state: u  size:   156}
  [  1] head @ 0x6120000000a8 {state: u  size:    48}
  [  2] head @ 0x612000000000 {state: u  size:   128}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      u
  size:       128 (total: 0xa8)
  prev:       0x6120000000a8
  next:       0x610000000098
  user:       0x612000000020
  foot:       0x6120000000a0
  foot-&gt;size: 128
[  1] @ 0x6120000000a8
  state:      u
  size:       48 (total: 0x58)
  prev:       0x612000000100
  next:       0x612000000000
  user:       0x6120000000c8
  foot:       0x6120000000f8
  foot-&gt;size: 48
[  2] @ 0x612000000100
  state:      u
  size:       156 (total: 0xc4)
  prev:       0x610000000078
  next:       0x6120000000a8
  user:       0x612000000120
  foot:       0x6120000001bc
  foot-&gt;size: 156
[  3] @ 0x6120000001c4
  state:      a
  size:       3604 (total: 0xe3c)
  prev:       0x610000000018
  next:       0x610000000038
  user:       0x6120000001e4
  foot:       0x612000000ff8
  foot-&gt;size: 3604

POINTERS
p3: 0x612000000120
p2: 0x6120000000c8
p1: 0x612000000020

MALLOC 5
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000001000
total_bytes: 4096
AVAILABLE LIST: {length:   1  bytes:  3478}
  [  0] head @ 0x61200000026a {state: a  size:  3438}
USED LIST: {length:   5  bytes:   618}
  [  0] head @ 0x612000000202 {state: u  size:    64}
  [  1] head @ 0x6120000001c4 {state: u  size:    22}
  [  2] head @ 0x612000000100 {state: u  size:   156}
  [  3] head @ 0x6120000000a8 {state: u  size:    48}
  [  4] head @ 0x612000000000 {state: u  size:   128}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      u
  size:       128 (total: 0xa8)
  prev:       0x6120000000a8
  next:       0x610000000098
  user:       0x612000000020
  foot:       0x6120000000a0
  foot-&gt;size: 128
[  1] @ 0x6120000000a8
  state:      u
  size:       48 (total: 0x58)
  prev:       0x612000000100
  next:       0x612000000000
  user:       0x6120000000c8
  foot:       0x6120000000f8
  foot-&gt;size: 48
[  2] @ 0x612000000100
  state:      u
  size:       156 (total: 0xc4)
  prev:       0x6120000001c4
  next:       0x6120000000a8
  user:       0x612000000120
  foot:       0x6120000001bc
  foot-&gt;size: 156
[  3] @ 0x6120000001c4
  state:      u
  size:       22 (total: 0x3e)
  prev:       0x612000000202
  next:       0x612000000100
  user:       0x6120000001e4
  foot:       0x6120000001fa
  foot-&gt;size: 22
[  4] @ 0x612000000202
  state:      u
  size:       64 (total: 0x68)
  prev:       0x610000000078
  next:       0x6120000001c4
  user:       0x612000000222
  foot:       0x612000000262
  foot-&gt;size: 64
[  5] @ 0x61200000026a
  state:      a
  size:       3438 (total: 0xd96)
  prev:       0x610000000018
  next:       0x610000000038
  user:       0x61200000028a
  foot:       0x612000000ff8
  foot-&gt;size: 3438

POINTERS
p5: 0x612000000222
p4: 0x6120000001e4
p3: 0x612000000120
p2: 0x6120000000c8
p1: 0x612000000020

FREE 1
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000001000
total_bytes: 4096
AVAILABLE LIST: {length:   2  bytes:  3646}
  [  0] head @ 0x612000000000 {state: a  size:   128}
  [  1] head @ 0x61200000026a {state: a  size:  3438}
USED LIST: {length:   4  bytes:   450}
  [  0] head @ 0x612000000202 {state: u  size:    64}
  [  1] head @ 0x6120000001c4 {state: u  size:    22}
  [  2] head @ 0x612000000100 {state: u  size:   156}
  [  3] head @ 0x6120000000a8 {state: u  size:    48}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      a
  size:       128 (total: 0xa8)
  prev:       0x610000000018
  next:       0x61200000026a
  user:       0x612000000020
  foot:       0x6120000000a0
  foot-&gt;size: 128
[  1] @ 0x6120000000a8
  state:      u
  size:       48 (total: 0x58)
  prev:       0x612000000100
  next:       0x610000000098
  user:       0x6120000000c8
  foot:       0x6120000000f8
  foot-&gt;size: 48
[  2] @ 0x612000000100
  state:      u
  size:       156 (total: 0xc4)
  prev:       0x6120000001c4
  next:       0x6120000000a8
  user:       0x612000000120
  foot:       0x6120000001bc
  foot-&gt;size: 156
[  3] @ 0x6120000001c4
  state:      u
  size:       22 (total: 0x3e)
  prev:       0x612000000202
  next:       0x612000000100
  user:       0x6120000001e4
  foot:       0x6120000001fa
  foot-&gt;size: 22
[  4] @ 0x612000000202
  state:      u
  size:       64 (total: 0x68)
  prev:       0x610000000078
  next:       0x6120000001c4
  user:       0x612000000222
  foot:       0x612000000262
  foot-&gt;size: 64
[  5] @ 0x61200000026a
  state:      a
  size:       3438 (total: 0xd96)
  prev:       0x612000000000
  next:       0x610000000038
  user:       0x61200000028a
  foot:       0x612000000ff8
  foot-&gt;size: 3438

FREE 3
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000001000
total_bytes: 4096
AVAILABLE LIST: {length:   3  bytes:  3842}
  [  0] head @ 0x612000000100 {state: a  size:   156}
  [  1] head @ 0x612000000000 {state: a  size:   128}
  [  2] head @ 0x61200000026a {state: a  size:  3438}
USED LIST: {length:   3  bytes:   254}
  [  0] head @ 0x612000000202 {state: u  size:    64}
  [  1] head @ 0x6120000001c4 {state: u  size:    22}
  [  2] head @ 0x6120000000a8 {state: u  size:    48}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      a
  size:       128 (total: 0xa8)
  prev:       0x612000000100
  next:       0x61200000026a
  user:       0x612000000020
  foot:       0x6120000000a0
  foot-&gt;size: 128
[  1] @ 0x6120000000a8
  state:      u
  size:       48 (total: 0x58)
  prev:       0x6120000001c4
  next:       0x610000000098
  user:       0x6120000000c8
  foot:       0x6120000000f8
  foot-&gt;size: 48
[  2] @ 0x612000000100
  state:      a
  size:       156 (total: 0xc4)
  prev:       0x610000000018
  next:       0x612000000000
  user:       0x612000000120
  foot:       0x6120000001bc
  foot-&gt;size: 156
[  3] @ 0x6120000001c4
  state:      u
  size:       22 (total: 0x3e)
  prev:       0x612000000202
  next:       0x6120000000a8
  user:       0x6120000001e4
  foot:       0x6120000001fa
  foot-&gt;size: 22
[  4] @ 0x612000000202
  state:      u
  size:       64 (total: 0x68)
  prev:       0x610000000078
  next:       0x6120000001c4
  user:       0x612000000222
  foot:       0x612000000262
  foot-&gt;size: 64
[  5] @ 0x61200000026a
  state:      a
  size:       3438 (total: 0xd96)
  prev:       0x612000000000
  next:       0x610000000038
  user:       0x61200000028a
  foot:       0x612000000ff8
  foot-&gt;size: 3438

ALLOC 3,1 AGAIN
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000001000
total_bytes: 4096
AVAILABLE LIST: {length:   3  bytes:  3530}
  [  0] head @ 0x61200000035a {state: a  size:  3198}
  [  1] head @ 0x612000000148 {state: a  size:    84}
  [  2] head @ 0x612000000000 {state: a  size:   128}
USED LIST: {length:   5  bytes:   566}
  [  0] head @ 0x61200000026a {state: u  size:   200}
  [  1] head @ 0x612000000100 {state: u  size:    32}
  [  2] head @ 0x612000000202 {state: u  size:    64}
  [  3] head @ 0x6120000001c4 {state: u  size:    22}
  [  4] head @ 0x6120000000a8 {state: u  size:    48}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      a
  size:       128 (total: 0xa8)
  prev:       0x612000000148
  next:       0x610000000038
  user:       0x612000000020
  foot:       0x6120000000a0
  foot-&gt;size: 128
[  1] @ 0x6120000000a8
  state:      u
  size:       48 (total: 0x58)
  prev:       0x6120000001c4
  next:       0x610000000098
  user:       0x6120000000c8
  foot:       0x6120000000f8
  foot-&gt;size: 48
[  2] @ 0x612000000100
  state:      u
  size:       32 (total: 0x48)
  prev:       0x61200000026a
  next:       0x612000000202
  user:       0x612000000120
  foot:       0x612000000140
  foot-&gt;size: 32
[  3] @ 0x612000000148
  state:      a
  size:       84 (total: 0x7c)
  prev:       0x61200000035a
  next:       0x612000000000
  user:       0x612000000168
  foot:       0x6120000001bc
  foot-&gt;size: 84
[  4] @ 0x6120000001c4
  state:      u
  size:       22 (total: 0x3e)
  prev:       0x612000000202
  next:       0x6120000000a8
  user:       0x6120000001e4
  foot:       0x6120000001fa
  foot-&gt;size: 22
[  5] @ 0x612000000202
  state:      u
  size:       64 (total: 0x68)
  prev:       0x612000000100
  next:       0x6120000001c4
  user:       0x612000000222
  foot:       0x612000000262
  foot-&gt;size: 64
[  6] @ 0x61200000026a
  state:      u
  size:       200 (total: 0xf0)
  prev:       0x610000000078
  next:       0x612000000100
  user:       0x61200000028a
  foot:       0x612000000352
  foot-&gt;size: 200
[  7] @ 0x61200000035a
  state:      a
  size:       3198 (total: 0xca6)
  prev:       0x610000000018
  next:       0x612000000148
  user:       0x61200000037a
  foot:       0x612000000ff8
  foot-&gt;size: 3198

POINTERS
p1: 0x61200000028a
p3: 0x612000000120
p5: 0x612000000222
p4: 0x6120000001e4
p2: 0x6120000000c8

FREE'D 1
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000001000
total_bytes: 4096
AVAILABLE LIST: {length:   3  bytes:  3770}
  [  0] head @ 0x61200000026a {state: a  size:  3438}
  [  1] head @ 0x612000000148 {state: a  size:    84}
  [  2] head @ 0x612000000000 {state: a  size:   128}
USED LIST: {length:   4  bytes:   326}
  [  0] head @ 0x612000000100 {state: u  size:    32}
  [  1] head @ 0x612000000202 {state: u  size:    64}
  [  2] head @ 0x6120000001c4 {state: u  size:    22}
  [  3] head @ 0x6120000000a8 {state: u  size:    48}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      a
  size:       128 (total: 0xa8)
  prev:       0x612000000148
  next:       0x610000000038
  user:       0x612000000020
  foot:       0x6120000000a0
  foot-&gt;size: 128
[  1] @ 0x6120000000a8
  state:      u
  size:       48 (total: 0x58)
  prev:       0x6120000001c4
  next:       0x610000000098
  user:       0x6120000000c8
  foot:       0x6120000000f8
  foot-&gt;size: 48
[  2] @ 0x612000000100
  state:      u
  size:       32 (total: 0x48)
  prev:       0x610000000078
  next:       0x612000000202
  user:       0x612000000120
  foot:       0x612000000140
  foot-&gt;size: 32
[  3] @ 0x612000000148
  state:      a
  size:       84 (total: 0x7c)
  prev:       0x61200000026a
  next:       0x612000000000
  user:       0x612000000168
  foot:       0x6120000001bc
  foot-&gt;size: 84
[  4] @ 0x6120000001c4
  state:      u
  size:       22 (total: 0x3e)
  prev:       0x612000000202
  next:       0x6120000000a8
  user:       0x6120000001e4
  foot:       0x6120000001fa
  foot-&gt;size: 22
[  5] @ 0x612000000202
  state:      u
  size:       64 (total: 0x68)
  prev:       0x612000000100
  next:       0x6120000001c4
  user:       0x612000000222
  foot:       0x612000000262
  foot-&gt;size: 64
[  6] @ 0x61200000026a
  state:      a
  size:       3438 (total: 0xd96)
  prev:       0x610000000018
  next:       0x612000000148
  user:       0x61200000028a
  foot:       0x612000000ff8
  foot-&gt;size: 3438

FREE'D 2
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000001000
total_bytes: 4096
AVAILABLE LIST: {length:   3  bytes:  3858}
  [  0] head @ 0x612000000000 {state: a  size:   216}
  [  1] head @ 0x61200000026a {state: a  size:  3438}
  [  2] head @ 0x612000000148 {state: a  size:    84}
USED LIST: {length:   3  bytes:   238}
  [  0] head @ 0x612000000100 {state: u  size:    32}
  [  1] head @ 0x612000000202 {state: u  size:    64}
  [  2] head @ 0x6120000001c4 {state: u  size:    22}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      a
  size:       216 (total: 0x100)
  prev:       0x610000000018
  next:       0x61200000026a
  user:       0x612000000020
  foot:       0x6120000000f8
  foot-&gt;size: 216
[  1] @ 0x612000000100
  state:      u
  size:       32 (total: 0x48)
  prev:       0x610000000078
  next:       0x612000000202
  user:       0x612000000120
  foot:       0x612000000140
  foot-&gt;size: 32
[  2] @ 0x612000000148
  state:      a
  size:       84 (total: 0x7c)
  prev:       0x61200000026a
  next:       0x610000000038
  user:       0x612000000168
  foot:       0x6120000001bc
  foot-&gt;size: 84
[  3] @ 0x6120000001c4
  state:      u
  size:       22 (total: 0x3e)
  prev:       0x612000000202
  next:       0x610000000098
  user:       0x6120000001e4
  foot:       0x6120000001fa
  foot-&gt;size: 22
[  4] @ 0x612000000202
  state:      u
  size:       64 (total: 0x68)
  prev:       0x612000000100
  next:       0x6120000001c4
  user:       0x612000000222
  foot:       0x612000000262
  foot-&gt;size: 64
[  5] @ 0x61200000026a
  state:      a
  size:       3438 (total: 0xd96)
  prev:       0x612000000000
  next:       0x612000000148
  user:       0x61200000028a
  foot:       0x612000000ff8
  foot-&gt;size: 3438

P2 FAILS
POINTERS
p1: 0x61200000028a
p3: 0x612000000120
p5: 0x612000000222
p4: 0x6120000001e4
p2: (nil)
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000001000
total_bytes: 4096
AVAILABLE LIST: {length:   2  bytes:   380}
  [  0] head @ 0x612000000000 {state: a  size:   216}
  [  1] head @ 0x612000000148 {state: a  size:    84}
USED LIST: {length:   4  bytes:  3716}
  [  0] head @ 0x61200000026a {state: u  size:  3438}
  [  1] head @ 0x612000000100 {state: u  size:    32}
  [  2] head @ 0x612000000202 {state: u  size:    64}
  [  3] head @ 0x6120000001c4 {state: u  size:    22}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      a
  size:       216 (total: 0x100)
  prev:       0x610000000018
  next:       0x612000000148
  user:       0x612000000020
  foot:       0x6120000000f8
  foot-&gt;size: 216
[  1] @ 0x612000000100
  state:      u
  size:       32 (total: 0x48)
  prev:       0x61200000026a
  next:       0x612000000202
  user:       0x612000000120
  foot:       0x612000000140
  foot-&gt;size: 32
[  2] @ 0x612000000148
  state:      a
  size:       84 (total: 0x7c)
  prev:       0x612000000000
  next:       0x610000000038
  user:       0x612000000168
  foot:       0x6120000001bc
  foot-&gt;size: 84
[  3] @ 0x6120000001c4
  state:      u
  size:       22 (total: 0x3e)
  prev:       0x612000000202
  next:       0x610000000098
  user:       0x6120000001e4
  foot:       0x6120000001fa
  foot-&gt;size: 22
[  4] @ 0x612000000202
  state:      u
  size:       64 (total: 0x68)
  prev:       0x612000000100
  next:       0x6120000001c4
  user:       0x612000000222
  foot:       0x612000000262
  foot-&gt;size: 64
[  5] @ 0x61200000026a
  state:      u
  size:       3438 (total: 0xd96)
  prev:       0x610000000078
  next:       0x612000000100
  user:       0x61200000028a
  foot:       0x612000000ff8
  foot-&gt;size: 3438

APPENDED PAGES
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000004000
total_bytes: 16384
AVAILABLE LIST: {length:   3  bytes: 12668}
  [  0] head @ 0x612000001000 {state: a  size: 12248}
  [  1] head @ 0x612000000000 {state: a  size:   216}
  [  2] head @ 0x612000000148 {state: a  size:    84}
USED LIST: {length:   4  bytes:  3716}
  [  0] head @ 0x61200000026a {state: u  size:  3438}
  [  1] head @ 0x612000000100 {state: u  size:    32}
  [  2] head @ 0x612000000202 {state: u  size:    64}
  [  3] head @ 0x6120000001c4 {state: u  size:    22}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      a
  size:       216 (total: 0x100)
  prev:       0x612000001000
  next:       0x612000000148
  user:       0x612000000020
  foot:       0x6120000000f8
  foot-&gt;size: 216
[  1] @ 0x612000000100
  state:      u
  size:       32 (total: 0x48)
  prev:       0x61200000026a
  next:       0x612000000202
  user:       0x612000000120
  foot:       0x612000000140
  foot-&gt;size: 32
[  2] @ 0x612000000148
  state:      a
  size:       84 (total: 0x7c)
  prev:       0x612000000000
  next:       0x610000000038
  user:       0x612000000168
  foot:       0x6120000001bc
  foot-&gt;size: 84
[  3] @ 0x6120000001c4
  state:      u
  size:       22 (total: 0x3e)
  prev:       0x612000000202
  next:       0x610000000098
  user:       0x6120000001e4
  foot:       0x6120000001fa
  foot-&gt;size: 22
[  4] @ 0x612000000202
  state:      u
  size:       64 (total: 0x68)
  prev:       0x612000000100
  next:       0x6120000001c4
  user:       0x612000000222
  foot:       0x612000000262
  foot-&gt;size: 64
[  5] @ 0x61200000026a
  state:      u
  size:       3438 (total: 0xd96)
  prev:       0x610000000078
  next:       0x612000000100
  user:       0x61200000028a
  foot:       0x612000000ff8
  foot-&gt;size: 3438
[  6] @ 0x612000001000
  state:      a
  size:       12248 (total: 0x3000)
  prev:       0x610000000018
  next:       0x612000000000
  user:       0x612000001020
  foot:       0x612000003ff8
  foot-&gt;size: 12248

P2 SUCCEEDS
POINTERS
p1: 0x61200000028a
p3: 0x612000000120
p5: 0x612000000222
p4: 0x6120000001e4
p2: 0x612000001020
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000004000
total_bytes: 16384
AVAILABLE LIST: {length:   3  bytes: 11604}
  [  0] head @ 0x612000001428 {state: a  size: 11184}
  [  1] head @ 0x612000000000 {state: a  size:   216}
  [  2] head @ 0x612000000148 {state: a  size:    84}
USED LIST: {length:   5  bytes:  4780}
  [  0] head @ 0x612000001000 {state: u  size:  1024}
  [  1] head @ 0x61200000026a {state: u  size:  3438}
  [  2] head @ 0x612000000100 {state: u  size:    32}
  [  3] head @ 0x612000000202 {state: u  size:    64}
  [  4] head @ 0x6120000001c4 {state: u  size:    22}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      a
  size:       216 (total: 0x100)
  prev:       0x612000001428
  next:       0x612000000148
  user:       0x612000000020
  foot:       0x6120000000f8
  foot-&gt;size: 216
[  1] @ 0x612000000100
  state:      u
  size:       32 (total: 0x48)
  prev:       0x61200000026a
  next:       0x612000000202
  user:       0x612000000120
  foot:       0x612000000140
  foot-&gt;size: 32
[  2] @ 0x612000000148
  state:      a
  size:       84 (total: 0x7c)
  prev:       0x612000000000
  next:       0x610000000038
  user:       0x612000000168
  foot:       0x6120000001bc
  foot-&gt;size: 84
[  3] @ 0x6120000001c4
  state:      u
  size:       22 (total: 0x3e)
  prev:       0x612000000202
  next:       0x610000000098
  user:       0x6120000001e4
  foot:       0x6120000001fa
  foot-&gt;size: 22
[  4] @ 0x612000000202
  state:      u
  size:       64 (total: 0x68)
  prev:       0x612000000100
  next:       0x6120000001c4
  user:       0x612000000222
  foot:       0x612000000262
  foot-&gt;size: 64
[  5] @ 0x61200000026a
  state:      u
  size:       3438 (total: 0xd96)
  prev:       0x612000001000
  next:       0x612000000100
  user:       0x61200000028a
  foot:       0x612000000ff8
  foot-&gt;size: 3438
[  6] @ 0x612000001000
  state:      u
  size:       1024 (total: 0x428)
  prev:       0x610000000078
  next:       0x61200000026a
  user:       0x612000001020
  foot:       0x612000001420
  foot-&gt;size: 1024
[  7] @ 0x612000001428
  state:      a
  size:       11184 (total: 0x2bd8)
  prev:       0x610000000018
  next:       0x612000000000
  user:       0x612000001448
  foot:       0x612000003ff8
  foot-&gt;size: 11184

FREE'D 1-5
HEAP STATS (overhead per node: 40)
heap_start:  0x612000000000
heap_end:    0x612000004000
total_bytes: 16384
AVAILABLE LIST: {length:   1  bytes: 16384}
  [  0] head @ 0x612000000000 {state: a  size: 16344}
USED LIST: {length:   0  bytes:     0}
HEAP BLOCKS:
[  0] @ 0x612000000000
  state:      a
  size:       16344 (total: 0x4000)
  prev:       0x610000000018
  next:       0x610000000038
  user:       0x612000000020
  foot:       0x612000003ff8
  foot-&gt;size: 16344
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3db8d1d" class="outline-3 grading50">
<h3 id="org3db8d1d"><span class="section-number-3">3.12</span> <a id="org9d2d916"></a> Grading Criteria for El Malloc&#xa0;&#xa0;&#xa0;<span class="tag"><span class="grading50">grading50</span></span></h3>
<div class="outline-text-3" id="text-3-12">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-left">Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left"><b>Automated Tests</b></td>
</tr>

<tr>
<td class="org-right">15</td>
<td class="org-left"><code>make test-prob2</code> runs 10 tests for correctness with Valgrind enabled</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left"><code>make test-prob2 tesnum=5</code> to run individual tests</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left"><b>Manual Inspection</b></td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><code>el_get_header()</code> and <code>el_block_below()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of provided macros for pointer arithmetic</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Correct use of <code>sizeof()</code> operator to account for sizes</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left"><code>el_block_below()</code> checks for beginning of heap and returns NULL</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><code>el_add_block_front()</code> and <code>el_remove_block()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Sensible use of pointers prev/next to link/unlink nodes <b>efficiently; no looping used</b></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Correct updating of list length and bytes</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Accounts for <code>EL_BLOCK_OVERHEAD</code> when updating bytes</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><code>el_split_block()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of <code>el_get_foot()</code> to obtain footers for updating size</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Checks to determine if block is large enough to be split; returns NULL if not</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear evidence of placing a new header and footer for new block when splitting</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Accounting for overhead <code>EL_BLOCK_OVERHEAD</code> when calculating new size</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><code>el_malloc()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of <code>el_find_first_avail()</code> to locate a node to split</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of <code>el_split_block()</code> to split block into two</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear state change of split blocks to Used and Available</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear movement of lower split blocks to front of Used List</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear movement of upper split blocks to front of Available lists</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of pointer arithmetic macros to computer user address</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><code>el_merge_block_with_above()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left"><code>NULL</code> checks for argument and block above which result in no changes</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear checks of whether both blocks are <code>EL_AVAILABLE</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of <code>el_block_above()</code> to find block above</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear updates to size of lower block and higher foot</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Movement of blocks out of available list and merged block to front</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><code>el_free()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Error checking that block is <code>EL_USED</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Movement of block from used to available list</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Attempts to merge block with blocks above and below it</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><code>el_append_pages_to_heap()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Makes use of <code>mmap()</code> to map in additional pages of virtual memory</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Checks <code>mmap()</code> for failures and prints appropriate error messages</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Maps new heap space to current heap end to create a contiguous heap</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Creates new available block for new space and attempts to merge with existing available blocks</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">50</td>
<td class="org-left">Problem Total</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>



<div id="outline-container-org878cdeb" class="outline-2">
<h2 id="org878cdeb"><span class="section-number-2">4</span> Project Submission</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgad5801b" class="outline-3">
<h3 id="orgad5801b"><span class="section-number-3">4.1</span> <a id="orgfb1b2e2"></a> Submit to Gradescope</h3>
<div class="outline-text-3" id="text-4-1">
<ol class="org-ol">
<li><p>
In a terminal, change to your project code directory and type
<b>make zip</b> which will create a zip file of your code. A session
should look like this:
</p>
<div class="org-src-container">
<pre class="src src-sh">   &gt; cd Desktop/2021/p5-code      # location of project code

   &gt; ls 
   Makefile    el_malloc.c    test-input/
   ...

   &gt; make zip                     # create a zip file using Makefile target
   rm -f p5-code.zip
   cd .. &amp;&amp; zip "p5-code/p5-code.zip" -r "p5-code"
     adding: p5-code/ (stored 0%)
     adding: p5-code/el_malloc.c (deflated 72%)
     adding: p5-code/Makefile (deflated 59%)
     ...
   Zip created in p5-code.zip

   &gt; ls p5-code.zip
   p5-code.zip
</pre>
</div></li>
<li>Log into <a href="https://www.gradescope.com/">Gradescope</a> and locate and click Project 5' which will
open up submission</li>
<li>Click on the 'Drag and Drop' text which will open a file selection
dialog; locate and choose your <code>p5-code.zip</code> file</li>
<li>This will show the contents of the Zip file and should include your
C source files along with testing files and directories.</li>
<li>Click 'Upload' which will show progress uploading files.  It may
take a few seconds before this dialog closes to indicate that the
upload is successful. Note: there is a limit of 256 files per
upload; normal submissions are not likely to have problems with
this but you may want to make sure that nothing has gone wrong such
as infinite loops creating many files or incredibly large files.</li>
<li>Once files have successfully uploaded, the Autograder will begin
running the command line tests and recording results.  These are
the same tests that are run via <code>make test</code>.</li>
<li>When the tests have completed, results will be displayed
summarizing scores along with output for each batch of tests.</li>
<li>Refer to the <a href="https://www-users.cs.umn.edu/~kauffman/2021/p1.html">Submission instructions for P1</a> for details and
pictures.</li>
</ol>
</div>
</div>

<div id="outline-container-org32499a3" class="outline-3">
<h3 id="org32499a3"><span class="section-number-3">4.2</span> Late Policies</h3>
<div class="outline-text-3" id="text-4-2">
<p>
You may wish to review the policy on late project submission which
will cost you late tokens to submit late or credit if you run out of
tokens. <b>No projects will be accepted more than 48 hours after the
deadline.</b>
</p>

<p>
<a href="https://www-users.cs.umn.edu/~kauffman/2021/syllabus.html">https://www-users.cs.umn.edu/~kauffman/2021/syllabus.html</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr/> <i> Author: Chris Kauffman (<a href="mailto:kauffman@umn.edu">kauffman@umn.edu</a>) <br/> Date: 2022-04-25 Mon 21:40 <br/> </i>
</div>
</body>
</html>
