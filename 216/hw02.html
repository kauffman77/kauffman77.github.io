<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-09-07 Sun 13:05 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CMSC216 HW02: C Memory Management</title>
<meta name="author" content="Chris Kauffman" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<meta name="viewport" content="width=device-width, maximum-scale=1, minimum-scale=1" />
<style type="text/css">
@media screen {
:root {
--heading-bg-color:#e21833;
--heading-fg-color:#ffd200;
}
html {
font-family: serif;
text-align: justify;
}
pre.src, pre.example {
overflow-x: scroll;
}
/* Merge subtitle area with title area */
.subtitle {
text-align: center;
margin-top: -2em;
padding-top: 1em;
padding-bottom: 0.1em;
}
.title, .subtitle {
color: var(--heading-fg-color);
background-color: var(--heading-bg-color);
}
/* Section borders, left section header style */
div.outline-2, #table-of-contents {
background-color: rgb(250,250,250);
border: 0.75em solid var(--heading-bg-color);
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
}
div.outline-2 > h2, #table-of-contents > h2 {
background-color: var(--heading-bg-color);
color: var(--heading-fg-color);
font-variant: small-caps;
padding: 0em 0em 0em .5em; /* top right bottom left */
margin: 0em -.5em 0em -.75em; /* top right bottom left */
text-align: left;
}
blockquote {
font-style: italic;
}
td, th {
padding-top: 2px;
padding-bottom: 2px;
}
body {
background-color: #EEE;
}
pre {
}
#content, #preamble, #postamble {
margin-left:300px;
max-width: 100%;
}
.tag {
background-color: inherit; font-family: inherit;
padding: inherit; font-size: 80%; font-weight: inherit;
text-transform: uppercase;
}

.figure p { text-align: inherit; }
figure-number { font-style: italic; }
#table-of-contents {
text-align: left;
position: fixed;
left: 0;
margin: 0 auto;
padding: 0;
width: 300px;
top: 0;
height: 100%;
border: 0;
display: block;
}
#text-table-of-contents {
overflow-y: scroll;
height: 100%;
}
#text-table-of-contents ul {
padding-left: 1em;
margin-left: 0.5em;
}
#table-of-contents > h2 {
padding: 0.1em;
margin: 0;
}
/* adjustments for small screen, toc at top only */
@media (max-width: 800px) { /* landscape for iphone */
html {
-webkit-text-size-adjust: none;  /* prevent scaling of text on mobile */
}
body {
background-color: #EEE;
width:100%;
margin:0 auto;
}
#content, #preamble, #postamble {
margin-left:0;
}
#table-of-contents {
position: static;
left: inherit;
width:inherit;
height: auto;
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
border: 0.75em solid #006633;
}
div.outline-2, #table-of-contents {
background-color: rgb(250,250,250);
border: 0.75em solid var(--heading-bg-color);
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
}
div.outline-2 > h2, #table-of-contents > h2 {
background-color: var(--heading-bg-color);
color: var(--heading-fg-color);
font-variant: small-caps;
padding: 0em 0em 0em .5em; /* top right bottom left */
margin: 0em -.5em 0em -.75em; /* top right bottom left */
text-align: left;
}
#text-table-of-contents {
overflow-y: visible;
height: inherit;
}
#text-table-of-contents ul {
padding-left: 1em;
margin-left: 0.5em;
}
}
.linenr { font-size: xx-small; }
}

@media print {
html {
font-family: serif;
font-size: 10pt;
text-align: justify;
.linenr { font-size: xx-small; }
}
}
</style>
</head>
<body>
<div id="preamble" class="status">
<i>Last Updated: 2025-09-07 Sun 13:05</i>
</div>
<div id="content" class="content">
<h1 class="title">CMSC216 HW02: C Memory Management</h1>
<ul class="org-ul">
<li><b>Due: 11:59pm Sun 14-Sep-2025</b> on <a href="https://www.gradescope.com/">Gradescope</a></li>
<li><i>Approximately 0.83% of total grade</i></li>
</ul>
<div id="outline-container-orgc0db7fe" class="outline-4">
<h4 id="orgc0db7fe">CODE DISTRIBUTION: <a href="hw02-code.zip">hw02-code.zip</a></h4>
</div>

<div id="outline-container-org0e611d3" class="outline-4">
<h4 id="org0e611d3">CHANGELOG: Empty</h4>
<div class="outline-text-4" id="text-org0e611d3">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org99ad6a5">1. Rationale</a>
<ul>
<li><a href="#org2f4e873">Associated Reading / Preparation</a></li>
<li><a href="#org4809792">Grading Policy</a></li>
</ul>
</li>
<li><a href="#org494c35c">2. Codepack</a></li>
<li><a href="#org42fe275">3. What to Understand</a></li>
<li><a href="#org60b4628">4. Questions</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org99ad6a5" class="outline-2">
<h2 id="org99ad6a5"><span class="section-number-2">1</span> Rationale</h2>
<div class="outline-text-2" id="text-1">
<p>
This HW covers the basics of memory layout, C structs,
allocation/deallocation, string processing, and their use in some
basic programs. Problems provide practice at creating memory diagrams
and study the same Linked List program that is the subject of other
course activities to give more experience with it.
</p>
</div>
<div id="outline-container-org2f4e873" class="outline-3">
<h3 id="org2f4e873">Associated Reading / Preparation</h3>
<div class="outline-text-3" id="text-org2f4e873">
<p>
From any good C resource review:
</p>
<ul class="org-ul">
<li>Basic I/O using <code>fopen(), fscanf(), fread(), fwrite()</code></li>
<li><code>struct</code> declarations</li>
<li>String processing / comparison</li>
<li><code>malloc()</code> and <code>free()</code></li>
</ul>
<p>
From previous experience with data structures, review how Singly
Linked Lists are constructed.
</p>
</div>
</div>
<div id="outline-container-org4809792" class="outline-3">
<h3 id="org4809792">Grading Policy</h3>
<div class="outline-text-3" id="text-org4809792">
<p>
Credit for this HW is earned by taking the associated HW Quiz which is
linked under <code>Gradescope</code>.  The quiz will ask similar questions as
those that are present in the <code>QUESTIONS.txt</code> file and those that
complete all answers in <code>QUESTIONS.txt</code> should have no trouble with
the quiz.
</p>

<p>
Homework and Quizzes are open resource/open collaboration. You must
submit your own work but you may freely discuss HW topics with other
members of the class.
</p>

<p>
See the <a href="https://www.cs.umd.edu/~profk/216/syllabus.html">full policies in the course syllabus</a>.
</p>
</div>
</div>
</div>
<div id="outline-container-org494c35c" class="outline-2">
<h2 id="org494c35c"><span class="section-number-2">2</span> Codepack</h2>
<div class="outline-text-2" id="text-2">
<p>
The codepack for the HW contains the following files:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">File</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>QUESTIONS.txt</code></td>
<td class="org-left">Questions to answer</td>
</tr>

<tr>
<td class="org-left"><code>diagram.c</code></td>
<td class="org-left">C file for Problem 1</td>
</tr>

<tr>
<td class="org-left"><code>list_main.c</code></td>
<td class="org-left">C file for Problem 3/4/5</td>
</tr>

<tr>
<td class="org-left"><code>list_funcs.c</code></td>
<td class="org-left">C file for Problem 3/4/5</td>
</tr>

<tr>
<td class="org-left"><code>list.h</code></td>
<td class="org-left">C file for Problem 3/4/5</td>
</tr>

<tr>
<td class="org-left"><code>commands.txt</code></td>
<td class="org-left">Command script for <code>list_main</code>, Problem 3/4/5</td>
</tr>

<tr>
<td class="org-left"><code>Makefile</code></td>
<td class="org-left">Builds <code>list_main</code> application via <code>make</code></td>
</tr>

<tr>
<td class="org-left"><code>testy</code></td>
<td class="org-left">Testing script</td>
</tr>

<tr>
<td class="org-left"><code>test_list_main.org</code></td>
<td class="org-left">Tests for <code>list_main</code>, run via <code>make test</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org42fe275" class="outline-2">
<h2 id="org42fe275"><span class="section-number-2">3</span> What to Understand</h2>
<div class="outline-text-2" id="text-3">
<p>
Ensure that you understand
</p>
<ul class="org-ul">
<li>Basics of memory layout on the stack</li>
<li>Declaration of structs</li>
<li>Basics of strings in C</li>
<li><code>malloc()</code> and <code>free()</code> when using dynamic structures</li>
<li>Use of Valgrind to begin diagnosing memory errors</li>
<li>Basic command loops in which a user enters commands which manipulate
internal program data</li>
</ul>
</div>
</div>
<div id="outline-container-org60b4628" class="outline-2">
<h2 id="org60b4628"><span class="section-number-2">4</span> Questions</h2>
<div class="outline-text-2" id="text-4">
<p>
Analyze the files in the provided codepack and answer the questions
given in <code>QUESTIONS.txt</code>.
</p>

<div class="org-src-container">
<pre class="src src-text">                            ________________

                             HW02 QUESTIONS
                            ________________


Write your answers to the questions below directly in this text file to
prepare for the associated quiz. Credit for the HW is earned by
completing the associated online quiz on Gradescope.


PROBLEM 1: Memory in diagram.c
==============================

  Lecture has introduced the basic memory model that C uses where
  variables are placed in memory at runtime at locations chosen by the
  compiler.  The space required for variables is dictated by their
  type. This problem gives some practice at working with variables in
  memory and pointers.

  For each of the C blocks below, give a memory diagram of the block
  indicating memory locations and contents of cells. These blocks appear
  in the file `diagram.c' which you can modify to print results if you
  want to verify your answers.

  MAKE SURE to accurately express the standard sizes for each of the
  kinds of variables ON A 64-BIT MACHINE in your diagrams by placing
  them at appropriate memory addresses that are tightly packed. A
  reminder: on 64-bit machines, all pointers are 64 bits / 8 bytes.

  The specific order of variables appear in memory will be chosen by the
  compiler. In graded problems, so long as answers are internally
  consistent, they will receive full credit; that means allocating
  enough space for variables in whatever order is chosen and ensuring
  that pointer point at the location of the indicated variables.


A
~

  ,----
  |   // BLOCK A
  |   int a = 5;
  |   int b = 7;
  |   double x = 4.5;
  |   int *ip = &amp;a;
  |   ip = &amp;b;
  |   int c = *ip;
  |   *ip = 19;
  |   // DRAW MEMORY HERE 
  `----

  ,----
  | | ADDR  | SYMBOL | VAL |
  | |-------+--------+-----|
  | | #1048 | a      |     |
  | | #1044 | b      |     |
  | |       |        |     |
  | |       |        |     |
  | |       |        |     |
  `----


B
~

  ,----
  |   // BLOCK B
  |   int arr[4] = {12, 14, 16, 18};
  |   int *arp = arr;
  |   int brr = 11;
  |   arr[1] = 23;
  |   arp[3] = 29;
  |   arp = &amp;arr[2];
  |   *arp = brr;
  |   // DRAW MEMORY HERE 
  `----

  ,----
  | | ADDR  | SYMBOL | VAL |
  | |-------+--------+-----|
  | | #2024 | arr[3] |  18 |
  | | #2020 | arr[2] |  16 |
  | |       |        |     |
  | |       |        |     |
  | |       |        |     |
  | |       |        |     |
  `----


C
~

  ,----
  |   // BLOCK C
  |   char str[8] = "hello";
  |   str[5] = 'w';
  |   char *cp = str + 6;
  |   *cp = '\0';
  |   str[0] = 'y';
  |   // DRAW MEMORY HERE 
  `----

  ,----
  | 
  | | ADDR  | SYMBOL | VAL |
  | |-------+--------+-----|
  | | #3107 | str[7] | ?   |
  | | #3106 | str[6] | ?   |
  | | #3105 | str[5] | \0  |
  | | #3104 | str[4] | o   |
  | | #3103 | str[3] | l   |
  | | #3102 | str[2] | l   |
  | | #3101 | str[1] | e   |
  | | #3100 | str[0] | h   |
  | | #3092 |     cp | ?   |
  | 
  `----


PROBLEM 2: Structs, Dots, and Arrows
====================================

  Lecture will soon discuss structs, a way to aggregate data of
  different types into a single datum. They are akin to objects in other
  programming environments but do not have methods or and public/private
  attributes for fields. There are a half dozen syntactic variants that
  declare structs but we will favor these two.
  ,----
  | typedef struct {                // most common syntax; declares new type mytype_t
  |   int an_int_field;
  |   double a_double_field;
  |   char *a_char_ptr_field;
  | } mytype_t;
  | 
  | typedef struct othertype {      // variant used when a pointer to the type being
  |   int first_field;              // defined is required such as in linked lists
  |   char second_field;
  |   struct othertype *pointer_field;
  | } othertype_t;  
  `----

  The use of `_t' at the end of struct names is an convention to
  indicate that they are a type; it is not a strict rule and some
  historical types do not end with an `_t' but in all course examples
  defined types will follow it.

  With these set up, one can declare data of the type of the struct and
  access fields of the struct using the dot notation. An example appears
  in the `struct_demo.c' file.

  ,----
  | int main(int argc, char *argv[]){
  |   mytype_t mine1;               // first struct
  |   mine1.an_int_field = 5;
  |   mine1.a_double_field = 11.6;
  |   char mychar = 'h';
  |   mine1.a_char_ptr_field = &amp;mychar;
  | 
  |   mytype_t mine2;               // second struct
  |   mine2.an_int_field = 222;
  |   mine2.a_double_field = 333.4;
  |   mine2.a_char_ptr_field = &amp;mychar; // points to same place as first struct does
  | 
  |   // print out the fields of the two structs
  |   printf("mine1: %d %f %p\n",
  |          mine1.an_int_field, mine1.a_double_field, mine1.a_char_ptr_field);
  |   printf("mine2: %d %f %p\n",
  |          mine2.an_int_field, mine2.a_double_field, mine2.a_char_ptr_field);
  | 
  |   return 0;
  | }
  `----


A Basic Struct Definition and Use
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  In the file `struct_define.c' below with a simple struct definition
  and use to print the fields of a struct.


B Memory Layout of Structs
~~~~~~~~~~~~~~~~~~~~~~~~~~

  Draw a memory diagram of the stack frame for `main()' in
  `struct_define.c' at the `return' line to show how the structs are
  likely to lay out in memory. Keep in mind that the compiler will
  respect the order of struct fields specified in memory with the first
  struct field declared at the earliest point in memory.

  Below is a table to help you get started.
  ,----
  | | FRAME         | Address | Symbol              |     Value |
  | |---------------+---------+---------------------+-----------|
  | | main()        |         | grumpycat.is_grumpy |           |
  | | before return |         |                     |           |
  | |               |         |                     |           |
  | |               |         |                     |           |
  | |               | #4040   | grumpycat.?         |           |
  | |               | #4039   |                     |       'N' |
  | |               | #4038   | nyancat.is_active   |       'Y' |
  | |               |         |                     |        14 |
  | |               | #4028   |                     |       0.1 |
  | |               | #4024   | nyancat.views       | 205000000 |
  `----


C Dots vs Arrows
~~~~~~~~~~~~~~~~

  The "dot" operation in C is for "field access" and is appropriate to
  use when a variable is an actual struct. C allows for pointers to data
  and when structs are pointed at, accessing their data requires first a
  dereference then a field access.  This is done via the "arrow"
  operator "-&gt;" as in `ptrstrct-&gt;fieldname'.

  In summary
  - Use . when an actual (non-pointer) struct is in use
  - Use -&gt; when a pointer to a struct is in use

  A common use of struct pointers is when structs are passed via their
  addresses (as pointers) to a function that operates on the struct. An
  example of this is given in `struct_pointer_demo.c' which has a
  function which halves a field. Study this example which shows how to
  pass a pointer to a struct into the function and uses the Arrow syntax
  to modify the struct.

  #include &lt;stdio.h&gt;

  typedef struct { // most common syntax; declares new type mytype_t int
    an_int_field; double a_double_field; char *a_char_ptr_field; }
    mytype_t;

  void mytype_halve_double(mytype_t *mine){ mine-&gt;a_double_field =
    mine-&gt;a_double_field / 2.0; }

  int main(int argc, char *argv[]){ mytype_t mine1; // first struct
    mine1.an_int_field = 5; mine1.a_double_field = 11.6; char mychar =
    'h'; mine1.a_char_ptr_field = &amp;mychar;

  mytype_halve_double(&amp;mine1);

  // print out the fields of the two structs printf("mine1: %d %f %p\n",
  mine1.an_int_field, mine1.a_double_field, mine1.a_char_ptr_field);

    return 0; }

  Create a new file called `struct_pointer_funcs.c' and copy the
  contents your previous `struct_define.c' file with `cat_t' into it.
  Add the following two functions to the code which involve pointers to
  structs and the arrow operator and use them in the way specified.

  ,----
  | // reduces the weight of the cat to 90% of what it was
  | void cat_diet(cat_t *cat);
  | 
  | // prints all fields of the cat using a format like the following
  | // views 205000000 weight: 0.100000 age: 14 active: Y grumpy: N
  | void cat_print(cat_t *cat);
  | 
  | // age goes up by one and due to a viral birthday video, views doubles
  | void cat_birthday_viral(cat *cat);
  | 
  | 
  | // in main(), after data is initialzed as before, grumpycat goes on a
  | // diet, nyancat has a viral birthday, and both cats are printed using
  | // the new printing function.
  | // EXPECTED OUTPUT
  | // views 410000000 weight: 0.100000 age: age 15 active: Y grumpy: N
  | // views 8300000 weight: 6.750000 age: age 13 active: N grumpy: Y
  `----


D Pointers to structs in functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Draw a memory diagram involving the stack frames for both `main()' and
  `cat_birthday_viral()' at the point in `main()' where `nyancat' has
  the `cat_birthday_viral()' function called on it. It's a good idea to
  copy over the memory diagram you previously constructed. Don't forget
  to add a stack frame for `cat_birthday_viral()'.
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr/> <i> Author: Chris Kauffman (<a href="mailto:profk@umd.edu">profk@umd.edu</a>) <br/> Date: 2025-09-07 Sun 13:05 <br/> </i>
</div>
</body>
</html>
