<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-02-12 Wed 20:33 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CMSC216 Project 1: C Programming</title>
<meta name="author" content="Chris Kauffman" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<meta name="viewport" content="width=device-width, maximum-scale=1, minimum-scale=1" />
<style type="text/css">
@media screen {
:root {
--heading-bg-color:#e21833;
--heading-fg-color:#ffd200;
}
html {
font-family: serif;
text-align: justify;
}
pre.src, pre.example {
overflow-x: scroll;
}
/* Merge subtitle area with title area */
.subtitle {
text-align: center;
margin-top: -2em;
padding-top: 1em;
padding-bottom: 0.1em;
}
.title, .subtitle {
color: var(--heading-fg-color);
background-color: var(--heading-bg-color);
}
/* Section borders, left section header style */
div.outline-2, #table-of-contents {
background-color: rgb(250,250,250);
border: 0.75em solid var(--heading-bg-color);
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
}
div.outline-2 > h2, #table-of-contents > h2 {
background-color: var(--heading-bg-color);
color: var(--heading-fg-color);
font-variant: small-caps;
padding: 0em 0em 0em .5em; /* top right bottom left */
margin: 0em -.5em 0em -.75em; /* top right bottom left */
text-align: left;
}
blockquote {
font-style: italic;
}
td, th {
padding-top: 2px;
padding-bottom: 2px;
}
body {
background-color: #EEE;
}
pre {
}
#content, #preamble, #postamble {
margin-left:300px;
max-width: 100%;
}
.tag {
background-color: inherit; font-family: inherit;
padding: inherit; font-size: 80%; font-weight: inherit;
text-transform: uppercase;
}

.figure p { text-align: inherit; }
figure-number { font-style: italic; }
#table-of-contents {
text-align: left;
position: fixed;
left: 0;
margin: 0 auto;
padding: 0;
width: 300px;
top: 0;
height: 100%;
border: 0;
display: block;
}
#text-table-of-contents {
overflow-y: scroll;
height: 100%;
}
#text-table-of-contents ul {
padding-left: 1em;
margin-left: 0.5em;
}
#table-of-contents > h2 {
padding: 0.1em;
margin: 0;
}
/* adjustments for small screen, toc at top only */
@media (max-width: 800px) { /* landscape for iphone */
html {
-webkit-text-size-adjust: none;  /* prevent scaling of text on mobile */
}
body {
background-color: #EEE;
width:100%;
margin:0 auto;
}
#content, #preamble, #postamble {
margin-left:0;
}
#table-of-contents {
position: static;
left: inherit;
width:inherit;
height: auto;
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
border: 0.75em solid #006633;
}
div.outline-2, #table-of-contents {
background-color: rgb(250,250,250);
border: 0.75em solid var(--heading-bg-color);
border-top: 0em;
padding: 0em .5em .5em .5em; /* top right bottom left */
margin: 1em 0em 1em 0em; /* top right bottom left */
}
div.outline-2 > h2, #table-of-contents > h2 {
background-color: var(--heading-bg-color);
color: var(--heading-fg-color);
font-variant: small-caps;
padding: 0em 0em 0em .5em; /* top right bottom left */
margin: 0em -.5em 0em -.75em; /* top right bottom left */
text-align: left;
}
#text-table-of-contents {
overflow-y: visible;
height: inherit;
}
#text-table-of-contents ul {
padding-left: 1em;
margin-left: 0.5em;
}
}
.linenr { font-size: xx-small; }
th.org-left   { text-align: left;   }
}

@media print {
html {
font-family: serif;
font-size: 10pt;
text-align: justify;
.linenr { font-size: xx-small; }
}
}
</style>
<style>
/* Theme: Srcery
Description: Srcery dark color scheme for highlight.js
Author: Chen Bin <chen.bin@gmail.com>
Maintainer: @redguardtoo
Website: https://srcery-colors.github.io/
Date: 2021-04-13
https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/srcery.css

Tailored by: Chris Kauffman <profk@umd.edu>
Date: Sat Nov 25 06:16:20 PM EST 2023
*/
pre code.hljs {
display: block;
overflow-x: auto;
padding: 1em
}
code.hljs {
padding: 3px 5px
}
.hljs {
background: #1C1B19;
/* Black */
color: #FFFFFF/* Bright White */

}
/* Bright White */
.hljs-subst,
.hljs-quote,
.hljs-literal {
color: #FCE8C3
}
/* Bright Blue */
.hljs-type,
.hljs-symbol {
color: #68A8E4
}
/* Red */
.hljs-keyword,
.hljs-deletion {
color: #EF2F27
}
/* Yellow */
.hljs-name,
.hljs-function,
.hljs-attribute,
.hljs-selector-attr,
.hljs-selector-id,
.hljs-selector-class,
.hljs-selector-pseudo,
.hljs-section,
.hljs-title {
color: #FBB829
}
/* Cyan */
.hljs-code,
.hljs-variable,
.hljs-property,
.hljs-template-variable,
.hljs-class {
color: #0AAEB3
}
/* Bright Green */
.hljs-string,
.hljs-regexp,
.hljs-bullet,
.hljs-addition {
color: #98BC37
}
/* Bright Magenta */
.hljs-built_in,
.hljs-params {
color: #FF5C8F
}
/* Blue */
.hljs-template-tag,
.hljs-selector-tag {
color: #2C78BF
}
/* Bright Black */
.hljs-link,
.hljs-number,
.hljs-comment,
.hljs-meta {
color: #B1B195
/* color: #918175 */
}
.hljs-emphasis {
font-style: italic
}
.hljs-strong {
font-weight: bold
}
/* @see https://github.com/srcery-colors/srcery-emacs for reference */
</style>

<link rel="stylesheet" href="./srcery-ck.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
function interactive_lang() {      // define a custom "interactive" language
return {
name: 'interactive',           // language name
keywords: {
$pattern: /[^ \t\n]+/,       // lex based on non-whitespace
keyword: [">>","(shellac)","HM>","TM>","homeputer>","grace3:","grace4:","grace5:","grace6:","grace7:","grace8:","grace9:","grace10:","grace3>>","grace4>>","grace5>>","grace6>>","grace7>>","grace8>>","grace9>>","grace10>>"], // allowed interactive prompts
},
contains: [
// hljs.HASH_COMMENT_MODE,   // use standard hash comments, any # is a comment
hljs.COMMENT(/#+ /, /$/),    // use custom comment of # w/ whitespace
hljs.COMMENT(/#+/, /$/),     // and a sequence of hashes
]
};
};
hljs.registerLanguage('interactive', interactive_lang);     // register custom language

// Add highlighjs CSS classes to elemens marked with relevant org classes
lang_map = new Map();              // map of org to hljs languages
lang_map.set("src-c"     , "language-c");
lang_map.set("src-python", "language-python");
lang_map.set("src-text"  , "language-plaintext");
lang_map.set("src-sh"    , "language-interactive");
function add_class(el) {           // applied to each pre.src element
for (let [org_lang, hljs_lang] of lang_map) {
if(el.classList.contains(org_lang)){
el.classList.add(hljs_lang);
}
}
}
// visit all pre.src elements and apply function to add language class
document.querySelectorAll('pre.src').forEach(add_class);
hljs.configure({cssSelector: 'pre'}); // select pre blocks only to highligh
hljs.highlightAll();                  // perform highlighting on all pre blocks
});
</script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src=""https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"">
</script>
</head>
<body>
<div id="preamble" class="status">
<i>Last Updated: 2025-02-12 Wed 20:33</i>
</div>
<div id="content" class="content">
<h1 class="title">CMSC216 Project 1: C Programming</h1>
<ul class="org-ul">
<li><b>Due: 11:59pm Mon Mon 24-Feb-2025</b></li>
<li><i>Approximately 4.0% of total grade</i></li>
<li>Submit to <a href="https://www.gradescope.com/"><b>Gradescope</b></a></li>
<li>Projects are <b>individual work</b>: no collaboration with other students
is allowed. Seek help from course staff if you get stuck for too long.</li>
</ul>

<div id="outline-container-org3ab5751" class="outline-4">
<h4 id="org3ab5751">CODE DISTRIBUTION: <a href="p1-code.zip">p1-code.zip</a></h4>
</div>
<div id="outline-container-org46877d8" class="outline-4">
<h4 id="org46877d8">VIDEO OVERVIEW: <a href="https://youtu.be/B-dCO2Xt79c">https://youtu.be/B-dCO2Xt79c</a></h4>
</div>
<div id="outline-container-org8f0a8c2" class="outline-4">
<h4 id="org8f0a8c2">CHANGELOG:</h4>
<div class="outline-text-4" id="text-org8f0a8c2">
<dl class="org-dl">
<dt>Wed Feb 12 08:31:27 PM EST 2025</dt><dd><p>
A video overview of project 1 has
been posted here: <a href="https://youtu.be/B-dCO2Xt79c">https://youtu.be/B-dCO2Xt79c</a>.  Students wishing
for additional discussion and demonstration of steps on how to get
started with the function may benefit from watching the video.
</p>

<p>
The missing images illustrating the process of submitting a
completed project have been fixed.
</p></dd>
</dl>
</div>
</div>

<div id="outline-container-org601783f" class="outline-4">
<h4 id="org601783f"></h4>
<div class="outline-text-4" id="text-org601783f">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgb15b8e2">1. Introduction</a></li>
<li><a href="#orge40f4be">2. Download Code and Setup</a>
<ul>
<li><a href="#org9dee2ac">2.1. Makefile</a></li>
<li><a href="#org194dc98">2.2. Automated Tests</a></li>
<li><a href="#org390aecd">2.3. Multipart Tests</a></li>
</ul>
</li>
<li><a href="#org854541e">3. Maze Solutions via BFS</a>
<ul>
<li><a href="#orgddc4e83">3.1. Breadth First Search Principles</a></li>
<li><a href="#org16771b3">3.2. Demo of BFS in a Maze</a></li>
<li><a href="#org5656bcf">3.3. BFS Reference Material</a></li>
</ul>
</li>
<li><a href="#orgccc4c45">4. Outline of Code</a>
<ul>
<li><a href="#org2db9a1c">4.1. Getting Started</a></li>
<li><a href="#org61b6d95">4.2. The Dev Cycle</a></li>
</ul>
</li>
<li><a href="#org4790d72">5. <b>Problem 1</b>: Row/Col Queue</a>
<ul>
<li><a href="#org86b1710">5.1. Queue Data Types</a></li>
<li><a href="#org52c98a9">5.2. Required Queue Functions</a></li>
<li><a href="#org6242aa1">5.3. Grading Criteria for Problem 1</a></li>
</ul>
</li>
<li><a href="#org2212ff2">6. <b>Problem 2</b>: Tile/Maze Functions</a>
<ul>
<li><a href="#orgbddea14">6.1. Tile/Maze Data Types</a></li>
<li><a href="#org9ddd801">6.2. Enumerations in C</a></li>
<li><a href="#orgfa71ab0">6.3. Provided Data</a></li>
<li><a href="#org2180e5a">6.4. Required Tile/Maze Functions</a></li>
<li><a href="#org38b759a">6.5. Grading Criteria for Problem 2</a></li>
</ul>
</li>
<li><a href="#orgcd02a5c">7. <b>Problem 3</b>: BFS Functions</a>
<ul>
<li><a href="#org4e14028">7.1. Step Functions</a></li>
<li><a href="#org6a8bc94">7.2. Logging</a></li>
<li><a href="#org33a95d6">7.3. Required BFS Functions</a></li>
<li><a href="#orgb8cb469">7.4. Grading Criteria for Problem 3</a></li>
</ul>
</li>
<li><a href="#org57b1965">8. <b>Problem 4</b>: Data Files and Main</a>
<ul>
<li><a href="#org6a48a9b">8.1. Maze Data Files</a></li>
<li><a href="#orgcf66c72">8.2. Loading Maze Data</a></li>
<li><a href="#orgc1fba46">8.3. The Main Function</a></li>
<li><a href="#org0b942ca">8.4. Grading Criteria for Problem 4</a></li>
</ul>
</li>
<li><a href="#org23ecde7">9. Optional MAKEUP Credit (10pts)</a></li>
<li><a href="#org8fb0715">10. Project Submission</a>
<ul>
<li><a href="#org4e1c678">10.1. Submit to Gradescope</a></li>
<li><a href="#org45dfb29">10.2. Late Project Submission Policies</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb15b8e2" class="outline-2">
<h2 id="orgb15b8e2"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth First Search (BFS)</a> is a fundamental algorithm in computing
that allows data modeled with mathematical graphs to be processed and
analyzed for varying effects. A classic usage of BFS is to determine
the Shortest Path between a Start and End point in grid-like graphs
such as in 2D mazes, sometimes referred to a "the dungeon problem"
early computer games used text and characters to on the screen to draw
dungeons that player would navigate. This project will process simple
2D maze data stored in text files and determine the shortest path from
a Start position to all other reachable positions in the maze
including an End tile.
</p>
</div>
</div>

<div id="outline-container-orge40f4be" class="outline-2">
<h2 id="orge40f4be"><span class="section-number-2">2</span> <a id="org6e181ba"></a> Download Code and Setup</h2>
<div class="outline-text-2" id="text-2">
<p>
Download the code pack linked at the top of the page. Unzip this which
will create a project folder. Create new files in this
folder. Ultimately you will re-zip this folder to submit it.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">File</th>
<th scope="col" class="org-left">State</th>
<th scope="col" class="org-left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>Makefile</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Build file to compile all programs</td>
</tr>

<tr>
<td class="org-left"><code>mazesolve_funcs.c</code></td>
<td class="org-left">CREATE</td>
<td class="org-left">Problems 1-3 functions to write, outline provided below</td>
</tr>

<tr>
<td class="org-left"><code>mazesolve_main.c</code></td>
<td class="org-left">CREATE</td>
<td class="org-left">Problem 3 main function</td>
</tr>

<tr>
<td class="org-left"><code>mazesolve.h</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Project Header file</td>
</tr>

<tr>
<td class="org-left"><code>cmdline_args.c</code></td>
<td class="org-left">Provided</td>
<td class="org-left">Demo of how to access command line arguments</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>data/maze-little.txt</code></td>
<td class="org-left">Data</td>
<td class="org-left">Tiny maze for testing</td>
</tr>

<tr>
<td class="org-left"><code>data/maze-room1.txt</code></td>
<td class="org-left">Data</td>
<td class="org-left">Modest maze for testing</td>
</tr>

<tr>
<td class="org-left"><code>data/maze-big-mult1.txt</code></td>
<td class="org-left">Data</td>
<td class="org-left">Large maze with multiple paths from Start to End</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>testy</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Test running script</td>
</tr>

<tr>
<td class="org-left"><code>test_mazesolve_funcs.c</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Testing file for required C functions</td>
</tr>

<tr>
<td class="org-left"><code>test-results/</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Directory in which temporary testing files are written</td>
</tr>

<tr>
<td class="org-left"><code>test_mazesolve1.org</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Problem 1 tests</td>
</tr>

<tr>
<td class="org-left"><code>test_mazesolve2.org</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Problem 2 tests</td>
</tr>

<tr>
<td class="org-left"><code>test_mazesolve3.org</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Problem 3 tests</td>
</tr>

<tr>
<td class="org-left"><code>test_mazesolve4.org</code></td>
<td class="org-left">Testing</td>
<td class="org-left">Problem 4 tests</td>
</tr>
</tbody>
</table>
</div>


<div id="outline-container-org9dee2ac" class="outline-3">
<h3 id="org9dee2ac"><span class="section-number-3">2.1</span> Makefile</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A <code>Makefile</code> is provided as part of this project. Building programs in
C is a bit tedious and most folks use <b>build systems</b> of which <code>make</code>
is a venerable entry. The instructions and dependencies to create programs
are written in a <code>Makefile</code> which is then interpreted by the <code>make</code>
program which will run <code>gcc</code> and other commands to create programs.
</p>

<p>
Use this <code>Makefile</code> by issuing commands like <code>make prob1</code>
</p>
<div class="org-src-container">
<pre class="src src-sh">&gt;&gt; make help
Typical usage is:
  &gt; make                          # build all programs
  &gt; make clean                    # remove all compiled items
  &gt; make zip                      # create a zip file for submission
  &gt; make prob1                    # built targets associated with problem 1
  &gt; make test                     # run all tests
  &gt; make test-prob2               # run test for problem 2
  &gt; make test-prob2 testnum=5     # run problem 2 test #5 only
  &gt; make update                   # download and install any updates to project files

&gt;&gt; make prob2                     # build problem 2 demo program
make prob2
gcc -Wall -g -Wno-unused-variable -c mazesolve_funcs.c
gcc -Wall -g -Wno-unused-variable -o test_mazesolve_funcs test_mazesolve_funcs.c mazesolve_funcs.o

&gt; make clean                      # remove all programs/binary object files
rm -f mazesolve_main test_mazesolve_funcs *.o

&gt;&gt; make prob4                     # build problem 4 main program
gcc -Wall -g -Wno-unused-variable -c mazesolve_main.c
gcc -Wall -g -Wno-unused-variable -c mazesolve_funcs.c
gcc -Wall -g -Wno-unused-variable -o mazesolve_main mazesolve_main.o mazesolve_funcs.o
gcc -Wall -g -Wno-unused-variable -o test_mazesolve_funcs test_mazesolve_funcs.c mazesolve_funcs.o

&gt; make clean                      # remove all programs/binary object files
rm -f mazesolve_main test_mazesolve_funcs *.o

&gt;&gt; make                           # build all programs/objects for the assignment
gcc -Wall -g -Wno-unused-variable -c mazesolve_main.c
gcc -Wall -g -Wno-unused-variable -c mazesolve_funcs.c
gcc -Wall -g -Wno-unused-variable -o mazesolve_main mazesolve_main.o mazesolve_funcs.o
gcc -Wall -g -Wno-unused-variable -o test_mazesolve_funcs test_mazesolve_funcs.c mazesolve_funcs.o
</pre>
</div>

<p>
You are not required to understand all that is in the <code>Makefile</code> (yet)
but it is a very useful tool well worth your time to learn.
</p>
</div>
</div>

<div id="outline-container-org194dc98" class="outline-3">
<h3 id="org194dc98"><span class="section-number-3">2.2</span> <a id="orgf2477a1"></a> Automated Tests</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Automated tests are included with the code distribution. <b>These tests
are known to work on grace.umd.edu only</b> but in most cases they should
run identically in Linux environments. They <i>may</i> work on the Windows Subsystem
for Linux but no guarantees are made. They very unlikely to run on
MacOS natively as Linux-specific tools are used.
</p>

<p>
The provided <code>Makefile</code> allows automated tests to be run via calls
like <code>make test-prob1</code> to test Problem 1 and <code>make test-prob2</code> to test
Problem 2. See the transcript below.
</p>
<div class="org-src-container">
<pre class="src src-sh">&gt;&gt; make test-prob1                    # run tests for problem 1, compiles required code first
gcc -Wall -g -Wno-unused-variable -c mazesolve_funcs.c
gcc -Wall -g -Wno-unused-variable -o test_mazesolve_funcs test_mazesolve_funcs.c mazesolve_funcs.o
./testy -o md test_mazesolve1.org 
===============================================================
== test_mazesolve1.org : Problem 1 Row/Col Queue Function Tests
== Running 10 / 10 tests
 1) rcqueue_allocate_free1 : ok
 2) rcqueue_add_rear1      : ok
 3) rcqueue_add_rear2      : ok
 4) rcqueue_get_front1     : ok
 5) rcqueue_remove_front1  : ok
 6) rcqueue_remove_front2  : ok
 7) rcqueue_remove_front3  : ok
 8) rcqueue_print1         : ok
 9) rcqueue_print1         : ok
10) rcqueue_print2         : ok
===============================================================
RESULTS: 10 / 10 tests passed

&gt;&gt; make test-prob2                    # run tests for problem 2
./testy -o md test_mazesolve2.org 
=================================================================
== test_mazesolve2.org : Problem 2 Basic Tile/Maze Function Tests
== Running 15 / 15 tests
 1) tile_print_path1    : ok
 2) tile_print_path2    : ok
 3) tile_extend_path1   : ok
 4) tile_extend_path2   : ok
 5) maze_allocate_free1 : ok
 6) maze_allocate_free2 : ok
...

&gt; make test                           # run tests for all problems
...
</pre>
</div>
<p>
Each problem describes specifically how tests can be run and how
credit will be assigned.
</p>

<p>
Note that one can <b>run a single test</b> with the following <code>make</code>
invocation which sets <code>testnum</code>.
</p>
<div class="org-src-container">
<pre class="src src-sh">&gt; make test-prob2 testnum=5
</pre>
</div>
<p>
This is useful when debugging to limit the output and time it takes to
check program results.
</p>
</div>
</div>

<div id="outline-container-org390aecd" class="outline-3">
<h3 id="org390aecd"><span class="section-number-3">2.3</span> Multipart Tests</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Some automated tests are reported as <code>MULTIPART</code>. These involve several
steps such as repeated runs of a program or multiple criteria that are
checked in sequence.  Multipart tests will be run in <i>Segments</i> and if
an early segment fails, the remaining segments will not run. The
Segment that fails will appear at the end of the results file and show
the usual diagnostic information (side-by-side diff, Valgrind report,
etc.). All Segments of a MULTIPART tests must pass for the test to succeed.
</p>
</div>
</div>
</div>

<div id="outline-container-org854541e" class="outline-2">
<h2 id="org854541e"><span class="section-number-2">3</span> Maze Solutions via BFS</h2>
<div class="outline-text-2" id="text-3">
<p>
Mazes will be encoded in simple text files several of which are
present in the project codepack in the <code>data/</code> directory. An example
is:
</p>
<div class="org-src-container">
<pre class="src src-sh">&gt;&gt; cat data/maze-simple2.txt
rows: 7 cols: 16
tiles:
################
#S             #
# ### ###### # #
# ### ##E  #   #
# ### #### ##  #
#              #
################
</pre>
</div>
<ul class="org-ul">
<li><code>S</code> marks the Start Tile where the search begins</li>
<li><code>E</code> marks the End Tile which is the goal to be reached</li>
<li><code>#</code> marks Wall tiles which are blocked and cannot be crossed</li>
<li>Spaces are Open tiles which can be traversed</li>
</ul>

<p>
The goal of the project is to create a program that will read this
text file, construct and internal representation of the maze, use a
BFS to determine paths to all other tiles, and then print out the
shortest path from the Start to End tile. It is well summarized by a
sample run.
</p>
<div class="org-src-container">
<pre class="src src-sh">&gt;&gt; ./mazesolve_main data/maze-simple2.txt 
maze: 7 rows 16 cols
      (1,1) start
      (3,8) end
maze tiles:
################
#S             #
# ### ###### # #
# ### ##E  #   #
# ### #### ##  #
#              #
################
SOLUTION:
maze: 7 rows 16 cols
      (1,1) start
      (3,8) end
maze tiles:
################
#S             #
#.### ###### # #
#.### ##E..#   #
#.### ####.##  #
#..........    #
################
path length: 17
 0: SOUTH
 1: SOUTH
 2: SOUTH
 3: SOUTH
 4: EAST
 5: EAST
 6: EAST
 7: EAST
 8: EAST
 9: EAST
10: EAST
11: EAST
12: EAST
13: NORTH
14: NORTH
15: WEST
16: WEST
</pre>
</div>
<p>
This demonstration shows several features of the program.
</p>
<ul class="org-ul">
<li>It reads a text file with the maze in it and dynamically allocates
data to store the maze</li>
<li>After conducting the BFS and locating a path from Start to End, the
program draws the path and prints out the sequence of movement
directions to go from the Start to End tile, the 17 steps shown last</li>
</ul>
<p>
Much happens between the two steps indicated above that will be
discussed further.
</p>
</div>

<div id="outline-container-orgddc4e83" class="outline-3">
<h3 id="orgddc4e83"><span class="section-number-3">3.1</span> Breadth First Search Principles</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The essence of a BFS is to maintain a Queue of positions to explore
with the queue ordered on the "distance" from the Start tile. In this
situation, only North / South / East / West movements are allowed and
the regular grid means adjacent Tiles are 1 "move" apart (general
graphs use edges to represented connected nodes possibly weighting the
edges which leads to more complex approaches like Dijkstra's
algorithm). A nice feature of queuing Tiles in this fashion is that
Tiles nearer to the Start Tile will be explored first allowing the
algorithm to determine the shortest path from the Start tile to any
other.  Below is adapted pseudocode for the type of BFS that will be
implemented in the project.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span>def maze_bfs(maze):
<span class="linenr"> 2: </span>  start_tile = maze.tiles[maze.start_row][maze.start_col] 
<span class="linenr"> 3: </span>  start_tile.state = FOUND
<span class="linenr"> 4: </span>  start_tile.path  = []         # empty array
<span class="linenr"> 5: </span>  queue = make_empty_queue()    # for row/col coordinates
<span class="linenr"> 6: </span>  queue.add_rear(maze.start_row, maze.start_col)
<span class="linenr"> 7: </span>  while queue is not empty:
<span class="linenr"> 8: </span>    (row,col) = queue.get_front()
<span class="linenr"> 9: </span>    cur_tile = maze.tiles[row][col]
<span class="linenr">10: </span>    for dir in [North,South,West,East]:
<span class="linenr">11: </span>      next_tile = tile in direction dir from (row,col)
<span class="linenr">12: </span>      if tile out of bounds or tile.type==Wall or tile.state==FOUND:
<span class="linenr">13: </span>        continue to next direction
<span class="linenr">14: </span>      else:
<span class="linenr">15: </span>        next_tile.state = FOUND
<span class="linenr">16: </span>        next_tile.path = copy of cur_tile.path w/ dir appended
<span class="linenr">17: </span>        queue.add_rear(row of next_tile, col of next_tile)
<span class="linenr">18: </span>    queue.remove_front()
<span class="linenr">19: </span># At the end of execution, all tiles have the shortest path from the
<span class="linenr">20: </span># Start tile to them stored in their path[] array
<span class="linenr">21: </span># 
<span class="linenr">22: </span># Note: this variation calculates paths from Start to all other
<span class="linenr">23: </span># tiles but a common variant terminates the algorithm when a path to
<span class="linenr">24: </span># the End Tile is found
</pre>
</div>

<p>
There are quite a few details associated with the pseudocode above
that must be handled in a code implementation. The project will break
this algorithm into smaller chunks that can be written and tested
somewhat independently during development.
</p>
</div>
</div>

<div id="outline-container-org16771b3" class="outline-3">
<h3 id="org16771b3"><span class="section-number-3">3.2</span> Demo of BFS in a Maze</h3>
<div class="outline-text-3" id="text-3-2">
<p>
An example of how BFS proceeds is instructive. Below is the execution
of the program the project implements with <b>logging enabled</b> so that
intermediate information is reported as the algorithm makes
progress. The additional output is enabled by using the command line
flag <code>-log &lt;num&gt;</code> and causes output to be printed affixed with
<code>LOG:</code>. The program will be required to handle this command line
argument AND function will examine a global <code>LOG_LEVEL</code> variable and
print additional output for some of its values.
</p>

<p>
The program demo is shown in chunks.
</p>
</div>

<div id="outline-container-org21c4d0e" class="outline-4">
<h4 id="org21c4d0e">Initialization</h4>
<div class="outline-text-4" id="text-org21c4d0e">
<div class="org-src-container">
<pre class="src src-sh">&gt;&gt; ./mazesolve_main -log 5 data/maze-small-threepath1.txt 
maze: 6 rows 9 cols
      (2,4) start
      (3,7) end
maze tiles:
#########
#    #  #
# ##S  ##
#  # ##E#
#       #
#########
LOG: BFS initialization complete
#########:  0
#    #  #:  1
# ##0  ##:  2
#  # ##E#:  3
#       #:  4
#########:  5
012345678
0        
queue count: 1
NN ROW COL
 0   2   4
</pre>
</div>
<p>
In this first portion, the file is loaded and the BFS data is
initialized. The maze is drawn after the <code>LOG: BFS initialization
complete</code> message with the <code>S</code> replaced with a 0 as the Start tile has
a path of length 0 to itself. Below this drawing of the maze is the
state of the queue which has only the Start tile coordinates (2,4) in
it. This is the state of affairs after the first 5 lines of Pseudocode
for <code>maze_bfs()</code> and before the main loop proceeds. The drawing
includes Axis Labels to make it easier to see the (row,col) positions
of various tiles.
</p>
</div>
</div>

<div id="outline-container-org021f93e" class="outline-4">
<h4 id="org021f93e">BFS Step 1</h4>
<div class="outline-text-4" id="text-org021f93e">
<div class="org-src-container">
<pre class="src src-sh">LOG: BFS STEP 1
LOG: processing neighbors of (2,4)
LOG: Found tile at (1,4) with len 1 path: N
LOG: Found tile at (3,4) with len 1 path: S
LOG: Skipping BLOCKED tile at (2,3)
LOG: Found tile at (2,5) with len 1 path: E
LOG: maze state after BFS step
#########:  0
#   1#  #:  1
# ##01 ##:  2
#  #1##E#:  3
#       #:  4
#########:  5
012345678
0        
queue count: 3
NN ROW COL
 0   1   4
 1   3   4
 2   2   5
</pre>
</div>
<p>
During the firs iteration, the single element from the search Queue is
removed. It is the Start tile at (2,4) as indicated by the <code>LOG:</code>
message.  Each of the neighbors of this tile are searched
</p>
<ul class="org-ul">
<li>(1,4) which is North, an Open tile</li>
<li>(3,4) which is South, an Open tile</li>
<li>(2,3) which is North, a Wall</li>
<li>(2,5) which is North, an Open tile</li>
</ul>
<p>
The Wall tile is ignored. Each of the Open tiles is marked as FOUND
and the empty path for (2,4) has the direction to go to reach neighbor
appended and copied to the neighbors. Each of these Found tiles is
added to the search Queue. Completing the first iteration of the
algorithm's <code>while()</code> loop.
</p>

<p>
The search Queue is not empty so the outer loop will iterate again.
</p>
</div>
</div>

<div id="outline-container-org74b5ebe" class="outline-4">
<h4 id="org74b5ebe">BFS Step 2</h4>
<div class="outline-text-4" id="text-org74b5ebe">
<div class="org-src-container">
<pre class="src src-sh">LOG: BFS STEP 2
LOG: processing neighbors of (1,4)
LOG: Skipping BLOCKED tile at (0,4)
LOG: Skipping FOUND tile at (2,4)
LOG: Found tile at (1,3) with len 2 path: NW
LOG: Skipping BLOCKED tile at (1,5)
LOG: maze state after BFS step
#########:  0
#  21#  #:  1
# ##01 ##:  2
#  #1##E#:  3
#       #:  4
#########:  5
012345678
0        
queue count: 3
NN ROW COL
 0   3   4
 1   2   5
 2   1   3
</pre>
</div>
<p>
At the front of the queue is (1,4) so it is removed from the queue and
its neighbors are processed. These are Walls (North, East) and Open
tiles (South, West).  However, the Start tile is to the South and it
has already been marked as FOUND so is skipped from further
processing. Rather, only (1,3) is new and added at the end of the
queue with the path {North, West} as printed in the <code>LOG:</code>
message. That tile is now printed with a 2 in it as it is 2 moves away
from the Start tile.
</p>
</div>
</div>

<div id="outline-container-org212cd28" class="outline-4">
<h4 id="org212cd28">BFS Step 3</h4>
<div class="outline-text-4" id="text-org212cd28">
<div class="org-src-container">
<pre class="src src-sh">LOG: BFS STEP 3
LOG: processing neighbors of (3,4)
LOG: Skipping FOUND tile at (2,4)
LOG: Found tile at (4,4) with len 2 path: SS
LOG: Skipping BLOCKED tile at (3,3)
LOG: Skipping BLOCKED tile at (3,5)
LOG: maze state after BFS step
#########:  0
#  21#  #:  1
# ##01 ##:  2
#  #1##E#:  3
#   2   #:  4
#########:  5
012345678
0        
queue count: 3
NN ROW COL
 0   2   5
 1   1   3
 2   4   4
</pre>
</div>
<p>
Like the preceding step, (3,4) which is processed in this step, has
only one new neighbor (4,4) with (3,3) and (3,5) being blocked by
Walls and (2,4) being previously Found.
</p>
</div>
</div>

<div id="outline-container-org7b0ea9f" class="outline-4">
<h4 id="org7b0ea9f">Remaining BFS Steps</h4>
<div class="outline-text-4" id="text-org7b0ea9f">
<p>
The remaining output is shown below which eventually visits all tiles
in the maze. It follows a similar pattern of processing the first
queue element to add its unblocked/new neighbors to the search Queue.
If in doubt, study these examples for additional insight on
how BFS proceeds and output expected for the program when logging is
enabled.
</p>
<div class="org-src-container">
<pre class="src src-sh">LOG: BFS STEP 4
LOG: processing neighbors of (2,5)
LOG: Skipping BLOCKED tile at (1,5)
LOG: Skipping BLOCKED tile at (3,5)
LOG: Skipping FOUND tile at (2,4)
LOG: Found tile at (2,6) with len 2 path: EE
LOG: maze state after BFS step
#########:  0
#  21#  #:  1
# ##012##:  2
#  #1##E#:  3
#   2   #:  4
#########:  5
012345678
0        
queue count: 3
NN ROW COL
 0   1   3
 1   4   4
 2   2   6
LOG: BFS STEP 5
LOG: processing neighbors of (1,3)
LOG: Skipping BLOCKED tile at (0,3)
LOG: Skipping BLOCKED tile at (2,3)
LOG: Found tile at (1,2) with len 3 path: NWW
LOG: Skipping FOUND tile at (1,4)
LOG: maze state after BFS step
#########:  0
# 321#  #:  1
# ##012##:  2
#  #1##E#:  3
#   2   #:  4
#########:  5
012345678
0        
queue count: 3
NN ROW COL
 0   4   4
 1   2   6
 2   1   2
LOG: BFS STEP 6
LOG: processing neighbors of (4,4)
LOG: Skipping FOUND tile at (3,4)
LOG: Skipping BLOCKED tile at (5,4)
LOG: Found tile at (4,3) with len 3 path: SSW
LOG: Found tile at (4,5) with len 3 path: SSE
LOG: maze state after BFS step
#########:  0
# 321#  #:  1
# ##012##:  2
#  #1##E#:  3
#  323  #:  4
#########:  5
012345678
0        
queue count: 4
NN ROW COL
 0   2   6
 1   1   2
 2   4   3
 3   4   5
LOG: BFS STEP 7
LOG: processing neighbors of (2,6)
LOG: Found tile at (1,6) with len 3 path: EEN
LOG: Skipping BLOCKED tile at (3,6)
LOG: Skipping FOUND tile at (2,5)
LOG: Skipping BLOCKED tile at (2,7)
LOG: maze state after BFS step
#########:  0
# 321#3 #:  1
# ##012##:  2
#  #1##E#:  3
#  323  #:  4
#########:  5
012345678
0        
queue count: 4
NN ROW COL
 0   1   2
 1   4   3
 2   4   5
 3   1   6
LOG: BFS STEP 8
LOG: processing neighbors of (1,2)
LOG: Skipping BLOCKED tile at (0,2)
LOG: Skipping BLOCKED tile at (2,2)
LOG: Found tile at (1,1) with len 4 path: NWWW
LOG: Skipping FOUND tile at (1,3)
LOG: maze state after BFS step
#########:  0
#4321#3 #:  1
# ##012##:  2
#  #1##E#:  3
#  323  #:  4
#########:  5
012345678
0        
queue count: 4
NN ROW COL
 0   4   3
 1   4   5
 2   1   6
 3   1   1
LOG: BFS STEP 9
LOG: processing neighbors of (4,3)
LOG: Skipping BLOCKED tile at (3,3)
LOG: Skipping BLOCKED tile at (5,3)
LOG: Found tile at (4,2) with len 4 path: SSWW
LOG: Skipping FOUND tile at (4,4)
LOG: maze state after BFS step
#########:  0
#4321#3 #:  1
# ##012##:  2
#  #1##E#:  3
# 4323  #:  4
#########:  5
012345678
0        
queue count: 4
NN ROW COL
 0   4   5
 1   1   6
 2   1   1
 3   4   2
LOG: BFS STEP 10
LOG: processing neighbors of (4,5)
LOG: Skipping BLOCKED tile at (3,5)
LOG: Skipping BLOCKED tile at (5,5)
LOG: Skipping FOUND tile at (4,4)
LOG: Found tile at (4,6) with len 4 path: SSEE
LOG: maze state after BFS step
#########:  0
#4321#3 #:  1
# ##012##:  2
#  #1##E#:  3
# 43234 #:  4
#########:  5
012345678
0        
queue count: 4
NN ROW COL
 0   1   6
 1   1   1
 2   4   2
 3   4   6
LOG: BFS STEP 11
LOG: processing neighbors of (1,6)
LOG: Skipping BLOCKED tile at (0,6)
LOG: Skipping FOUND tile at (2,6)
LOG: Skipping BLOCKED tile at (1,5)
LOG: Found tile at (1,7) with len 4 path: EENE
LOG: maze state after BFS step
#########:  0
#4321#34#:  1
# ##012##:  2
#  #1##E#:  3
# 43234 #:  4
#########:  5
012345678
0        
queue count: 4
NN ROW COL
 0   1   1
 1   4   2
 2   4   6
 3   1   7
LOG: BFS STEP 12
LOG: processing neighbors of (1,1)
LOG: Skipping BLOCKED tile at (0,1)
LOG: Found tile at (2,1) with len 5 path: NWWWS
LOG: Skipping BLOCKED tile at (1,0)
LOG: Skipping FOUND tile at (1,2)
LOG: maze state after BFS step
#########:  0
#4321#34#:  1
#5##012##:  2
#  #1##E#:  3
# 43234 #:  4
#########:  5
012345678
0        
queue count: 4
NN ROW COL
 0   4   2
 1   4   6
 2   1   7
 3   2   1
LOG: BFS STEP 13
LOG: processing neighbors of (4,2)
LOG: Found tile at (3,2) with len 5 path: SSWWN
LOG: Skipping BLOCKED tile at (5,2)
LOG: Found tile at (4,1) with len 5 path: SSWWW
LOG: Skipping FOUND tile at (4,3)
LOG: maze state after BFS step
#########:  0
#4321#34#:  1
#5##012##:  2
# 5#1##E#:  3
#543234 #:  4
#########:  5
012345678
0        
queue count: 5
NN ROW COL
 0   4   6
 1   1   7
 2   2   1
 3   3   2
 4   4   1
LOG: BFS STEP 14
LOG: processing neighbors of (4,6)
LOG: Skipping BLOCKED tile at (3,6)
LOG: Skipping BLOCKED tile at (5,6)
LOG: Skipping FOUND tile at (4,5)
LOG: Found tile at (4,7) with len 5 path: SSEEE
LOG: maze state after BFS step
#########:  0
#4321#34#:  1
#5##012##:  2
# 5#1##E#:  3
#5432345#:  4
#########:  5
012345678
0        
queue count: 5
NN ROW COL
 0   1   7
 1   2   1
 2   3   2
 3   4   1
 4   4   7
LOG: BFS STEP 15
LOG: processing neighbors of (1,7)
LOG: Skipping BLOCKED tile at (0,7)
LOG: Skipping BLOCKED tile at (2,7)
LOG: Skipping FOUND tile at (1,6)
LOG: Skipping BLOCKED tile at (1,8)
LOG: maze state after BFS step
#########:  0
#4321#34#:  1
#5##012##:  2
# 5#1##E#:  3
#5432345#:  4
#########:  5
012345678
0        
queue count: 4
NN ROW COL
 0   2   1
 1   3   2
 2   4   1
 3   4   7
LOG: BFS STEP 16
LOG: processing neighbors of (2,1)
LOG: Skipping FOUND tile at (1,1)
LOG: Found tile at (3,1) with len 6 path: NWWWSS
LOG: Skipping BLOCKED tile at (2,0)
LOG: Skipping BLOCKED tile at (2,2)
LOG: maze state after BFS step
#########:  0
#4321#34#:  1
#5##012##:  2
#65#1##E#:  3
#5432345#:  4
#########:  5
012345678
0        
queue count: 4
NN ROW COL
 0   3   2
 1   4   1
 2   4   7
 3   3   1
LOG: BFS STEP 17
LOG: processing neighbors of (3,2)
LOG: Skipping BLOCKED tile at (2,2)
LOG: Skipping FOUND tile at (4,2)
LOG: Skipping FOUND tile at (3,1)
LOG: Skipping BLOCKED tile at (3,3)
LOG: maze state after BFS step
#########:  0
#4321#34#:  1
#5##012##:  2
#65#1##E#:  3
#5432345#:  4
#########:  5
012345678
0        
queue count: 3
NN ROW COL
 0   4   1
 1   4   7
 2   3   1
LOG: BFS STEP 18
LOG: processing neighbors of (4,1)
LOG: Skipping FOUND tile at (3,1)
LOG: Skipping BLOCKED tile at (5,1)
LOG: Skipping BLOCKED tile at (4,0)
LOG: Skipping FOUND tile at (4,2)
LOG: maze state after BFS step
#########:  0
#4321#34#:  1
#5##012##:  2
#65#1##E#:  3
#5432345#:  4
#########:  5
012345678
0        
queue count: 2
NN ROW COL
 0   4   7
 1   3   1
LOG: BFS STEP 19
LOG: processing neighbors of (4,7)
LOG: Found tile at (3,7) with len 6 path: SSEEEN
LOG: Skipping BLOCKED tile at (5,7)
LOG: Skipping FOUND tile at (4,6)
LOG: Skipping BLOCKED tile at (4,8)
LOG: maze state after BFS step
#########:  0
#4321#34#:  1
#5##012##:  2
#65#1##6#:  3
#5432345#:  4
#########:  5
012345678
0        
queue count: 2
NN ROW COL
 0   3   1
 1   3   7
LOG: BFS STEP 20
LOG: processing neighbors of (3,1)
LOG: Skipping FOUND tile at (2,1)
LOG: Skipping FOUND tile at (4,1)
LOG: Skipping BLOCKED tile at (3,0)
LOG: Skipping FOUND tile at (3,2)
LOG: maze state after BFS step
#########:  0
#4321#34#:  1
#5##012##:  2
#65#1##6#:  3
#5432345#:  4
#########:  5
012345678
0        
queue count: 1
NN ROW COL
 0   3   7
LOG: BFS STEP 21
LOG: processing neighbors of (3,7)
LOG: Skipping BLOCKED tile at (2,7)
LOG: Skipping FOUND tile at (4,7)
LOG: Skipping BLOCKED tile at (3,6)
LOG: Skipping BLOCKED tile at (3,8)
LOG: maze state after BFS step
#########:  0
#4321#34#:  1
#5##012##:  2
#65#1##6#:  3
#5432345#:  4
#########:  5
012345678
0        
queue count: 0
NN ROW COL
LOG: solution START at (2,4)
LOG: solution path[0] is SOUTH, set (3,4) to ONPATH
LOG: solution path[1] is SOUTH, set (4,4) to ONPATH
LOG: solution path[2] is EAST, set (4,5) to ONPATH
LOG: solution path[3] is EAST, set (4,6) to ONPATH
LOG: solution path[4] is EAST, set (4,7) to ONPATH
LOG: solution path[5] is NORTH, set (3,7) to ONPATH
LOG: solution END at (3,7)
SOLUTION:
maze: 6 rows 9 cols
      (2,4) start
      (3,7) end
maze tiles:
#########
#    #  #
# ##S  ##
#  #.##E#
#   ....#
#########
path length: 6
 0: SOUTH
 1: SOUTH
 2: EAST
 3: EAST
 4: EAST
 5: NORTH
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5656bcf" class="outline-3">
<h3 id="org5656bcf"><span class="section-number-3">3.3</span> BFS Reference Material</h3>
<div class="outline-text-3" id="text-3-3">
<p>
For those who want more details on BFS associated with our case and
the more general case, the following references are concise and
useful.
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Wikipedia: Breadth First Search</a> : Covers basics of the algorithm
including simplified pseudocode, some good visuals, and a variety of
properties of the algorithm like its time and space complexity.</li>

<li><a href="https://www.youtube.com/watch?v=KiCBXu4P-2Y">Breadth First Search grid shortest path | Graph Theory by
WilliamFiset</a> : Good Overview video which focuses on a Python
implementation to search a 2D maze / grid as is our
situation. Connections to Graph Theory and general BFS on graphs are
made though without code.</li>
</ul>
</div>
</div>
</div>



<div id="outline-container-orgccc4c45" class="outline-2">
<h2 id="orgccc4c45"><span class="section-number-2">4</span> Outline of Code</h2>
<div class="outline-text-2" id="text-4">
<p>
The file <code>mazesolve_funcs.c</code> will contain most of the support
functions for the Maze Solving program. An outline of these functions
are presented below. Note that each function has the Problem # to
which it belongs. The final <code>main()</code> function should be written in the
<code>mazesolve_main.c</code> file.
</p>

<p>
You may add additional functions to those indicated ("helper" or
"utility" functions) but these will not graded and the design of the
project is oriented towards not needing additional functions.
</p>

<div class="org-src-container">
<pre class="src src-c">#include "mazesolve.h"

////////////////////////////////////////////////////////////////////////////////
// PROVIDED DATA
//
// The data below should not be altered as it should be used as-is in functions
///////////////////////////////////////////////////////////////////////////////

// Global variable controlling how much info should be printed; it is
// assigned values like LOG_ALL (defined in the header as 10) to
// trigger additional output to be printed during certain
// functions. This output is useful to monitor and audit how program
// execution proceeds.
int LOG_LEVEL = 0;

// Pre-specified order in which neighbor tiles shoudl be checked for
// compatibility with tests.
direction_t dir_delta[5] = {NONE, NORTH, SOUTH, WEST, EAST};
int row_delta[5] =         {+0,      -1,    +1,   +0,   +0};
int col_delta[5] =         {+0,      +0,    +0,   -1,   +1};
#define DELTA_START 1
#define DELTA_COUNT 5


// strings to print for compact directions
char *direction_compact_strs[5] = {
  "?",                          // NONE
  "N",                          // NORTH
  "S",                          // SOUTH
  "W",                          // WEST
  "E",                          // EAST
};
  
// strings to print for verbose directions
char *direction_verbose_strs[5] = {
  "NONE",                       // NONE
  "NORTH",                      // NORTH
  "SOUTH",                      // SOUTH
  "WEST",                       // WEST
  "EAST",                       // EAST
};

#define TILETYPE_COUNT 6

// strings to print for each tile type
char tiletype_chars[TILETYPE_COUNT] = {
  '?',                          // NOTSET = 0,
  '#',                          // WALL,
  ' ',                          // OPEN,
  '.',                          // ONPATH,
  'S',                          // START,
  'E',                          // END,
};

// characters to print in the visual rendering of the BFS in the maze
// when the distance is evently divisible by 10: a is 10, b is 20, c
// is 30, etc.
char digit10_chars[] = "0abcdefghijklmnopqrstuvwxyzABCDE%GHIJKLMNOPQR$TUVWXYZ";

////////////////////////////////////////////////////////////////////////////////
// FUNCTIONS FOR PROBLEM 1: Row/Col Queue
////////////////////////////////////////////////////////////////////////////////

rcqueue_t *rcqueue_allocate();
// PROBLEM 1: Create a new queue of row/col coordinates that is
// empty. Heap-allocate the queue and return a pointer to
// it. Initialize all fields of the queue struct to indicate its
// emptiness. 
//
// CONSTRAINTS: When allocating heap memory, assume calls to malloc()
// succeed and avoid checks to determine if memory allocation failed.

void rcqueue_add_rear(rcqueue_t *queue, int row, int col);
// PROBLEM 1: Add the given row/col coordinates at the end of the
// queue.  Allocates a new node for the coordinates and links this in
// at the end of the queue.
//
// NOTES: The first addition to an empty queue usually requires
// special handling that is different from than subsequent
// additions. Make sure to check for this case. If you see
// Segmentation Faults when running tests, examine the line numbers
// closely, check what the test was evaluating, and trace the
// execution mentally or via debug printing to find the problem.

void rcqueue_free(rcqueue_t *queue);
// PROBLEM 1: De-allocate the memory associated with `queue`. If it is
// non-empty, remove all elements from it de-allocating their nodes
// before free()'ing the queue struct itself.

int rcqueue_get_front(rcqueue_t *queue, int *rowp, int *colp);
// PROBLEM 1: Retrieve the front element of the queue but do not
// otherwise change the queue.  If the queue is empty, immediately
// returns 0.  Otherwise, the pointers rowp and colp are dereferenced
// and set to be the row/col in the front node in the queue and 1 is
// returned to indicate that the rowp/colp have been set.

int rcqueue_remove_front(rcqueue_t *queue);
// PROBLEM 1: Removes the front node of the queue. If the queue is
// empty, immediately returns 0 to indicate the queue is
// unchanged. Otherwise, advances the front pointer of the queue to
// the next node in the queue and the de-allocates the node which was
// previously at the front. Adjusts the count of nodes in the
// queue. Returns 1 to indicate the queue has changed.
//
// CONSTRAINT: This should be a constant time O(1) operation.
// CONSTRAINT: When the queue is empty, BOTH front/rear should be NULL.

void rcqueue_print(rcqueue_t *queue);
// PROBLEM 1: Prints a table of the current queue contents to standard
// out using printf(). The output should look like the following.
//
// queue count: 3
// NN ROW COL
//  0   4   5
//  1   1   8
//  2   5   5
// 
// The first line is the plain text "queue count: " followed by the
// count of nodes in the queue. The next line is a header with 
// Node Number (NN), Row, and Col for columns with remaining lines
// showing data for each node. Each line of this output is printed
// with numbers right-aligned with a field width of 2 characters for
// node numbers and 3 characters for row/col coordinates.
//
// If `queue` is NULL, print the string "null queue\n" instead.
//
// NOTES: Research the capabilities of printf() to print data in a
// specific field width. A usage like printf("%3d",number) will be
// useful in a situation like this to line up table entries.

////////////////////////////////////////////////////////////////////////////////
// FUNCTIONS FOR PROBLEM 2: Tile and Maze Utility Functions
////////////////////////////////////////////////////////////////////////////////

void tile_print_path(tile_t *tile, int format);
// PROBLEM 2: Print the path field of `tile` in one of two formats. If
// the path field is NULL, print "No path found\n". Otherwise, if the
// `format` parameter is PATH_FORMAT_COMPACT, iterate over the path
// array and print each element as a string that comes from the global
// direction_compact_strs[] array without printing any newlines. If
// the `format` parameter is PATH_FORMAT_VERBOSE, print the length of
// the path on its own line then each element of the path with its
// index on its on line using strings from teh
// direction_verbose_strs[] global array. If the format is neither of
// COMPACT or VERBOSE, print an error message (not tested).
//
// CONSTRAINT: This function must use the correspondence of
// enumeration values like NORTH to integers to access elements from
// the global arrays direction_compact_strs[] and
// direction_verbose_strs[]. Code that utilizes long-winded
// conditional cases here will lose large quantities of style points.
//
// EXAMPLE:
// tile_t src = {.path_len = 4,  .path = {NORTH, EAST, EAST, SOUTH} }; 
// tile_print_path(&amp;tile, PATH_FORMAT_COMPACT);
// printf("\n");
//   NEES
// tile_print_path(&amp;tile, PATH_FORMAT_VERBOSE);
//   path length: 4
//     0: NORTH
//     1: EAST
//     2: EAST
//     3: SOUTH
//
// NOTES: This function will be short, less than 30 lines.  It should
// not have conditional structures that decide between NORTH, SOUTH,
// etc. Rather, use an access pattern like the following to "look up"
// the string that is needed in a given case.
// 
//   direction_t d = path[i];
//   char *dirstr = direction_verbose_strs[d];
//   printf("%s\n",dirstr);
// 
// Or more compactly
// 
//   printf("%s\n", direction_verbose_strs[path[i]]);
// 
// Handling a multipart conditional using an array of data like this
// is an elegant technique that proficient codes seek to use as often
// as possible.

void tile_extend_path(tile_t *src, tile_t *dst, direction_t dir);
// PROBLEM 2: Fills in the path/path_len fields of `dst` based on
// arriving at it from the `src` tile via `dir`.  Heap-allocates a
// direction_t array for the path in dst that is one longer than the
// path in src. Copies all elements from the `src` path to `dst`. Adds
// `dir` as the final element of the path in `dst`. This function is
// used when a new tile is found during BFS to store the path used to
// locate it from the starting point.
// 
// EXAMPLE:
// tile_t src = {.path_len = 4,  .path = {NORTH, EAST, EAST, SOUTH} }; 
// tile_t dst = {.path_len = -1, .path = NULL };
// tile_extend_path(&amp;src, &amp;dst, EAST);
// dst is now   {.path_len = 5,  .path = {NORTH, EAST, EAST, SOUTH, EAST} }; 
//
// NOTES: This function will need to access fields of the
// tiles. Review syntax to do so.

maze_t *maze_allocate(int rows, int cols);
// PROBLEM 2: Allocate on the heap a maze with the given rows/cols.
// Allocates space for the maze struct itself and an array of row
// pointers for its tiles. Then uses a nested set of loops to allocate
// each row of tiles for the maze and initialize the fields of each
// tile to be NOTSET, NOTFOUND, NULL, and -1 appropriately. Sets
// start/end row/col fields to be -1 and the queue to be NULL
// initially. Returns the resulting maze.
//
// CONSTRAINT: Assumes malloc() succeeds and does not include checks
// for its failure. Does not bother with checking rows/cols for
// inappropriate values such as 0 or negatives.
//
// NOTES: Consult recent lab work for examples of how to allocate a 2D
// array using repeated malloc() calls and adapt that approach
// hear. Ensure that the allocation is being done via rows of tile_t
// structs. Common errors are to neglect initializing all fields of
// the maze and all fields of every tile.  Valgrind errors that data
// is uninitialized are usually resolved by adding code to explicitly
// initialize everything.

void maze_free(maze_t *maze);
// PROBLEM 2: De-allocates the memory associated with a maze and its
// tiles.  Uses a doubly nested loop to iterate over all tiles and
// de-allocate any non-NULL paths that are part of the tiles.
// Iterates to free each row of the tiles row and frees then frees the
// array of row tile row pointers. If the queue is non-null, frees it
// and finally frees the maze struct itself.

int maze_tile_blocked(maze_t *maze, int row, int col);
// PROBLEM 2: Return 1 if the indicated coordinate is blocked and
// could not be traversed as part of a path solving a maze. A
// coordinate is blocked if it is out of bounds for the maze (row/col
// below zero or above maze row/col boundaries) or the tile at that
// coordinate has type WALL. If the coordinate is not blocked, returns
// 0.  This function will be used later during the
// Breadth-First-Search to determine if a coordinate should be ignored
// due to being blocked.
//
// NOTES: This function will require accessing fields of the maze so
// review syntax on struct field acces and 2D indexing into the maze's
// tiles table. The tiletype_t enumeration in mazesolve.h establishes
// global symbols for tile types like OPEN, ONPATH, START, and so
// forth. Use one of these in this function.

void maze_print_tiles(maze_t *maze);
// PROBLEM 2: Prints `maze` showing the solution path from Start to
// End tiles. First prints maze information including the size in rows
// and columns and the coordinates of Start/End tiles. The prints out
// the maze tiles with each tile printed based on its type. The character
// to print for each tile is based on its type and corresponds to
// elements in the global tiletyp_chars[] array: if the type is WALL,
// prints the character at tiletype_char[WALL]. This function is used
// to print a maze loaded from a file and print the solution path
// after doing a BFS.
//
// EXAMPLE 1: Output for maze which does not yet have a solution so no
// tiles have state ONPATH
// 
// maze: 7 rows 16 cols
//       (1,1) start
//       (3,8) end
// maze tiles:
// ################
// #S             #
// # ### ###### # #
// # ### ##E  #   #
// # ### #### ##  #
// #              #
// ################
// 
// EXAMPLE 2: The same maze above where some tiles have been marked
// with ONPATH as a solution has been calcualted via BFS. The ONPATH
// tiles are printed with . characters specified in the
// tiletype_chars[] global variable.
// 
// maze: 7 rows 16 cols
//       (1,1) start
//       (3,8) end
// maze tiles:
// ################
// #S             #
// #.### ###### # #
// #.### ##E..#   #
// #.### ####.##  #
// #..........    #
// ################

void maze_print_state(maze_t *maze);
// PROBLEM 2: Prints the `maze` in a format that shows its state and
// progress during the BFS search from Start to End positions.  The
// 2D grid of tiles is printed with tile with state FOUND printing a
// single character representaion of its distance from the Start tile
// and all other tiles with state NOTFOUND printing a single character
// that is based on their type (e.g. spaces for OPEN tiles, # for WALL
// tiles, etc). The `maze` queue is also printed using the previously
// written rcqueue_print() function for output.
//
// FOUND tiles will print their distance as a single character per one
// of two cases so that compact be reasonably complete information
// about its distance from the Start tile is shown.
//
// - If the tile's path_len field is NOT divsible by 10, then print
//   the last digit of the path_len (e.g. divide path_len by 10 and
//   take remainder
//
// - If the tiles' path_len IS divisible by 10, print the single
//   character at index (path_len)/10 in the global string
//   digit10_chars[]. These will show 'a' for 10, 'b' for 20, 'c' for
//   30, and so on.
//
// To the right of each maze row print a ": &lt;row#&gt;". Below the maze,
// print two lines: the first a sequence of "01234..890123..." up to
// the number of columns and below that a "tens" digits (0, 1, 2, etc
// printed every 10 characters). The combin combination of row and
// column axis label numbers makes it easier to find a tile at a
// specific coordinate.
//
// This function is used during BFS to show progress of the algorithm
// in a step-by-step manner when logging of BFS steps is enabled.
//
// CONSTRAINT 1: You must provide comments in this function that guide
// a reader on what different blocks and in some cases specific lines
// do. Comments like "print the bottom axis labels" or "tile not
// found, print its normal character" are informative. Comments like
// "print" or "assign tile" are not informative.
//
// CONSTRAINT 2: This function must avoid "many-case" conditionals
// such as if/else an switches based on the tile type or path_len. Use
// the provided global arrays digit10_chars[] and tiletype_chars[] to
// avoid such many-case conditionals.
//
// EXAMPLE: A 7x16 maze printed after a series of BFS steps.  
//
// 0         1     
// 0123456789012345
// ################: 0
// #0123456789a123#: 1
// #1###5######2#4#: 2
// #2###6##E  #34 #: 3
// #3###7####4##  #: 4
// #456789a1234   #: 5
// ################: 6
// queue count: 4
// NN ROW COL
//  0   4  10
//  1   5  11
//  2   3  13
//  3   2  14
//
// EXAMPLE NOTES: The End tile E at (3,8) has not been found yet so is
// drawn with an E while the Start tile at (1,1) is FOUND so is drawn
// with a 0 (path_len 0 from the Start). Some tiles like the WALL
// tiles marked with # are never FOUND as they are blocked and some
// OPEN tiles have not been FOUND yet so are draw with a space. Some
// FOUND tiles have 'a' in them indicating their path is 10 long from
// the Start tile. The 'a' is taken from the digits10_chars[] array.

////////////////////////////////////////////////////////////////////////////////
// FUNCTIONS FOR PROBLEM 3: Breadth First Search of the Maze
////////////////////////////////////////////////////////////////////////////////

void maze_bfs_init(maze_t *maze);
// PROBLEM 3: Initializes the maze for a BFS search. Adjusts the start
// tile: allocates it a length 0 path, sets its path_len to 0, and
// sets its state to FOUND. Allocates an empty rcqueue for the queue
// in the maze using an appropriate function and then adds the Start
// tile to it.
//
// LOGGING: If LOG_LEVEL &gt;= LOG_BFS_STATES, after initialization is
// complete. prints "BFS initialization compelte" and calls
// maze_print_state().
//
// NOTES: This function is called within maze_bfs_iterate() to set up
// the queue and Start tile before the search proceeds. It should not
// be called outside of that context except during some testing of its
// functionality and that of the BFS step function.
//
// EXAMPLE: The queue is initially empty (prints as null). After
//          calling bfs_init(), the Start tile is set to FOUND so
//          prints as its path_len of 0 and appears in the now
//          allocated queue.
//
// print_maze_state(maze);
//   ################:  0
//   #S             #:  1
//   # ### ###### # #:  2
//   # ### ##E  #   #:  3
//   # ### #### ##  #:  4
//   #              #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   null queue
// LOG_LEVEL = LOG_ALL;
// maze_bfs_init(maze);
// print_maze_state(maze);
//   LOG: BFS initialization complete
//   ################:  0
//   #0             #:  1
//   # ### ###### # #:  2
//   # ### ##E  #   #:  3
//   # ### #### ##  #:  4
//   #              #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 1
//   NN ROW COL
//    0   1   1

int maze_bfs_process_neighbor(maze_t *maze, int cur_row, int cur_col, direction_t dir);
// PROBLEM 3: Process the neighbor in direction `dir` from coordinates
// `cur_row/cur_col`. Calculates the adjacent tiles row/col
// coordinates using the row_delta[]/col_delta[] global array and
// `dir`.  If the neighbor tile is blocked according to the
// maze_tile_blocked() function, makes no changes and returns 0 as the
// position cannot be reached. If the neighbor tile has state FOUND,
// makes no changes and returns 0 as the tile has already been
// processed in the BFS. Otherwise changes the neighbor tile to be a
// Found tile: extends the current tile's path to the neighbor tile in
// the given direction, changes the neighbor tile's state to FOUND,
// and adds the neighbor tile to the maze search queue. This function
// is used in BFS to propogate paths to all non-blocked neighbor
// tiles and extend the search forntier.
//
// LOGGING:
// 1. If LOG_LEVEL &gt;= LOG_BFS_PATHS and the neighor tile's state
//    changes from NOTFOUND to FOUND, print a message like: 
//      LOG: Found tile at (4,10) with len 14 path: SSSSEEEEEEEEEN
//    with the coordinates, path_len, and COMPACT path for the newly
//    found tile.
// 2. If LOG_LEVEL &gt;= LOG_SKIPPED_TILES and the neighbor tile is
//    skipped as it is blocked or already found, print a message like
//    one of
//      LOG: Skipping BLOCKED tile at (6,13)
//      LOG: Skipping FOUND tile at (5,12)
//
// EXAMPLE:
// maze_print_state(maze);
//   ################:  0
//   #0123          #:  1
//   #1### ###### # #:  2
//   #2### ##E  #   #:  3
//   #3### #### ##  #:  4
//   #4             #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 2
//   NN ROW COL
//    0   1   4
//    1   5   1
// LOG_LEVEL = LOG_ALL; // above both LOG_BFS_PATHS and LOG_SKIPPED_TILES
// maze_bfs_process_neighbor(maze, 1, 4, NORTH);
//   LOG: Skipping BLOCKED tile at (0,4)
// maze_bfs_process_neighbor(maze, 1, 4, SOUTH);
//   LOG: Skipping BLOCKED tile at (2,4)
// maze_bfs_process_neighbor(maze, 1, 4, WEST);
//   LOG: Skipping FOUND tile at (1,3)
// maze_bfs_process_neighbor(maze, 1, 4, EAST);
//   LOG: Found tile at (1,5) with len 4 path: EEEE
// maze_print_state(maze);
//   ################:  0
//   #01234         #:  1
//   #1### ###### # #:  2
//   #2### ##E  #   #:  3
//   #3### #### ##  #:  4
//   #4             #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 2
//   NN ROW COL
//    0   1   4
//    1   5   1
//    2   1   5

int maze_bfs_step(maze_t *maze);
// PROBLEM 3: Processes the tile in BFS which is at the front of the
// maze search queue. For the front tile, iterates over the directions
// in the global dir_delta[] array from index DELTA_START to less than
// DELTA_COUNT which will be NORTH, SOUTH, WEST, EAST. Processes the
// neighbors in each of these directions with an appropriate
// function. Removes the front element of the search queue and
// returns 1. Note: if this function is called when the maze queue is
// empty, return 0 and print an error message though this case will
// not be tested and should not arise if other parts of the program
// are correct.
//
// LOGGING: 
// If LOG_LEVEL &gt;= LOG_BFS_STEPS, print a message like
//   LOG: processing neighbors of (5,1)
// at the start of the function.
//
// If LOG_LEVEL &gt;= LOG_BFS_STEPS, prints a message and uses
// maze_print_state() at the end of the function to show the maze
// after processing finishes as in:
//   LOG: maze state after BFS step
//   ################:  0
//   #01234         #:  1
//   #1### ###### # #:  2
//   #2### ##E  #   #:  3
//   #3### #### ##  #:  4
//   #45            #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 2
//   NN ROW COL
//    0   1   5
//    1   5   2
//
// EXAMPLE:
// maze_print_state(maze);
//   ################:  0
//   #0123456789a1  #:  1
//   #1###5###### # #:  2
//   #2###6##E  #   #:  3
//   #3###7#### ##  #:  4
//   #456789a12     #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 2
//   NN ROW COL
//    0   1  12
//    1   5   9
// LOG_LEVEL = LOG_ALL;
// maze_bfs_step(maze);
//   LOG: processing neighbors of (1,12)
//   LOG: maze state after BFS step
//   ################:  0
//   #0123456789a12 #:  1
//   #1###5######2# #:  2
//   #2###6##E  #   #:  3
//   #3###7#### ##  #:  4
//   #456789a12     #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 3
//   NN ROW COL
//    0   5   9
//    1   2  12
//    2   1  13

void maze_bfs_iterate(maze_t *maze);
// PROBLEM 3: Initializes a BFS on the maze and iterates BFS steps
// until the queue for the maze is empty and the BFS is complete. Each
// iteration of the algorithm loop will process all neighbors of a
// FOUND tile.  This will calculate paths from the Start tile to all
// other tiles including the End tile.
//
// LOGGING: If LOG_LEVEL &gt;= LOG_BFS_STEPS prints the step number for
// each iteration of the loop as
//   LOG: BFS STEP 45
// where the number starts at 1 and increases each loop iteration.
//
// See EXAMPLES for main() to get an idea of output for iteration.
//
// NOTES: This function will call several of the preceding functions
// to initialize and proceed with the BFS.

int maze_set_solution(maze_t *maze);
// PROBLEM 3: Uses the path stored in the End tile to visit each tile
// on the solution path from Star to End and make them as ONPATH to
// show the solution path.  If the End tile has a NULL path, returns 0
// and makes no changes to the maze. Otherwise, visits each direction
// in the End tile's path and, beginning at the Start tile, "moves" in
// the direction indicated and chcnges the nextf tile's state to
// ONPATH. Returns 1 on changing the state of tiles to show the
// solution path.  This function is used to set up printing the
// solution path later.
//
// CONSTRAINT: Makes use of the row_delta[] / col_delta[] global
// arrays when "moving" rather than using multi-way conditional. For
// example, if the current coordinates are (3,5) and the path[i]
// element is WEST, uses row_delta[WEST] which is -1 and
// col_delta[WEST] which is 0 to update the coordinates to (3,4) which
// is one tile to the WEST. Solutions that use a multi-way conditional
// with cases for NORTH, SOUTH, etc. will be penalized.
//
// NOTE: This function may temporarily change the state of the END
// tile to ONPATH as indicated in the log messages below. Before
// finishing, the state of the END tile is changed from ONPATH to END.
// 
// LOGGING: If the LOG_LEVEL &gt;= LOG_SET_SOLUTION, prints out 
// 
// 1. Once at the beginning of the solution construction
//   LOG: solution START at (1,1)
// with the coordinates substituted for the actual START coordinates.
// 
// 2. For every element of the End tile path[] array
//   LOG: solution path[5] is EAST, set (5,3) to ONPATH
// with items like the index, direction, and coordinates replaced with
// appropriate data via printf().  Use the direction_verbose_strs[]
// to print strings of the directions.
//
// 3. Once at the end of solution construction:
//   LOG: solution END at (3,8)
// with the coordinates substituted for the actual END coordinates.
// 
// EXAMPLE:
// maze_print_tiles(maze);
//   maze: 7 rows 16 cols
//         (1,1) start
//         (3,8) end
//   maze tiles:
//   ################
//   #S             #
//   # ### ###### # #
//   # ### ##E  #   #
//   # ### #### ##  #
//   #              #
//   ################
// 
// LOG_LEVEL = LOG_SET_SOLUTION;
// maze_set_solution(maze);
//   LOG: solution START at (1,1)
//   LOG: solution path[0] is SOUTH, set (2,1) to ONPATH
//   LOG: solution path[1] is SOUTH, set (3,1) to ONPATH
//   LOG: solution path[2] is SOUTH, set (4,1) to ONPATH
//   LOG: solution path[3] is SOUTH, set (5,1) to ONPATH
//   LOG: solution path[4] is EAST, set (5,2) to ONPATH
//   LOG: solution path[5] is EAST, set (5,3) to ONPATH
//   LOG: solution path[6] is EAST, set (5,4) to ONPATH
//   LOG: solution path[7] is EAST, set (5,5) to ONPATH
//   LOG: solution path[8] is EAST, set (5,6) to ONPATH
//   LOG: solution path[9] is EAST, set (5,7) to ONPATH
//   LOG: solution path[10] is EAST, set (5,8) to ONPATH
//   LOG: solution path[11] is EAST, set (5,9) to ONPATH
//   LOG: solution path[12] is EAST, set (5,10) to ONPATH
//   LOG: solution path[13] is NORTH, set (4,10) to ONPATH
//   LOG: solution path[14] is NORTH, set (3,10) to ONPATH
//   LOG: solution path[15] is WEST, set (3,9) to ONPATH
//   LOG: solution path[16] is WEST, set (3,8) to ONPATH
//   LOG: solution END at (3,8)
// 
// maze_print_tiles(maze);
//   maze: 7 rows 16 cols
//         (1,1) start
//         (3,8) end
//   maze tiles:
//   ################
//   #S             #
//   #.### ###### # #
//   #.### ##E..#   #
//   #.### ####.##  #
//   #..........    #
//   ################

////////////////////////////////////////////////////////////////////////////////
// FUNCTIONS FOR PROBLEM 4: Maze Memory Allocation and File Input
////////////////////////////////////////////////////////////////////////////////

maze_t *maze_from_file(char *fname);
// PROBLEM 4: Read a maze from a text file. The text file format
// starts with the size of the maze and then contains its tiles. An
// example is:
//
// rows: 7 cols: 19
// tiles:
// ###################
// #          #    # #
// # ###  ##    ## # #
// #  ##  # S #  # # #
// ##  #  #####  # # #
// #E  #         #   #
// ###################   
//
// If `fname` cannot be opened as a file, returns NULL. Otherwise
// proceeds to read row/col numbers, allocate a maze of appropriate
// size, and read characters into it. Each tile read has its state
// changed per the character it is shown as. The global array
// tiletype_chars[] should be searched to find the character read for
// a tile and the index at which it is found set to be the tile state;
// e.g. the character 'S' was read which appears at index 4 of
// tiletype_chars[] so the tile.type = 4 which is START in the
// tiletype enumeration.
//
// CONSTRAINT: You must use fscanf() for this function. 
//
// CONSTRAINT: You MUST comment your code to describe the intent of
// blocks of code. Full credit comments will balance some details with
// broad descriptions of blocks of code.  Missing comments or pedantic
// comments which describe every code line with unneeded detail will
// not receive full credit. Aim to make it easy for a human reader to
// scan your function to find a specific point of interest such as
// where a tile type is determined or when a row is finished
// processing. Further guidance on good/bad comments is in the C
// Coding Style Guide.
//
// LOGGING: If LOG_LEVEL &gt;= LOG_FILE_LOAD prints messages to help
// track parsing progress. There are many log messages required as
// they will be useful for debugging parsing problems that always
// arise when reading such data.
//
// LOG: expecting 6 rows and 9 columns
//   Printed after reading the first line indicating rows/cols in the
//   maze.
//
// LOG: beginning to read tiles
//   Printed after reading the "tiles\n" line when the main loop is
//   about to start reading character/tiles.
//
// LOG: (2,1) has character ' ' type 2
//   Printed with the coordinates of each character/tile that is
//   read. The coordinates, character read, and an integer indicating
//   the type decided upon for the tile is shown.
//
// LOG: (2,4) has character 'S' type 4
// LOG: setting START at (2,4)
//   Printed when the Start tile, marked with an S, is found
//
// LOG: (3,7) has character 'E' type 5
// LOG: setting END at (3,7)
//   Printed when the End tile, marked with an E, is found
//
// LOG: finished reading row 4 of tiles
//   Printed after reading each row of the maze file to help track
//   progress.
//
// NOTES: The fscanf() function is essential for this function. A call
// like fscanf(fin,"age: %d name: %s\n",&amp;num, str) will read the literal
// word "age:" then a number, then the literal word "name:" and a
// string.  Use this facility to parse the simple format. It is fine
// to read a literal string only as in fscanf(fin,"skip this stuff\n")
// which will bypass that exact line in a file.  Use the format
// specifier %c to read single characters as you process the tiles as
// this is the easiest mechanism to work on the character parsing of
// the maze tiles.  Keep in mind that all lines of the maze will end
// with the character '\n' which must be read past in order to get to
// the next row.

int main(int argc, char *argv[]);
// PROBLEM 4: main() in mazesolve_main.c
//
// The program must support two command line forms.
// 1. ./mazesolve_main &lt;mazefile&gt;
// 2. ./mazesolve_main -log &lt;N&gt; &lt;mazefile&gt;
// Both forms have a maze data file as the last command line
// argument. The 2nd form sets the global variable LOG_LEVEL to the
// value N which enables additional output.
//
// NOTES
// - It is a good idea to check that the number of command line arguments
//   is either 2 (Form 1) and 4 (Form 2) and if not, bail out from the
//   program. This won't be tested but it simplifies the rest of the
//   program.
// - All command line arguments come into C programs as strings
//   (char*).  That means the number after the -log option will also
//   be a string of characters and needs to be converted to an int to
//   be used in the program.  The atoi() function is useful for this:
//   search for documentation on it and use it for the conversion.
// - Make sure to check that loading a maze from a file succeeds. If
//   not, print the following error message: 
//     Could not load maze file. Exiting with error code 1
//   This message is in addition to the error message that is printed
//   byt he maze_from_file() function. Return 1 from main() to indicate
//   that the program was not successful.
// - If a maze is successfully loaded, perform a BFS on it using
//   appropriate functions. Don't forget to free its memory before
//   ending the program.
</pre>
</div>
</div>

<div id="outline-container-org2db9a1c" class="outline-3">
<h3 id="org2db9a1c"><span class="section-number-3">4.1</span> Getting Started</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Create the file <code>mazesolve_funcs.c</code>. Copy the code outline above into
the C file to serve as a starting point for the project. Filling in
dummy bodies (e.g. <code>return 0</code> or <code>return NULL</code> etc.) will allow the
Automated Tests to run after which one can begin filling in
definitions for the functions according to the provided specification.
</p>

<p>
For the most part, try to solve functions in the order that they
appear in the code outline as later functions will use earlier
functions. If you do get stuck on a function, don't be afraid to move
on momentarily to keep your momentum up.
</p>
</div>
</div>

<div id="outline-container-org61b6d95" class="outline-3">
<h3 id="org61b6d95"><span class="section-number-3">4.2</span> The Dev Cycle</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-orgad6f2d8" class="outline-4">
<h4 id="orgad6f2d8">To complete the project</h4>
<div class="outline-text-4" id="text-orgad6f2d8">
<ul class="org-ul">
<li>Read documentation on a required function</li>
<li>Write part of the implementation</li>
<li>Run test cases associated with function</li>
<li>Analyze the results</li>
<li>Consult docs on the function for clarification</li>
<li>Add <code>printf()</code> statements to show debug information</li>
<li>Repeat the above until all tests for the function pass</li>
<li>Consult the MANUAL INSPECTION criteria to ensure your style and
functionality meet their requirements</li>
<li>Repeat for the next function</li>
</ul>
</div>
</div>

<div id="outline-container-orga25fadf" class="outline-4">
<h4 id="orga25fadf">When stuck on a bug for an Extended period (1+ hour)</h4>
<div class="outline-text-4" id="text-orga25fadf">
<ul class="org-ul">
<li>Search for related examples from Labs / HWs / Lectures</li>
<li>Ask for help on Piazza or visit office hours</li>
<li>Take a break and come back after recovering some mental energy</li>
<li><i>Stay Determined!</i></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org4790d72" class="outline-2">
<h2 id="org4790d72"><span class="section-number-2">5</span> <b>Problem 1</b>: Row/Col Queue</h2>
<div class="outline-text-2" id="text-5">
<p>
This problem is a "warm-up" that will implement a standard Queue data
structure using linked nodes. The data tracked in the queue are
row/column coordinates that should be processed later during a
BFS. Students are expected to have seen and implemented queues like
this before in other programming environments and are expected to have
gained familiarity with linked nodes from previous labs/HWs in this
course so the problem should not be difficult. It is a chance to
practice the basic "Dev Cycle" on familiar ground before moving to the
more complex tasks later.
</p>
</div>

<div id="outline-container-org86b1710" class="outline-3">
<h3 id="org86b1710"><span class="section-number-3">5.1</span> Queue Data Types</h3>
<div class="outline-text-3" id="text-5-1">
<p>
The central data types associated with the queue appear in
<code>mazesolve.h</code> near the top.
</p>

<div class="org-src-container">
<pre class="src src-c">// rcqueue_t data
////////////////////////////////////////////////////////////////////////////////
typedef struct rcnode {         // node type for row/col queues
  int row, col;                 // row/col coordinates for the node
  struct rcnode *next;          // pointer to next node
} rcnode_t;

typedef struct {                // queue type for row/col coordinates
  rcnode_t *front, *rear;       // pointers to ends of queue
  int count;                    // number of nodes in queue
} rcqueue_t;

////////////////////////////////////////////////////////////////////////////////
</pre>
</div>

<p>
These data structures will be manipulated by the required functions.
</p>
</div>
</div>

<div id="outline-container-org52c98a9" class="outline-3">
<h3 id="org52c98a9"><span class="section-number-3">5.2</span> Required Queue Functions</h3>
<div class="outline-text-3" id="text-5-2">
<p>
These functions all start with <code>rcqueue_</code> and preform the basic
operations expected for queues: adding elements to the rear of the
queue, removing elements from the front, and accessing the front
element. Some queue implementations merge the access/remove front
element however in this situation the operations are distinct:
</p>
<ul class="org-ul">
<li><code>rcqueue_get_front()</code> sets a pair of row/col integers based on the
row/col at the front of the queue; if the queue is empty, the
function does nothing.</li>
<li><code>rcqueue_remove_front()</code> removes the front queue element for
non-empty queues and does nothing to empty queues.</li>
</ul>
<p>
The queue completed in this problem will be used later to facilitate
the Breadth First Search of the maze (Problem 3).
</p>

<div class="org-src-container">
<pre class="src src-c">// FUNCTIONS FOR PROBLEM 1: Row/Col Queue
////////////////////////////////////////////////////////////////////////////////

rcqueue_t *rcqueue_allocate();
// PROBLEM 1: Create a new queue of row/col coordinates that is
// empty. Heap-allocate the queue and return a pointer to
// it. Initialize all fields of the queue struct to indicate its
// emptiness. 
//
// CONSTRAINTS: When allocating heap memory, assume calls to malloc()
// succeed and avoid checks to determine if memory allocation failed.

void rcqueue_add_rear(rcqueue_t *queue, int row, int col);
// PROBLEM 1: Add the given row/col coordinates at the end of the
// queue.  Allocates a new node for the coordinates and links this in
// at the end of the queue.
//
// NOTES: The first addition to an empty queue usually requires
// special handling that is different from than subsequent
// additions. Make sure to check for this case. If you see
// Segmentation Faults when running tests, examine the line numbers
// closely, check what the test was evaluating, and trace the
// execution mentally or via debug printing to find the problem.

void rcqueue_free(rcqueue_t *queue);
// PROBLEM 1: De-allocate the memory associated with `queue`. If it is
// non-empty, remove all elements from it de-allocating their nodes
// before free()'ing the queue struct itself.

int rcqueue_get_front(rcqueue_t *queue, int *rowp, int *colp);
// PROBLEM 1: Retrieve the front element of the queue but do not
// otherwise change the queue.  If the queue is empty, immediately
// returns 0.  Otherwise, the pointers rowp and colp are dereferenced
// and set to be the row/col in the front node in the queue and 1 is
// returned to indicate that the rowp/colp have been set.

int rcqueue_remove_front(rcqueue_t *queue);
// PROBLEM 1: Removes the front node of the queue. If the queue is
// empty, immediately returns 0 to indicate the queue is
// unchanged. Otherwise, advances the front pointer of the queue to
// the next node in the queue and the de-allocates the node which was
// previously at the front. Adjusts the count of nodes in the
// queue. Returns 1 to indicate the queue has changed.
//
// CONSTRAINT: This should be a constant time O(1) operation.
// CONSTRAINT: When the queue is empty, BOTH front/rear should be NULL.

void rcqueue_print(rcqueue_t *queue);
// PROBLEM 1: Prints a table of the current queue contents to standard
// out using printf(). The output should look like the following.
//
// queue count: 3
// NN ROW COL
//  0   4   5
//  1   1   8
//  2   5   5
// 
// The first line is the plain text "queue count: " followed by the
// count of nodes in the queue. The next line is a header with 
// Node Number (NN), Row, and Col for columns with remaining lines
// showing data for each node. Each line of this output is printed
// with numbers right-aligned with a field width of 2 characters for
// node numbers and 3 characters for row/col coordinates.
//
// If `queue` is NULL, print the string "null queue\n" instead.
//
// NOTES: Research the capabilities of printf() to print data in a
// specific field width. A usage like printf("%3d",number) will be
// useful in a situation like this to line up table entries.

////////////////////////////////////////////////////////////////////////////////

</pre>
</div>
</div>
</div>

<div id="outline-container-org6242aa1" class="outline-3 grading 20">
<h3 id="org6242aa1"><span class="section-number-3">5.3</span> Grading Criteria for Problem 1&#xa0;&#xa0;&#xa0;<span class="tag"><span class="grading">grading</span>&#xa0;<span class="20">20</span></span></h3>
<div class="outline-text-3" id="text-5-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-left">Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">AUTOMATED TESTS via <code>make test-prob1</code></td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">Runs tests in <code>test_mazesolve1.org / test_mazesolve_funcs.c</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Runs all code under Valgrind to ensure that no memory errors are present.</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">1 point per test passed</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">MANUAL INSPECTION</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><a href="https://docs.google.com/document/d/1V6W1GBcL2cgOoiIeaz5V83U3BUbfK7wqYia71i0AeXQ/edit?usp=sharing">Code Style</a>: Functions adhere to <a href="https://docs.google.com/document/d/1V6W1GBcL2cgOoiIeaz5V83U3BUbfK7wqYia71i0AeXQ/edit?usp=sharing">CMSC 216 C Coding Style Guide</a> which dictates</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">reasonable indentation, commenting, consistency of curly usage, etc.</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left"><code>rcqueue_allocate() / rcqueue_add_rear()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Correct use of <code>malloc() / sizeof()</code> to allocate space for queue / nodes</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of "arrow" syntax when accessing fields of pointer to a struct</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Correct initialization / update of fields when allocating</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left"><code>rcqueue_get_front() / rcqueue_remove_front()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of pointer dereference operation when setting pointers to "settable" arguments</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Correct de-allocation using <code>free()</code> when unlinking nodes</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left"><code>rcqueue_print()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Checks present of cases for NULL vs non-NULL queue</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of <code>printf()</code> with width in format specifiers like <code>%3d</code> to format output</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clean code that iterates through the queue printing each element</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-org2212ff2" class="outline-2">
<h2 id="org2212ff2"><span class="section-number-2">6</span> <b>Problem 2</b>: Tile/Maze Functions</h2>
<div class="outline-text-2" id="text-6">
<p>
This problem introduces the Tile and Maze data types used in the
project and implements some basic functionality for them.
</p>
</div>

<div id="outline-container-orgbddea14" class="outline-3">
<h3 id="orgbddea14"><span class="section-number-3">6.1</span> Tile/Maze Data Types</h3>
<div class="outline-text-3" id="text-6-1">
<p>
The two central structs for representing program are
</p>
<ul class="org-ul">
<li><b>tile<sub>t</sub></b> which store information about a single coordinate in the
maze, whether it is a Wall, Open, Start etc. and whether it has been
processed during the BFS</li>
<li><b>maze<sub>t</sub></b> which maintains a 2D array of tiles along with global
information such as the location of the start/end tiles and the
queue of row/col coordinates to search.</li>
</ul>
<p>
These two structs are defined in the project header. 
</p>

<div class="org-src-container">
<pre class="src src-c">// tile and maze data
////////////////////////////////////////////////////////////////////////////////
typedef struct {                // tile data for positions in a 2D maze
  tiletype_t type;              // One of NOTSET, OPEN, WALL, ONPATH, START, END
  searchstate_t state;          // One of NOT_FOUND, QUEUED, DONE
  direction_t *path;            // array of directions from start to this position
  int path_len;                 // length of path array
} tile_t;

typedef struct {                // maze data tracking shape of maze and state of BFS search
  tile_t **tiles;               // 2D array of tiles
  int rows, cols;               // number of rows/cols in the 2D tile array
  int start_row, start_col;     // starting position in the maze
  int end_row, end_col;         // ending position in the maze
  rcqueue_t *queue;             // queue of coordinates to search
} maze_t;

////////////////////////////////////////////////////////////////////////////////
</pre>
</div>

<p>
Note the <code>tiles</code> field of <code>maze_t</code> is a doubly indirected pointer: it
will be used to access tiles via 2 array indices like
<code>maze-&gt;tiles[5][3]</code> for row 5 column 3.
</p>

<p>
Some of the fields in of <code>tile_t</code> have their own types which are
discussed in the next section on Enumerations.
</p>
</div>
</div>

<div id="outline-container-org9ddd801" class="outline-3">
<h3 id="org9ddd801"><span class="section-number-3">6.2</span> Enumerations in C</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The C language provides <b>Enumerations</b> which are fixed set of
symbolically named values usually encoded as integers. Enumerations
are used when a programmer wants to give human-readable names to
finite set of items and get efficient storage/operations on those
items.  Below are enumerations that appear the project header that
are used to represent a limited set of value appropriate to 3
situations.
</p>
<ol class="org-ol">
<li><b>Directions</b>: the 2D grid allows for only 4 movement directions
which are labeled in the <code>direction_t</code> enumeration</li>
<li><b>Tile Types</b>: tiles in the maze come in a limited set of types
which such as Walls and Open positions.</li>
<li><b>Tile Search State</b>: tiles are "found" during the BFS which begins
at the Start tile. At any time during BFS, some tiles are Found
while others are Notfound.</li>
</ol>
<div class="org-src-container">
<pre class="src src-c">// tile enumerations
////////////////////////////////////////////////////////////////////////////////
typedef enum {                  // allowable directions for neighbors
  NONE = 0,                     // NONE should not be used
  NORTH,                        // Same as integer 1
  SOUTH,                        // Same as integer 2
  WEST,                         // Same as integer 3
  EAST,                         // Same as integer 4
} direction_t;
// EXAMPLE USE:
// direction_t dirs[5] = {NORTH, WEST, WEST, SOUTH, SOUTH};
// char *str = direction_verbose_strs[WEST];

typedef enum {                  // types of supported tiles
  NOTSET = 0,                   // NOTSET should not be used
  WALL,                         // cannot be traversed, display as '#'
  OPEN,                         // can be traversed, display as a space ' '
  ONPATH,                       // part of shortest path from Start to End, '.'
  START,                        // starting tile, display as 'S'
  END,                          // ending tile, display as 'E'
} tiletype_t;
// EXAMPLE USE:
// tile_t tile;
// tile.type = OPEN;
// char display = tiletype_chars[WALL];

typedef enum {                  // type used during BFS to track found iles
  UNKNOWN   = 0,                // UNKNOWN should not be used
  NOTFOUND,                     // tile has not yet be found during BFS
  FOUND                         // tile has been found during BFS and has its path set
} searchstate_t;
// EXAMPLE USE:
// tile_t tile;
// tile.state = NOTFOUND;

////////////////////////////////////////////////////////////////////////////////
</pre>
</div>

<p>
As the syntax indicates, enumerations can be set up in a similar
fashion to a struct definitions via the <code>typedef</code> C construct.
</p>

<p>
<b>Creating enumerations establishes a global symbol for each value in
the enumeration.</b> For example, the global symbol <code>NORTH</code> is now
available to assign to variables of type <code>direction_t</code> as the examples
show. 
</p>

<p>
Beneath each enumeration is an example of using the enumerations. C
does not disguise the fact that enumerations are usually encoded as an
integral type so have a number associated with them. This appears in
the enumeration definitions where the initial element is dictated as
having equivalent value 0. It is also exploited in several of the
examples which show that the enumeration value can be used as an index
into arrays, a useful trick which coders will employ in some parts of
this problem.
</p>

<p>
Enumerations are useful as they allow the compiler to do a little bit
of type checking. Assigning an enumeration value to another type of
variable may cause the compiler to issue a warning or error. This is
often more useful than equivalent alternative mechanisms to setting up
global symbols for numbers such as can be done with the <code>#define</code>
mechanism also shown in the header.
</p>
</div>
</div>

<div id="outline-container-orgfa71ab0" class="outline-3">
<h3 id="orgfa71ab0"><span class="section-number-3">6.3</span> Provided Data</h3>
<div class="outline-text-3" id="text-6-3">
<p>
There is some provided data at the top of outline of
<code>mazesolve_funcs.c</code> which includes some provided data at the top which
can and should be used in the completion of the project. For example,
the first function in this problem will print "paths", arrays of
<code>direction_t</code> elements. The make this function flexible, two arrays
are provided which specify different formats for how <code>direction_t</code>
elements can be printed.
</p>
<div class="org-src-container">
<pre class="src src-c">// strings to print for compact directions
char *direction_compact_strs[5] = {
  "?",                          // NONE
  "N",                          // NORTH
  "S",                          // SOUTH
  "W",                          // WEST
  "E",                          // EAST
};
  
// strings to print for verbose directions
char *direction_verbose_strs[5] = {
  "NONE",                       // NONE
  "NORTH",                      // NORTH
  "SOUTH",                      // SOUTH
  "WEST",                       // WEST
  "EAST",                       // EAST
};
</pre>
</div>
<p>
The encoding of the enumeration value <code>NORTH</code> is integer 1. That
allows easy printing of a string corresponding to that value.
</p>
<div class="org-src-container">
<pre class="src src-c">{
  printf("NORTH integer: %d\n",NORTH);
  printf("NORTH compact string: %s\n", direction_compact_strs[NORTH]);
  printf("NORTH verbose string: %s\n", direction_verbose_strs[NORTH]);
}
// OUTPUT:
//   NORTH integer: 1
//   NORTH compact string: N
//   NORTH verbose string: NORTH
</pre>
</div>
</div>
</div>

<div id="outline-container-org2180e5a" class="outline-3">
<h3 id="org2180e5a"><span class="section-number-3">6.4</span> Required Tile/Maze Functions</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Tile functions are implemented first followed by maze functions. 
</p>
<ul class="org-ul">
<li>There are now tile allocation/de-allcoation functions. Rather, when
a maze is created, a 2D array of tiles is allocated as part of it.</li>
<li>Slightly more complex memory allocation is required in this
problem. Draw inspiration from lab work, especially for the 2D array
allocation in <code>maze_allocate()</code></li>
<li>The final function that prints the state of a maze during BFS is
somewhat involved and getting the output correct may take some
time. <i>Stay determined!</i></li>
</ul>

<div class="org-src-container">
<pre class="src src-c">// FUNCTIONS FOR PROBLEM 2: Tile and Maze Utility Functions
////////////////////////////////////////////////////////////////////////////////

void tile_print_path(tile_t *tile, int format);
// PROBLEM 2: Print the path field of `tile` in one of two formats. If
// the path field is NULL, print "No path found\n". Otherwise, if the
// `format` parameter is PATH_FORMAT_COMPACT, iterate over the path
// array and print each element as a string that comes from the global
// direction_compact_strs[] array without printing any newlines. If
// the `format` parameter is PATH_FORMAT_VERBOSE, print the length of
// the path on its own line then each element of the path with its
// index on its on line using strings from teh
// direction_verbose_strs[] global array. If the format is neither of
// COMPACT or VERBOSE, print an error message (not tested).
//
// CONSTRAINT: This function must use the correspondence of
// enumeration values like NORTH to integers to access elements from
// the global arrays direction_compact_strs[] and
// direction_verbose_strs[]. Code that utilizes long-winded
// conditional cases here will lose large quantities of style points.
//
// EXAMPLE:
// tile_t src = {.path_len = 4,  .path = {NORTH, EAST, EAST, SOUTH} }; 
// tile_print_path(&amp;tile, PATH_FORMAT_COMPACT);
// printf("\n");
//   NEES
// tile_print_path(&amp;tile, PATH_FORMAT_VERBOSE);
//   path length: 4
//     0: NORTH
//     1: EAST
//     2: EAST
//     3: SOUTH
//
// NOTES: This function will be short, less than 30 lines.  It should
// not have conditional structures that decide between NORTH, SOUTH,
// etc. Rather, use an access pattern like the following to "look up"
// the string that is needed in a given case.
// 
//   direction_t d = path[i];
//   char *dirstr = direction_verbose_strs[d];
//   printf("%s\n",dirstr);
// 
// Or more compactly
// 
//   printf("%s\n", direction_verbose_strs[path[i]]);
// 
// Handling a multipart conditional using an array of data like this
// is an elegant technique that proficient codes seek to use as often
// as possible.

void tile_extend_path(tile_t *src, tile_t *dst, direction_t dir);
// PROBLEM 2: Fills in the path/path_len fields of `dst` based on
// arriving at it from the `src` tile via `dir`.  Heap-allocates a
// direction_t array for the path in dst that is one longer than the
// path in src. Copies all elements from the `src` path to `dst`. Adds
// `dir` as the final element of the path in `dst`. This function is
// used when a new tile is found during BFS to store the path used to
// locate it from the starting point.
// 
// EXAMPLE:
// tile_t src = {.path_len = 4,  .path = {NORTH, EAST, EAST, SOUTH} }; 
// tile_t dst = {.path_len = -1, .path = NULL };
// tile_extend_path(&amp;src, &amp;dst, EAST);
// dst is now   {.path_len = 5,  .path = {NORTH, EAST, EAST, SOUTH, EAST} }; 
//
// NOTES: This function will need to access fields of the
// tiles. Review syntax to do so.

maze_t *maze_allocate(int rows, int cols);
// PROBLEM 2: Allocate on the heap a maze with the given rows/cols.
// Allocates space for the maze struct itself and an array of row
// pointers for its tiles. Then uses a nested set of loops to allocate
// each row of tiles for the maze and initialize the fields of each
// tile to be NOTSET, NOTFOUND, NULL, and -1 appropriately. Sets
// start/end row/col fields to be -1 and the queue to be NULL
// initially. Returns the resulting maze.
//
// CONSTRAINT: Assumes malloc() succeeds and does not include checks
// for its failure. Does not bother with checking rows/cols for
// inappropriate values such as 0 or negatives.
//
// NOTES: Consult recent lab work for examples of how to allocate a 2D
// array using repeated malloc() calls and adapt that approach
// hear. Ensure that the allocation is being done via rows of tile_t
// structs. Common errors are to neglect initializing all fields of
// the maze and all fields of every tile.  Valgrind errors that data
// is uninitialized are usually resolved by adding code to explicitly
// initialize everything.

void maze_free(maze_t *maze);
// PROBLEM 2: De-allocates the memory associated with a maze and its
// tiles.  Uses a doubly nested loop to iterate over all tiles and
// de-allocate any non-NULL paths that are part of the tiles.
// Iterates to free each row of the tiles row and frees then frees the
// array of row tile row pointers. If the queue is non-null, frees it
// and finally frees the maze struct itself.

int maze_tile_blocked(maze_t *maze, int row, int col);
// PROBLEM 2: Return 1 if the indicated coordinate is blocked and
// could not be traversed as part of a path solving a maze. A
// coordinate is blocked if it is out of bounds for the maze (row/col
// below zero or above maze row/col boundaries) or the tile at that
// coordinate has type WALL. If the coordinate is not blocked, returns
// 0.  This function will be used later during the
// Breadth-First-Search to determine if a coordinate should be ignored
// due to being blocked.
//
// NOTES: This function will require accessing fields of the maze so
// review syntax on struct field acces and 2D indexing into the maze's
// tiles table. The tiletype_t enumeration in mazesolve.h establishes
// global symbols for tile types like OPEN, ONPATH, START, and so
// forth. Use one of these in this function.

void maze_print_tiles(maze_t *maze);
// PROBLEM 2: Prints `maze` showing the solution path from Start to
// End tiles. First prints maze information including the size in rows
// and columns and the coordinates of Start/End tiles. The prints out
// the maze tiles with each tile printed based on its type. The character
// to print for each tile is based on its type and corresponds to
// elements in the global tiletyp_chars[] array: if the type is WALL,
// prints the character at tiletype_char[WALL]. This function is used
// to print a maze loaded from a file and print the solution path
// after doing a BFS.
//
// EXAMPLE 1: Output for maze which does not yet have a solution so no
// tiles have state ONPATH
// 
// maze: 7 rows 16 cols
//       (1,1) start
//       (3,8) end
// maze tiles:
// ################
// #S             #
// # ### ###### # #
// # ### ##E  #   #
// # ### #### ##  #
// #              #
// ################
// 
// EXAMPLE 2: The same maze above where some tiles have been marked
// with ONPATH as a solution has been calcualted via BFS. The ONPATH
// tiles are printed with . characters specified in the
// tiletype_chars[] global variable.
// 
// maze: 7 rows 16 cols
//       (1,1) start
//       (3,8) end
// maze tiles:
// ################
// #S             #
// #.### ###### # #
// #.### ##E..#   #
// #.### ####.##  #
// #..........    #
// ################

void maze_print_state(maze_t *maze);
// PROBLEM 2: Prints the `maze` in a format that shows its state and
// progress during the BFS search from Start to End positions.  The
// 2D grid of tiles is printed with tile with state FOUND printing a
// single character representaion of its distance from the Start tile
// and all other tiles with state NOTFOUND printing a single character
// that is based on their type (e.g. spaces for OPEN tiles, # for WALL
// tiles, etc). The `maze` queue is also printed using the previously
// written rcqueue_print() function for output.
//
// FOUND tiles will print their distance as a single character per one
// of two cases so that compact be reasonably complete information
// about its distance from the Start tile is shown.
//
// - If the tile's path_len field is NOT divsible by 10, then print
//   the last digit of the path_len (e.g. divide path_len by 10 and
//   take remainder
//
// - If the tiles' path_len IS divisible by 10, print the single
//   character at index (path_len)/10 in the global string
//   digit10_chars[]. These will show 'a' for 10, 'b' for 20, 'c' for
//   30, and so on.
//
// To the right of each maze row print a ": &lt;row#&gt;". Below the maze,
// print two lines: the first a sequence of "01234..890123..." up to
// the number of columns and below that a "tens" digits (0, 1, 2, etc
// printed every 10 characters). The combin combination of row and
// column axis label numbers makes it easier to find a tile at a
// specific coordinate.
//
// This function is used during BFS to show progress of the algorithm
// in a step-by-step manner when logging of BFS steps is enabled.
//
// CONSTRAINT 1: You must provide comments in this function that guide
// a reader on what different blocks and in some cases specific lines
// do. Comments like "print the bottom axis labels" or "tile not
// found, print its normal character" are informative. Comments like
// "print" or "assign tile" are not informative.
//
// CONSTRAINT 2: This function must avoid "many-case" conditionals
// such as if/else an switches based on the tile type or path_len. Use
// the provided global arrays digit10_chars[] and tiletype_chars[] to
// avoid such many-case conditionals.
//
// EXAMPLE: A 7x16 maze printed after a series of BFS steps.  
//
// 0         1     
// 0123456789012345
// ################: 0
// #0123456789a123#: 1
// #1###5######2#4#: 2
// #2###6##E  #34 #: 3
// #3###7####4##  #: 4
// #456789a1234   #: 5
// ################: 6
// queue count: 4
// NN ROW COL
//  0   4  10
//  1   5  11
//  2   3  13
//  3   2  14
//
// EXAMPLE NOTES: The End tile E at (3,8) has not been found yet so is
// drawn with an E while the Start tile at (1,1) is FOUND so is drawn
// with a 0 (path_len 0 from the Start). Some tiles like the WALL
// tiles marked with # are never FOUND as they are blocked and some
// OPEN tiles have not been FOUND yet so are draw with a space. Some
// FOUND tiles have 'a' in them indicating their path is 10 long from
// the Start tile. The 'a' is taken from the digits10_chars[] array.

////////////////////////////////////////////////////////////////////////////////

</pre>
</div>
</div>
</div>

<div id="outline-container-org38b759a" class="outline-3 grading 30">
<h3 id="org38b759a"><span class="section-number-3">6.5</span> Grading Criteria for Problem 2&#xa0;&#xa0;&#xa0;<span class="tag"><span class="grading">grading</span>&#xa0;<span class="30">30</span></span></h3>
<div class="outline-text-3" id="text-6-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-left">Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">AUTOMATED TESTS via <code>make test-prob2</code></td>
</tr>

<tr>
<td class="org-right">15</td>
<td class="org-left">Runs tests in <code>test_mazesolve5.org / test_mazesolve_funcs.c</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Runs all code under Valgrind to ensure that no memory errors are present.</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">1 point per test passed</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">MANUAL INSPECTION</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><a href="https://docs.google.com/document/d/1V6W1GBcL2cgOoiIeaz5V83U3BUbfK7wqYia71i0AeXQ/edit?usp=sharing">Code Style</a>: Functions adhere to <a href="https://docs.google.com/document/d/1V6W1GBcL2cgOoiIeaz5V83U3BUbfK7wqYia71i0AeXQ/edit?usp=sharing">CMSC 216 C Coding Style Guide</a> which dictates</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">reasonable indentation, commenting, consistency of curly usage, etc.</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left"><code>tile_print_path</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear case analysis for NULL path, compact, and verbose formats</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Uses the provided arrays of compact/verbose strings when printing directions</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of <code>printf()</code> format specifiers and width the nicely format output</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left"><code>tile_extend_path()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Proper use of <code>malloc()</code> to create a new memory space for the longer path</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of a loop or library function to copy memory from the old to the new space</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left"><code>maze_allocate()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Initialization of fields of maze to default values like -1 and NULL</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Allocation of tile row pointers and a loop to iterate and all rows of the maze</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear iteration pattern to initialize all tiles in the maze</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left"><code>maze_free()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear iteration pattern to visit all tiles in the 2D grid and <code>free()</code> any non-null paths in them</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Iteration to free all rows and the tiles array</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Checks and frees a non-null queue</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left"><code>maze_tile_blocked()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Performs bounds checks to ensure tile coordinates are within the maze</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Correct use of 2D indexing into the 2D tiles array to access the type of a tile</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left"><code>maze_print_tiles()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of <code>printf()</code> and format specifiers to print integer and character data</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear iteration pattern visiting all tiles in the 2D grid of the maze</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left"><code>maze_print_state()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Nested loops to print a character for each tile</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Case analysis so that tiles with path<sub>len</sub> evenly divisible by 10 are printed using letters</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Avoids many-case conditions and uses global arrays like <code>digit10_chars[] /  tiletype_chars[]</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear code that prints the axis labels for row/column</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Comments included to guide a reader through the complexities of the code</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-orgcd02a5c" class="outline-2">
<h2 id="orgcd02a5c"><span class="section-number-2">7</span> <b>Problem 3</b>: BFS Functions</h2>
<div class="outline-text-2" id="text-7">
<p>
This problem implements Breadth First Search on the maze. The
implementation is broken up into several functions with some specific
features.
</p>
</div>

<div id="outline-container-org4e14028" class="outline-3">
<h3 id="org4e14028"><span class="section-number-3">7.1</span> Step Functions</h3>
<div class="outline-text-3" id="text-7-1">
<p>
S iterates manipulating data at each step. To make it possible to
check that steps are taken correctly, the specific changes to process
a neighbor tile are condensed into the function
<code>maze_bfs_process_neighbor()</code> and the sequence of operations to expand
beyond a tile are also in a function, <code>maze_bfs_step()</code>. This allows
for easier testing to give some confidence that these operations are
correct before repeating them. The general hierarchy of the algorithm
is
</p>
<ul class="org-ul">
<li><code>maze_bfs_iterate()</code> repeatedly calls <code>maze_bfs_step()</code> until the
queue of search tiles is empty</li>
<li><code>maze_bfs_step()</code> repeatedly calls <code>maze_bfs_process_neighbor()</code> for
each direction of movement (North, South, etc.) from that tile.</li>
<li><code>maze_bfs_process_neighbor()</code> will process a single tile, adding a
path to when it is Found and ignoring out-of-bounds or previously
found tiles</li>
</ul>
</div>
</div>

<div id="outline-container-org6a8bc94" class="outline-3">
<h3 id="org6a8bc94"><span class="section-number-3">7.2</span> Logging</h3>
<div class="outline-text-3" id="text-7-2">
<p>
The functions here perform potentially many operations
that manipulate the internal state of Tiles and Mazes. To make
debugging them easier, some functions are required to print "LOG"
messages when the global variable <code>LOG_LEVEL</code> is set to certain
values.  Logging and debug messages are a common feature of many
programs as they enable diagnosis of problems more easily by
providing more detail information about how code proceeds. A simple
way to do conditional logging is with conditionals, as in
</p>
<div class="org-src-container">
<pre class="src src-c">  if(LOG_LEVEL &gt;= LOG_BFS_STATES){
    // print something here
  }
</pre>
</div>
<p>
The documentation comments for each function note what log messages to
print in their LOGGING sections.
</p>

<p>
Most of the tests set <code>LOG_LEVEL=LOG_ALL</code> which will print
everything. This is meant to make debugging easier.
</p>
</div>
</div>

<div id="outline-container-org33a95d6" class="outline-3">
<h3 id="org33a95d6"><span class="section-number-3">7.3</span> Required BFS Functions</h3>
<div class="outline-text-3" id="text-7-3">
<div class="org-src-container">
<pre class="src src-c">// FUNCTIONS FOR PROBLEM 3: Breadth First Search of the Maze
////////////////////////////////////////////////////////////////////////////////

void maze_bfs_init(maze_t *maze);
// PROBLEM 3: Initializes the maze for a BFS search. Adjusts the start
// tile: allocates it a length 0 path, sets its path_len to 0, and
// sets its state to FOUND. Allocates an empty rcqueue for the queue
// in the maze using an appropriate function and then adds the Start
// tile to it.
//
// LOGGING: If LOG_LEVEL &gt;= LOG_BFS_STATES, after initialization is
// complete. prints "BFS initialization compelte" and calls
// maze_print_state().
//
// NOTES: This function is called within maze_bfs_iterate() to set up
// the queue and Start tile before the search proceeds. It should not
// be called outside of that context except during some testing of its
// functionality and that of the BFS step function.
//
// EXAMPLE: The queue is initially empty (prints as null). After
//          calling bfs_init(), the Start tile is set to FOUND so
//          prints as its path_len of 0 and appears in the now
//          allocated queue.
//
// print_maze_state(maze);
//   ################:  0
//   #S             #:  1
//   # ### ###### # #:  2
//   # ### ##E  #   #:  3
//   # ### #### ##  #:  4
//   #              #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   null queue
// LOG_LEVEL = LOG_ALL;
// maze_bfs_init(maze);
// print_maze_state(maze);
//   LOG: BFS initialization complete
//   ################:  0
//   #0             #:  1
//   # ### ###### # #:  2
//   # ### ##E  #   #:  3
//   # ### #### ##  #:  4
//   #              #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 1
//   NN ROW COL
//    0   1   1

int maze_bfs_process_neighbor(maze_t *maze, int cur_row, int cur_col, direction_t dir);
// PROBLEM 3: Process the neighbor in direction `dir` from coordinates
// `cur_row/cur_col`. Calculates the adjacent tiles row/col
// coordinates using the row_delta[]/col_delta[] global array and
// `dir`.  If the neighbor tile is blocked according to the
// maze_tile_blocked() function, makes no changes and returns 0 as the
// position cannot be reached. If the neighbor tile has state FOUND,
// makes no changes and returns 0 as the tile has already been
// processed in the BFS. Otherwise changes the neighbor tile to be a
// Found tile: extends the current tile's path to the neighbor tile in
// the given direction, changes the neighbor tile's state to FOUND,
// and adds the neighbor tile to the maze search queue. This function
// is used in BFS to propogate paths to all non-blocked neighbor
// tiles and extend the search forntier.
//
// LOGGING:
// 1. If LOG_LEVEL &gt;= LOG_BFS_PATHS and the neighor tile's state
//    changes from NOTFOUND to FOUND, print a message like: 
//      LOG: Found tile at (4,10) with len 14 path: SSSSEEEEEEEEEN
//    with the coordinates, path_len, and COMPACT path for the newly
//    found tile.
// 2. If LOG_LEVEL &gt;= LOG_SKIPPED_TILES and the neighbor tile is
//    skipped as it is blocked or already found, print a message like
//    one of
//      LOG: Skipping BLOCKED tile at (6,13)
//      LOG: Skipping FOUND tile at (5,12)
//
// EXAMPLE:
// maze_print_state(maze);
//   ################:  0
//   #0123          #:  1
//   #1### ###### # #:  2
//   #2### ##E  #   #:  3
//   #3### #### ##  #:  4
//   #4             #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 2
//   NN ROW COL
//    0   1   4
//    1   5   1
// LOG_LEVEL = LOG_ALL; // above both LOG_BFS_PATHS and LOG_SKIPPED_TILES
// maze_bfs_process_neighbor(maze, 1, 4, NORTH);
//   LOG: Skipping BLOCKED tile at (0,4)
// maze_bfs_process_neighbor(maze, 1, 4, SOUTH);
//   LOG: Skipping BLOCKED tile at (2,4)
// maze_bfs_process_neighbor(maze, 1, 4, WEST);
//   LOG: Skipping FOUND tile at (1,3)
// maze_bfs_process_neighbor(maze, 1, 4, EAST);
//   LOG: Found tile at (1,5) with len 4 path: EEEE
// maze_print_state(maze);
//   ################:  0
//   #01234         #:  1
//   #1### ###### # #:  2
//   #2### ##E  #   #:  3
//   #3### #### ##  #:  4
//   #4             #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 2
//   NN ROW COL
//    0   1   4
//    1   5   1
//    2   1   5

int maze_bfs_step(maze_t *maze);
// PROBLEM 3: Processes the tile in BFS which is at the front of the
// maze search queue. For the front tile, iterates over the directions
// in the global dir_delta[] array from index DELTA_START to less than
// DELTA_COUNT which will be NORTH, SOUTH, WEST, EAST. Processes the
// neighbors in each of these directions with an appropriate
// function. Removes the front element of the search queue and
// returns 1. Note: if this function is called when the maze queue is
// empty, return 0 and print an error message though this case will
// not be tested and should not arise if other parts of the program
// are correct.
//
// LOGGING: 
// If LOG_LEVEL &gt;= LOG_BFS_STEPS, print a message like
//   LOG: processing neighbors of (5,1)
// at the start of the function.
//
// If LOG_LEVEL &gt;= LOG_BFS_STEPS, prints a message and uses
// maze_print_state() at the end of the function to show the maze
// after processing finishes as in:
//   LOG: maze state after BFS step
//   ################:  0
//   #01234         #:  1
//   #1### ###### # #:  2
//   #2### ##E  #   #:  3
//   #3### #### ##  #:  4
//   #45            #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 2
//   NN ROW COL
//    0   1   5
//    1   5   2
//
// EXAMPLE:
// maze_print_state(maze);
//   ################:  0
//   #0123456789a1  #:  1
//   #1###5###### # #:  2
//   #2###6##E  #   #:  3
//   #3###7#### ##  #:  4
//   #456789a12     #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 2
//   NN ROW COL
//    0   1  12
//    1   5   9
// LOG_LEVEL = LOG_ALL;
// maze_bfs_step(maze);
//   LOG: processing neighbors of (1,12)
//   LOG: maze state after BFS step
//   ################:  0
//   #0123456789a12 #:  1
//   #1###5######2# #:  2
//   #2###6##E  #   #:  3
//   #3###7#### ##  #:  4
//   #456789a12     #:  5
//   ################:  6
//   0123456789012345
//   0         1     
//   queue count: 3
//   NN ROW COL
//    0   5   9
//    1   2  12
//    2   1  13

void maze_bfs_iterate(maze_t *maze);
// PROBLEM 3: Initializes a BFS on the maze and iterates BFS steps
// until the queue for the maze is empty and the BFS is complete. Each
// iteration of the algorithm loop will process all neighbors of a
// FOUND tile.  This will calculate paths from the Start tile to all
// other tiles including the End tile.
//
// LOGGING: If LOG_LEVEL &gt;= LOG_BFS_STEPS prints the step number for
// each iteration of the loop as
//   LOG: BFS STEP 45
// where the number starts at 1 and increases each loop iteration.
//
// See EXAMPLES for main() to get an idea of output for iteration.
//
// NOTES: This function will call several of the preceding functions
// to initialize and proceed with the BFS.

int maze_set_solution(maze_t *maze);
// PROBLEM 3: Uses the path stored in the End tile to visit each tile
// on the solution path from Star to End and make them as ONPATH to
// show the solution path.  If the End tile has a NULL path, returns 0
// and makes no changes to the maze. Otherwise, visits each direction
// in the End tile's path and, beginning at the Start tile, "moves" in
// the direction indicated and chcnges the nextf tile's state to
// ONPATH. Returns 1 on changing the state of tiles to show the
// solution path.  This function is used to set up printing the
// solution path later.
//
// CONSTRAINT: Makes use of the row_delta[] / col_delta[] global
// arrays when "moving" rather than using multi-way conditional. For
// example, if the current coordinates are (3,5) and the path[i]
// element is WEST, uses row_delta[WEST] which is -1 and
// col_delta[WEST] which is 0 to update the coordinates to (3,4) which
// is one tile to the WEST. Solutions that use a multi-way conditional
// with cases for NORTH, SOUTH, etc. will be penalized.
//
// NOTE: This function may temporarily change the state of the END
// tile to ONPATH as indicated in the log messages below. Before
// finishing, the state of the END tile is changed from ONPATH to END.
// 
// LOGGING: If the LOG_LEVEL &gt;= LOG_SET_SOLUTION, prints out 
// 
// 1. Once at the beginning of the solution construction
//   LOG: solution START at (1,1)
// with the coordinates substituted for the actual START coordinates.
// 
// 2. For every element of the End tile path[] array
//   LOG: solution path[5] is EAST, set (5,3) to ONPATH
// with items like the index, direction, and coordinates replaced with
// appropriate data via printf().  Use the direction_verbose_strs[]
// to print strings of the directions.
//
// 3. Once at the end of solution construction:
//   LOG: solution END at (3,8)
// with the coordinates substituted for the actual END coordinates.
// 
// EXAMPLE:
// maze_print_tiles(maze);
//   maze: 7 rows 16 cols
//         (1,1) start
//         (3,8) end
//   maze tiles:
//   ################
//   #S             #
//   # ### ###### # #
//   # ### ##E  #   #
//   # ### #### ##  #
//   #              #
//   ################
// 
// LOG_LEVEL = LOG_SET_SOLUTION;
// maze_set_solution(maze);
//   LOG: solution START at (1,1)
//   LOG: solution path[0] is SOUTH, set (2,1) to ONPATH
//   LOG: solution path[1] is SOUTH, set (3,1) to ONPATH
//   LOG: solution path[2] is SOUTH, set (4,1) to ONPATH
//   LOG: solution path[3] is SOUTH, set (5,1) to ONPATH
//   LOG: solution path[4] is EAST, set (5,2) to ONPATH
//   LOG: solution path[5] is EAST, set (5,3) to ONPATH
//   LOG: solution path[6] is EAST, set (5,4) to ONPATH
//   LOG: solution path[7] is EAST, set (5,5) to ONPATH
//   LOG: solution path[8] is EAST, set (5,6) to ONPATH
//   LOG: solution path[9] is EAST, set (5,7) to ONPATH
//   LOG: solution path[10] is EAST, set (5,8) to ONPATH
//   LOG: solution path[11] is EAST, set (5,9) to ONPATH
//   LOG: solution path[12] is EAST, set (5,10) to ONPATH
//   LOG: solution path[13] is NORTH, set (4,10) to ONPATH
//   LOG: solution path[14] is NORTH, set (3,10) to ONPATH
//   LOG: solution path[15] is WEST, set (3,9) to ONPATH
//   LOG: solution path[16] is WEST, set (3,8) to ONPATH
//   LOG: solution END at (3,8)
// 
// maze_print_tiles(maze);
//   maze: 7 rows 16 cols
//         (1,1) start
//         (3,8) end
//   maze tiles:
//   ################
//   #S             #
//   #.### ###### # #
//   #.### ##E..#   #
//   #.### ####.##  #
//   #..........    #
//   ################

////////////////////////////////////////////////////////////////////////////////

</pre>
</div>
</div>
</div>

<div id="outline-container-orgb8cb469" class="outline-3 grading 30">
<h3 id="orgb8cb469"><span class="section-number-3">7.4</span> Grading Criteria for Problem 3&#xa0;&#xa0;&#xa0;<span class="tag"><span class="grading">grading</span>&#xa0;<span class="30">30</span></span></h3>
<div class="outline-text-3" id="text-7-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-left">Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">AUTOMATED TESTS via <code>make test-prob3</code></td>
</tr>

<tr>
<td class="org-right">15</td>
<td class="org-left">Runs tests in <code>test_mazesolve3.org / test_mazesolve_funcs.c</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Runs all code under Valgrind to ensure that no memory errors are present.</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">1 point per test passed</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">MANUAL INSPECTION</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><a href="https://docs.google.com/document/d/1V6W1GBcL2cgOoiIeaz5V83U3BUbfK7wqYia71i0AeXQ/edit?usp=sharing">Code Style</a>: Functions adhere to <a href="https://docs.google.com/document/d/1V6W1GBcL2cgOoiIeaz5V83U3BUbfK7wqYia71i0AeXQ/edit?usp=sharing">CMSC 216 C Coding Style Guide</a> which dictates</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">reasonable indentation, commenting, consistency of curly usage, etc.</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left"><code>maze_bfs_init()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Initializes the queue and start tile in preparation for BFS</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Appropriate log message(s) printed</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left"><code>maze_bfs_process_neighbor()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Utilizes the global <code>row_deltas[]</code> array to determine row/col change appropriate to neighbor direction</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Makes use of previously written functions for queue manipulation, blocked tile checks, etc.</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Appropriate log message(s) printed</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left"><code>maze_bfs_step()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Makes use of previously written functions for queue manipulation, neigbhbor processing etc.</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear iteration pattern over directions in the <code>maze_dir_delta[]</code> array form <code>DELTA_START</code> to <code>DELTA_COUNT</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Appropriate log message(s) printed</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left"><code>maze_bfs_iterate()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear iteration pattern while the maze search queue is not empty</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Makes use of previously written functions for search data initialization, etc.</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Appropriate log message(s) printed</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left"><code>maze_set_solution()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Checks for NULL path in which case no solution is present</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clear iteration pattern over the path to End tile</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of the <code>row_delta[] / col_delta[]</code> arrays to avoid many-case conditionals while setting path</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Appropriate log message(s) printed</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-org57b1965" class="outline-2">
<h2 id="org57b1965"><span class="section-number-2">8</span> <b>Problem 4</b>: Data Files and Main</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org6a48a9b" class="outline-3">
<h3 id="org6a48a9b"><span class="section-number-3">8.1</span> Maze Data Files</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Maze data files follow a simple format which specifies the rows and
columns in the maze in the first line, follows with a fixed indication
of the start of the tiles section, and all subsequent lines are rows
of the maze. This format is chosen as it allows easy processing of the
data: reading the first line gives the amount of memory required for
all tiles which an be allocated and the remainder of the file read
into the allocated space. Start/End tiles are marked with <code>S/E</code> with
Open tiles as spaces and wall tiles as <code>#</code>.
</p>

<p>
Below are a few examples of files. 
</p>
</div>

<div id="outline-container-orgef95d17" class="outline-4">
<h4 id="orgef95d17">EXAMPLE: maze-room1.txt</h4>
<div class="outline-text-4" id="text-orgef95d17">
<div class="org-src-container">
<pre class="src src-python">rows: 7 cols: 19
tiles:
###################
#          #    # #
# ###  ##    ## # #
#  ##  # S #  # # #
##  #  #####  # # #
#E  #         #   #
###################
</pre>
</div>
<p>
A fairly standard maze. To make it easier to visualize the boundaries,
many mazes include a border of Wall <code>#</code> tiles around the edge as is
done here.
</p>
</div>
</div>

<div id="outline-container-org52653a7" class="outline-4">
<h4 id="org52653a7">EXAMPLE: maze-edge1.txt</h4>
<div class="outline-text-4" id="text-org52653a7">
<div class="org-src-container">
<pre class="src src-python">rows: 7 cols: 16
tiles:
############## S
#               
# ### ###### # #
# ### ##E  #   #
# ### #### ##  #
#              #
################
</pre>
</div>
<p>
This maze is similar but does not have explicit wall tiles all the way
around it. Rather, the <code>S</code> start tile is located at the edge. Going
East or North will be out of bounds and a dead end to the search.
</p>
</div>
</div>

<div id="outline-container-org04640df" class="outline-4">
<h4 id="org04640df">EXAMPLE: maze-big-mult1.txt</h4>
<div class="outline-text-4" id="text-org04640df">
<div class="org-src-container">
<pre class="src src-python">rows: 21 cols: 51
tiles:
###################################################
#S  #                                     #       #
### ########### ################# ##### # # ##### #
# #     #     #       #       #   #   # #   #   # #
# ##### # ### # ##### # ##### # ### # # ##### ### #
#     #   # # #     # #   # #   #   # #   #     # #
# ######### # ####### ### # ##### ### ### ### # # #
# #         # #                         #   # #   #
# # ##### ### # ##### ####### ######### ### # #####
# #   # #     # #   # #       #     #     # # #   #
# ### # ####### # # ### ####### ### ####### # # # #
#   #   #     #   #   # #       #           # # # #
# ##### # ### # ##### # # ######### ######### ### #
#       #   #   #   #   #               #   #     #
# # ##########  # # # ##### ########### # # ##### #
# #   #           # # #   #     #     # # #     # #
# ### ### ######### # # # # ##### ### # # ##### # #
#   #     # #     # # # # # #   # # #   # #   #   #
# # ####### # # ### ### # ### # # # ##### # # #####
# #           #         #     #   #         #     E
###################################################
</pre>
</div>
<p>
This is a large maze that would take a human reader some time to
complete and cause some second-guesses on whether the solution path
found is indeed the shortest path from Start to End. That's why we
write programs, to provide relief for tedious tasks and give more
confidence in correct answers.
</p>
</div>
</div>

<div id="outline-container-org9511bcc" class="outline-4">
<h4 id="org9511bcc">Other Examples</h4>
<div class="outline-text-4" id="text-org9511bcc">
<p>
There are a variety of other examples of data files in the <code>data/</code>
directory for the project. Many of these files are used in testing so
DON'T DELETE THE data/ DIRECTORY.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcf66c72" class="outline-3">
<h3 id="orgcf66c72"><span class="section-number-3">8.2</span> Loading Maze Data</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Data is loaded from files into a Maze via the following
function. <b>This is a fairly complex function</b> so expect to take some
time to get it right. Also be conscious of the constraint that <b>you
must comment your code for full credit</b> on this function.
</p>

<div class="org-src-container">
<pre class="src src-c">maze_t *maze_from_file(char *fname);
// PROBLEM 4: Read a maze from a text file. The text file format
// starts with the size of the maze and then contains its tiles. An
// example is:
//
// rows: 7 cols: 19
// tiles:
// ###################
// #          #    # #
// # ###  ##    ## # #
// #  ##  # S #  # # #
// ##  #  #####  # # #
// #E  #         #   #
// ###################   
//
// If `fname` cannot be opened as a file, returns NULL. Otherwise
// proceeds to read row/col numbers, allocate a maze of appropriate
// size, and read characters into it. Each tile read has its state
// changed per the character it is shown as. The global array
// tiletype_chars[] should be searched to find the character read for
// a tile and the index at which it is found set to be the tile state;
// e.g. the character 'S' was read which appears at index 4 of
// tiletype_chars[] so the tile.type = 4 which is START in the
// tiletype enumeration.
//
// CONSTRAINT: You must use fscanf() for this function. 
//
// CONSTRAINT: You MUST comment your code to describe the intent of
// blocks of code. Full credit comments will balance some details with
// broad descriptions of blocks of code.  Missing comments or pedantic
// comments which describe every code line with unneeded detail will
// not receive full credit. Aim to make it easy for a human reader to
// scan your function to find a specific point of interest such as
// where a tile type is determined or when a row is finished
// processing. Further guidance on good/bad comments is in the C
// Coding Style Guide.
//
// LOGGING: If LOG_LEVEL &gt;= LOG_FILE_LOAD prints messages to help
// track parsing progress. There are many log messages required as
// they will be useful for debugging parsing problems that always
// arise when reading such data.
//
// LOG: expecting 6 rows and 9 columns
//   Printed after reading the first line indicating rows/cols in the
//   maze.
//
// LOG: beginning to read tiles
//   Printed after reading the "tiles\n" line when the main loop is
//   about to start reading character/tiles.
//
// LOG: (2,1) has character ' ' type 2
//   Printed with the coordinates of each character/tile that is
//   read. The coordinates, character read, and an integer indicating
//   the type decided upon for the tile is shown.
//
// LOG: (2,4) has character 'S' type 4
// LOG: setting START at (2,4)
//   Printed when the Start tile, marked with an S, is found
//
// LOG: (3,7) has character 'E' type 5
// LOG: setting END at (3,7)
//   Printed when the End tile, marked with an E, is found
//
// LOG: finished reading row 4 of tiles
//   Printed after reading each row of the maze file to help track
//   progress.
//
// NOTES: The fscanf() function is essential for this function. A call
// like fscanf(fin,"age: %d name: %s\n",&amp;num, str) will read the literal
// word "age:" then a number, then the literal word "name:" and a
// string.  Use this facility to parse the simple format. It is fine
// to read a literal string only as in fscanf(fin,"skip this stuff\n")
// which will bypass that exact line in a file.  Use the format
// specifier %c to read single characters as you process the tiles as
// this is the easiest mechanism to work on the character parsing of
// the maze tiles.  Keep in mind that all lines of the maze will end
// with the character '\n' which must be read past in order to get to
// the next row.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc1fba46" class="outline-3">
<h3 id="orgc1fba46"><span class="section-number-3">8.3</span> The Main Function</h3>
<div class="outline-text-3" id="text-8-3">
<p>
The final part of the Maze Solving application is to code a <code>main()</code>
function. Unlike the "service" or "helper" functions, <code>main()</code> should
be in its own file, <code>mazesolve_main.c</code>.  Create this file, and a <code>main()</code>
prototype that allows for command line arguments to be passed
in. Don't forget to include the project header as otherwise this
separate file will not be able to use the various functions in
<code>mazesolve_funcs.c</code>.
</p>
<div class="org-src-container">
<pre class="src src-c">#include "mazesolve.h"
int main(int argc, char *argv[]){
  ...
}
</pre>
</div>
<p>
The <code>mazesolve_main.c</code> file will be compiled to <code>mazesolve_main</code> using
the included <code>Makefile</code> and this program has two required command line
forms it must support.
</p>
<ol class="org-ol">
<li>Only the data file with the maze is passed in</li>
<li>A <code>-log N</code> option appears preceding the data file. This sets the
global variable <code>LOG_LEVEL</code> which will trigger additional output to
be printed.</li>
</ol>

<p>
Examples of these two command line forms are below.
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt;&gt; ./mazesolve_main data/maze-small-twopath1.txt   # Form 1: argc=2, only data file 
maze: 5 rows 5 cols                                # on command line
      (1,2) start
      (3,2) end
maze tiles:
#####
# S #
# # #
# E #
#####
SOLUTION:
maze: 5 rows 5 cols
      (1,2) start
      (3,2) end
maze tiles:
#####
#.S #
#.# #
#.E #
#####
path length: 4
 0: WEST
 1: SOUTH
 2: SOUTH
 3: EAST



&gt;&gt; ./mazesolve_main -log 1 data/maze-small-twopath1.txt   # form 2: argc=4, -log option passed  
maze: 5 rows 5 cols                                       # to specify log level, then data file
      (1,2) start
      (3,2) end
maze tiles:
#####
# S #
# # #
# E #
#####
LOG: BFS STEP 1                                           # Log messages for BFS steps printed
LOG: processing neighbors of (1,2)
LOG: BFS STEP 2
LOG: processing neighbors of (1,1)
LOG: BFS STEP 3
LOG: processing neighbors of (1,3)
LOG: BFS STEP 4
LOG: processing neighbors of (2,1)
LOG: BFS STEP 5
LOG: processing neighbors of (2,3)
LOG: BFS STEP 6
LOG: processing neighbors of (3,1)
LOG: BFS STEP 7
LOG: processing neighbors of (3,3)
LOG: BFS STEP 8
LOG: processing neighbors of (3,2)
SOLUTION:
maze: 5 rows 5 cols
      (1,2) start
      (3,2) end
maze tiles:
#####
#.S #
#.# #
#.E #
#####
path length: 4
 0: WEST
 1: SOUTH
 2: SOUTH
 3: EAST
</pre>
</div>

<p>
To get insight into how command line arguments are received in the
<code>argc / argv[]</code> parameters to <code>main()</code>, study the provided
<code>cmdline_args.c</code> program which prints command line arguments passed to
its executable.
</p>
<div class="org-src-container">
<pre class="src src-sh">&gt;&gt; gcc cmdline_args.c
&gt;&gt; ./a.out
There are 1 command line arguments
arg 0: './a.out'
&gt;&gt; ./a.out apple banana peach
There are 4 command line arguments
arg 0: './a.out'
arg 1: 'apple'
arg 2: 'banana'
arg 3: 'peach'
...
</pre>
</div>
</div>
</div>

<div id="outline-container-org0b942ca" class="outline-3 grading 20">
<h3 id="org0b942ca"><span class="section-number-3">8.4</span> Grading Criteria for Problem 4&#xa0;&#xa0;&#xa0;<span class="tag"><span class="grading">grading</span>&#xa0;<span class="20">20</span></span></h3>
<div class="outline-text-3" id="text-8-4">
<p>
The following criteria will be checked.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Weight</th>
<th scope="col" class="org-left">Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">AUTOMATED TESTS via <code>make test-prob4</code></td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">Runs tests in <code>test_mazesolve4.org / test_mazesolve_funcs.c</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Runs all code under Valgrind to ensure that no memory errors are present.</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">1 point per test passed</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">MANUAL INSPECTION</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left"><a href="https://docs.google.com/document/d/1V6W1GBcL2cgOoiIeaz5V83U3BUbfK7wqYia71i0AeXQ/edit?usp=sharing">Code Style</a>: Functions adhere to <a href="https://docs.google.com/document/d/1V6W1GBcL2cgOoiIeaz5V83U3BUbfK7wqYia71i0AeXQ/edit?usp=sharing">CMSC 216 C Coding Style Guide</a> which dictates</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">reasonable indentation, commenting, consistency of curly usage, etc.</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left"><code>maze_from_file()</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Includes clear comments indicating stages of file processing  / what is being read or done</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Checks for failure to open a file and returns</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clearly marked code sections to read header information for rows/cols and "tiles:\n"</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Clearly marked code sections to process rows of the maze and tiles</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of the <code>tiletype_chars[]</code> array or equivalent data array to set tile types from characters</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left"><code>main()</code> in <code>mazesolve_main.c</code></td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Case analysis of arguments to detect 2 or 4 arguments</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Use of <code>atoi()</code> to convert strings to <code>ints</code> when needed</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">Checks for failure to load data file</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org23ecde7" class="outline-2">
<h2 id="org23ecde7"><span class="section-number-2">9</span> <a id="orgce96cd6"></a> Optional MAKEUP Credit (10pts)</h2>
<div class="outline-text-2" id="text-9">
<p>
An optional MAKEUP credit problem <i>may</i> be added after the initial
project release. This will be announced and added to this section for
those interested.
</p>
</div>
</div>

<div id="outline-container-org8fb0715" class="outline-2">
<h2 id="org8fb0715"><span class="section-number-2">10</span> Project Submission</h2>
<div class="outline-text-2" id="text-10">
</div>

<div id="outline-container-org4e1c678" class="outline-3">
<h3 id="org4e1c678"><span class="section-number-3">10.1</span> <a id="org578d759"></a> Submit to Gradescope</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Some of the pictures below are dated and contain out of sync info
like:
</p>
<ul class="org-ul">
<li>'Assignment' rather than'Project'</li>
<li>Class code 'CSCI 2021' rather than 'CMSC216'</li>
<li>Mention some files that are not part of the current project</li>
<li>May indicate some other zip name when <code>p1-complete.zip</code> is that
default name of the zip for completed projects.</li>
</ul>
<p>
However, most students should have no trouble adapting these
instructions which amount to: <code>make zip</code> then upload the zip to
Gradescope. 
</p>

<ol class="org-ol">
<li><p>
In a terminal, change to your project code directory and type <b>make
zip</b> which will create a zip file of your code. A session should
look like this:
</p>
<div class="org-src-container">
<pre class="src src-sh">   &gt;&gt; cd 216-sync/p1-code         # location of assignment code

   &gt;&gt; ls 
   Makefile    mazesolve_main.c  mazesolve_funcs.c  data/
   ...

   &gt;&gt; make zip                     # create a zip file using Makefile target
   rm -f p1-complete.zip
   cd .. &amp;&amp; zip "p1-code/p1-complete.zip" -r "p1-code"
     adding: p1-code/ (stored 0%)
     adding: p1-code/Makefile (deflated 68%)
     adding: p1-code/test_prob1.org (deflated 69%)
     ...
   Zip created in p1-complete.zip

   &gt;&gt; ls p1-complete.zip
   p1-complete.zip
</pre>
</div></li>
<li><p>
Log into <a href="https://www.gradescope.com/">Gradescope</a> and locate and click 'Project 1' which will
open up submission
</p>
<div class="org-center">

<div id="orgb97d5a7" class="figure">
<p><img src="gradescope01.png" alt="gradescope01.png" style="max-width:100%;" />
</p>
</div>
</div></li>
<li><p>
Click on the 'Drag and Drop' text which will open a file selection
dialog; locate and choose your <code>p1-complete.zip</code> file (<i>The
pictures below may use a different zip name like <code>a1-code.zip</code></i>)
</p>
<div class="org-center">

<div id="org7df51e9" class="figure">
<p><img src="gradescope02.png" alt="gradescope02.png" style="max-width:100%;" />
</p>
</div>
</div></li>
<li><p>
This will show the contents of the Zip file and should include your
C source files along with testing files and directories. 
</p>
<div class="org-center">

<div id="orgc6bb3f7" class="figure">
<p><img src="gradescope03.png" alt="gradescope03.png" style="max-width:100%;" />
</p>
</div>
</div></li>
<li><p>
Click 'Upload' which will show progress uploading files.  It may
take a few seconds before this dialog closes to indicate that the
upload is successful. Note: there is a limit of 256 files per
upload; normal submissions are not likely to have problems with
this but you may want to make sure that nothing has gone wrong such
as infinite loops creating many files or incredibly large files. 
</p>

<p>
<b>WARNING</b>: There is a limit of 256 files per zip. Doing <code>make zip</code>
will warn if this limit is exceeded but uploading to Gradescope
will fail without any helpful messages if you upload more the 256
files in a zip. 
</p>

<div class="org-center">

<div id="org7abcf78" class="figure">
<p><img src="gradescope04.png" alt="gradescope04.png" style="max-width:100%;" />
</p>
</div>
</div></li>

<li><p>
Once files have successfully uploaded, the Autograder will begin
running the command line tests and recording results.  These are
the same tests that are run via <code>make test</code>.   
</p>
<div class="org-center">

<div id="orgd036af1" class="figure">
<p><img src="gradescope05.png" alt="gradescope05.png" style="max-width:100%;" />
</p>
</div>
</div></li>
<li><p>
When the tests have completed, results will be displayed
summarizing scores along with output for each batch of tests.
</p>
<div class="org-center">

<div id="org8f747fd" class="figure">
<p><img src="gradescope06.png" alt="gradescope06.png" style="max-width:100%;" />
</p>
</div>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-org45dfb29" class="outline-3">
<h3 id="org45dfb29"><span class="section-number-3">10.2</span> Late Project Submission Policies</h3>
<div class="outline-text-3" id="text-10-2">
<p>
You may wish to review the policy on late project submission which
will cost 1 Engagement Point per day late. <b>No projects will be
accepted more than 48 hours after the deadline.</b>
</p>

<p>
<a href="https://www.cs.umd.edu/~profk/216/syllabus.html#late-submission">https://www.cs.umd.edu/~profk/216/syllabus.html#late-submission</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr/> <i> <a href="https://www.umd.edu/web-accessibility" title="UMD Web Accessibility">Web Accessibility</a> <br/> Author: Chris Kauffman (<a href="mailto:profk@umd.edu">profk@umd.edu</a>) <br/> Date: 2025-02-12 Wed 20:33 <br/> </i>
</div>
</body>
</html>
